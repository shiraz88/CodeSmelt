
# Project Source Code Concatenation
# Generated on: 2025-02-15 23:27:30
# Project path: /home/runner/workspace



# File: extensions.py
================================================================================

"""
Source code file extension configurations
"""

# Common source code file extensions
SOURCE_EXTENSIONS = {
    # Web
    '.js', '.ts', '.jsx', '.tsx', '.vue', '.svelte',
    '.html', '.htm', '.css', '.scss', '.sass', '.less',
    
    # Python
    '.py', '.pyi', '.pyx',
    
    # Java/Kotlin
    '.java', '.kt', '.groovy',
    
    # C-family
    '.c', '.cpp', '.h', '.hpp', '.cc',
    
    # C#
    '.cs', '.cshtml', '.csx',
    
    # Ruby
    '.rb', '.erb',
    
    # PHP
    '.php', '.php5', '.phtml',
    
    # Go
    '.go',
    
    # Rust
    '.rs',
    
    # Swift
    '.swift',
    
    # Shell
    '.sh', '.bash', '.zsh',
    
    # Config/Data
    '.json', '.yaml', '.yml', '.toml', '.xml',
    '.conf', '.ini', '.env',
    
    # Documentation
    '.md', '.rst', '.txt'
}

# Files to always ignore
IGNORE_PATTERNS = {
    # Build outputs
    'build/*', 'dist/*', 'target/*', 'bin/*',
    '*.pyc', '__pycache__/*', '*.class',
    
    # Dependencies
    'node_modules/*', 'vendor/*', 'venv/*',
    
    # IDE files
    '.idea/*', '.vscode/*', '*.swp',
    
    # Package files
    'package-lock.json', 'yarn.lock',
    'Pipfile.lock', 'poetry.lock',
    
    # Large data files
    '*.csv', '*.json.gz', '*.sql',
    
    # Binary/Media files
    '*.pdf', '*.jpg', '*.png', '*.gif',
    '*.mp3', '*.mp4', '*.mov', '*.bin',
    '*.exe', '*.dll', '*.so', '*.dylib'
}


# File: pyproject.toml
================================================================================

[project]
name = "repl-nix-workspace"
version = "0.1.0"
description = "Add your description here"
requires-python = ">=3.11"
dependencies = [
    "gitignore-parser>=0.1.11",
]


# File: requirements.txt
================================================================================

gitignore_parser==0.1.11

# File: codesmelt.py
================================================================================

#!/usr/bin/env python3
"""
CodeSmelt: Source Code Concatenator

This tool melts down source code files from a git project into a single file,
including directory structure information.
"""

import argparse
import sys
from pathlib import Path
import os
from typing import Set, List, Optional
import fnmatch
from datetime import datetime
import gitignore_parser
from extensions import SOURCE_EXTENSIONS, IGNORE_PATTERNS

class CodeSmelt:
    def __init__(self, project_path: str, output_file: str):
        self.project_path = Path(project_path).resolve()
        self.output_file = Path(output_file)
        self.gitignore_matcher = self._setup_gitignore()
        self.debug = False
        self.include_structure = True

    def _setup_gitignore(self) -> Optional[callable]:
        """Setup gitignore matcher if .gitignore exists"""
        gitignore_path = self.project_path / '.gitignore'
        if gitignore_path.exists():
            try:
                return gitignore_parser.parse_gitignore(gitignore_path)
            except Exception as e:
                print(f"Warning: Failed to parse .gitignore: {e}")
        return None

    def _should_include_file(self, file_path: Path) -> bool:
        """Check if file should be included based on extension and ignore rules"""
        # Skip common virtual environment and system directories
        excluded_dirs = {
            '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
            '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
            'dist', 'build', 'target'
        }

        try:
            # Convert to relative path for checking
            try:
                rel_path = file_path.relative_to(self.project_path)
            except ValueError:
                if self.debug:
                    print(f"Debug: Skipping file outside project path: {file_path}")
                return False

            # Check for excluded directories in the path
            if any(part in excluded_dirs for part in file_path.parts):
                if self.debug:
                    print(f"Debug: Skipping excluded directory: {file_path}")
                return False

            # Check if file extension is in whitelist
            if file_path.suffix.lower() not in SOURCE_EXTENSIONS:
                if self.debug:
                    print(f"Debug: Skipping non-source file: {file_path}")
                return False

            # Check custom ignore patterns
            for pattern in IGNORE_PATTERNS:
                if fnmatch.fnmatch(str(rel_path), pattern):
                    if self.debug:
                        print(f"Debug: Skipping ignored pattern {pattern}: {file_path}")
                    return False

            # Check .gitignore if available
            if self.gitignore_matcher:
                try:
                    should_include = not self.gitignore_matcher(str(file_path))
                    if self.debug and not should_include:
                        print(f"Debug: Skipping gitignored file: {file_path}")
                    return should_include
                except Exception as e:
                    print(f"Warning: gitignore matching failed for {file_path}: {e}")
                    return True

            if self.debug:
                print(f"Debug: Including file: {file_path}")
            return True

        except Exception as e:
            print(f"Warning: Error checking file {file_path}: {e}")
            return False

    def _get_file_content(self, file_path: Path) -> str:
        """Read file content with proper encoding handling"""
        try:
            # Try UTF-8 first
            with open(file_path, 'r', encoding='utf-8') as f:
                return f.read()
        except UnicodeDecodeError:
            try:
                # Fallback to latin-1
                with open(file_path, 'r', encoding='latin-1') as f:
                    return f.read()
            except Exception as e:
                print(f"Warning: Failed to read {file_path}: {e}")
                return f"ERROR: Could not read file {file_path}\n"

    def _generate_directory_structure(self) -> str:
        """Generate a tree-like directory structure"""
        structure = ["Directory Structure:", ""]

        def add_to_tree(path: Path, prefix: str = ""):
            # Skip excluded directories
            excluded_dirs = {
                '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
                '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
                'dist', 'build', 'target'
            }
            if path.name in excluded_dirs:
                return

            # Add files first
            files = sorted([p for p in path.iterdir() if p.is_file()])
            included_files = [f for f in files if self._should_include_file(f)]

            for idx, file in enumerate(included_files):
                is_last = idx == len(included_files) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {file.name}")

            # Then add directories
            dirs = sorted([p for p in path.iterdir() if p.is_dir()])
            included_dirs = [d for d in dirs if d.name not in excluded_dirs]

            for idx, dir in enumerate(included_dirs):
                is_last = idx == len(included_dirs) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {dir.name}/")
                add_to_tree(dir, prefix + ("    " if is_last else "│   "))

        add_to_tree(self.project_path)
        return "\n".join(structure)

    def concatenate(self, debug: bool = False):
        """Main method to concatenate all source files"""
        self.debug = debug
        if not self.project_path.exists():
            print(f"Error: Project path {self.project_path} does not exist")
            return False

        try:
            with open(self.output_file, 'w', encoding='utf-8') as out:
                # Write header
                header = f"""
# Project Source Code Concatenation
# Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
# Project path: {self.project_path}

"""
                out.write(header)

                # Write directory structure if enabled
                if self.include_structure:
                    out.write(self._generate_directory_structure())
                    out.write("\n\n" + "="*80 + "\n\n")

                # Process all files
                file_count = 0
                for file_path in self.project_path.rglob('*'):
                    if file_path.is_file() and self._should_include_file(file_path):
                        rel_path = file_path.relative_to(self.project_path)

                        # Write file header
                        out.write(f"\n\n# File: {rel_path}\n")
                        out.write("="*80 + "\n\n")

                        # Write file content
                        content = self._get_file_content(file_path)
                        out.write(content)
                        file_count += 1

                print(f"Successfully melted {file_count} files to {self.output_file}")
                return True

        except Exception as e:
            print(f"Error during melting: {e}")
            return False

def main():
    parser = argparse.ArgumentParser(
        description="CodeSmelt: Melt down your git project's source code into a single file",
        usage="%(prog)s project_path [output_file] [-o OUTPUT] [-d] [-n]"
    )

    # Add the project path as required positional argument
    parser.add_argument(
        "project_path",
        help="Path to the git project directory"
    )

    # Add optional positional argument for output file
    parser.add_argument(
        "output_file",
        nargs="?",  # Make it optional
        help="Output file path (alternative to -o)",
        default=None
    )

    # Keep the original -o option for backward compatibility
    parser.add_argument(
        "-o", "--output",
        help="Output file path (default: concatenated_source.txt)",
        default=None
    )

    parser.add_argument(
        "-d", "--debug",
        action="store_true",
        help="Enable debug logging"
    )

    parser.add_argument(
        "-n", "--no-structure",
        action="store_true",
        help="Omit directory structure from output"
    )

    args = parser.parse_args()

    # Determine the output file path, prioritizing command line arguments
    output_file = args.output or args.output_file or "concatenated_source.txt"

    concatenator = CodeSmelt(args.project_path, output_file)
    concatenator.include_structure = not args.no_structure
    success = concatenator.concatenate(debug=args.debug)
    sys.exit(0 if success else 1)

if __name__ == "__main__":
    main()

# File: test_with_structure.txt
================================================================================


# Project Source Code Concatenation
# Generated on: 2025-02-15 23:26:14
# Project path: /home/runner/workspace

Directory Structure:

├── README.md
├── codesmelt.py
├── extensions.py
├── pyproject.toml
├── requirements.txt
└── test_with_structure.txt
└── assets/

================================================================================



# File: extensions.py
================================================================================

"""
Source code file extension configurations
"""

# Common source code file extensions
SOURCE_EXTENSIONS = {
    # Web
    '.js', '.ts', '.jsx', '.tsx', '.vue', '.svelte',
    '.html', '.htm', '.css', '.scss', '.sass', '.less',
    
    # Python
    '.py', '.pyi', '.pyx',
    
    # Java/Kotlin
    '.java', '.kt', '.groovy',
    
    # C-family
    '.c', '.cpp', '.h', '.hpp', '.cc',
    
    # C#
    '.cs', '.cshtml', '.csx',
    
    # Ruby
    '.rb', '.erb',
    
    # PHP
    '.php', '.php5', '.phtml',
    
    # Go
    '.go',
    
    # Rust
    '.rs',
    
    # Swift
    '.swift',
    
    # Shell
    '.sh', '.bash', '.zsh',
    
    # Config/Data
    '.json', '.yaml', '.yml', '.toml', '.xml',
    '.conf', '.ini', '.env',
    
    # Documentation
    '.md', '.rst', '.txt'
}

# Files to always ignore
IGNORE_PATTERNS = {
    # Build outputs
    'build/*', 'dist/*', 'target/*', 'bin/*',
    '*.pyc', '__pycache__/*', '*.class',
    
    # Dependencies
    'node_modules/*', 'vendor/*', 'venv/*',
    
    # IDE files
    '.idea/*', '.vscode/*', '*.swp',
    
    # Package files
    'package-lock.json', 'yarn.lock',
    'Pipfile.lock', 'poetry.lock',
    
    # Large data files
    '*.csv', '*.json.gz', '*.sql',
    
    # Binary/Media files
    '*.pdf', '*.jpg', '*.png', '*.gif',
    '*.mp3', '*.mp4', '*.mov', '*.bin',
    '*.exe', '*.dll', '*.so', '*.dylib'
}


# File: pyproject.toml
================================================================================

[project]
name = "repl-nix-workspace"
version = "0.1.0"
description = "Add your description here"
requires-python = ">=3.11"
dependencies = [
    "gitignore-parser>=0.1.11",
]


# File: requirements.txt
================================================================================

gitignore_parser==0.1.11

# File: README.md
================================================================================

# CodeSmelt: Source Code Concatenator

![CodeSmelt Logo](assets/CodeSmeltLogo.jpg)

**CodeSmelt** is a command-line tool that “melts down” your Git project’s source code into a single, well-organized file. It not only concatenates source files but also embeds a tree-like directory structure to help you quickly understand your project’s layout. This is especially useful for code analysis, preparing inputs for language models, or sharing project snapshots.

---

## Table of Contents

- [Features](#features)
- [Installation](#installation)
- [Usage](#usage)
  - [Basic Usage](#basic-usage)
  - [Custom Output & Debug Mode](#custom-output--debug-mode)
- [Configuration](#configuration)
  - [Source File Extensions](#source-file-extensions)
  - [Ignore Patterns](#ignore-patterns)
- [Tips for Using with LLMs](#tips-for-using-with-llms)
- [Troubleshooting](#troubleshooting)
- [Contributing](#contributing)
- [License](#license)
- [Author](#author)

---

## Features

- **Concatenation with Context:** Combines all source files (with supported extensions) into one file while preserving directory hierarchy.
- **Smart Filtering:** Uses built-in file extension whitelists and ignore patterns. Also honors your project’s `.gitignore` for extra filtering.
- **Encoding Handling:** Automatically handles file encoding issues (tries UTF-8 first, then falls back to Latin-1).
- **Debug Logging:** Option to enable debug logging so you can see which files are being included or skipped.
- **Easy Customization:** Adjust supported file extensions and ignore patterns via the `extensions.py` file.

---

## Installation

1. **Clone the Repository:**

   ```bash
   git clone https://github.com/yourusername/codesmelt.git
   cd codesmelt
   ```

2. **Install Dependencies:**

   CodeSmelt requires Python 3. Instead of installing dependencies individually, you can install all required packages using the `requirements.txt` file:

   ```bash
   pip install -r requirements.txt
   ```

   *(If you use a virtual environment, activate it before installing.)*

3. **Ensure File Structure:**

   Make sure the following files are in the same directory:
   
   - `codesmelt.py`
   - `extensions.py`
   - `README.md`
   - `requirements.txt`
   - `assets/CodeSmeltLogo.jpg` (logo image)

---

## Usage

### Basic Usage

Run CodeSmelt by providing the path to your Git project. For example:

```bash
python codesmelt.py /path/to/project
```

### Custom Output & Debug Mode

- **Specify a Custom Output File:**

  ```bash
  python codesmelt.py -o output.txt /path/to/project
  ```

- **Enable Debug Logging:**

  ```bash
  python codesmelt.py -d -o output.txt /path/to/project
  ```

#### Command-line Arguments

- `project_path` (required): Path to your Git project directory.
- `-o, --output`: Specify the output file path (default: `concatenated_source.txt`).
- `-d, --debug`: Enable debug logging to get detailed information about file selection.

---

## Configuration

CodeSmelt uses the `extensions.py` file to define:

### Source File Extensions

The tool automatically includes many common source code file extensions. Examples include:

- **Web:** `.js`, `.ts`, `.jsx`, `.tsx`, `.vue`, `.svelte`, `.html`, `.css`, etc.
- **Python:** `.py`, `.pyi`, `.pyx`
- **Java/Kotlin:** `.java`, `.kt`, `.groovy`
- **C-family:** `.c`, `.cpp`, `.h`, `.hpp`
- **Other Languages:** Ruby (`.rb`), PHP (`.php`), Go (`.go`), Rust (`.rs`), Swift (`.swift`), Shell (`.sh`), and more.

*To add or remove extensions, edit the `SOURCE_EXTENSIONS` set in `extensions.py`.*

### Ignore Patterns

Files and directories are automatically ignored based on three levels:

1. **Built-in Patterns:** Defined in the `IGNORE_PATTERNS` set in `extensions.py` (e.g., build outputs, dependency directories, IDE files, binary/media files).
2. **Project’s `.gitignore`:** If a `.gitignore` is present at the root of your project, CodeSmelt honors its rules.
3. **Directory-specific Rules:** Additional `.gitignore` files in subdirectories will also be considered.

*To customize, modify the `IGNORE_PATTERNS` in `extensions.py`.*

Example of adding Unity3D-specific ignores:

```python
IGNORE_PATTERNS = {
    # ... existing patterns ...
    'Assets/AssetStoreTools/*',
    'Library/*',
    'Temp/*',
    'Logs/*',
    '*.unity',  # Unity scene files
    '*.meta',   # Unity meta files
    '*.prefab', # Unity prefab files
    # ... other patterns ...
}
```

---

## Tips for Using with LLMs

1. **Token Management:**
   - For very large projects, consider concatenating only specific directories to avoid token limits.
   - Use debug mode (`-d`) to verify which files are included/excluded.

2. **Effective Prompting:**
   - Reference files using their relative paths as shown in the generated directory structure.
   - Ask questions about specific sections of the output using the file headers.

3. **Best Practices:**
   - Always review the concatenated output before sending it to an LLM.
   - For large projects, consider breaking down the analysis into smaller, manageable components.

---

## Troubleshooting

### Common Issues

1. **No Files Found:**
   - Double-check the project path.
   - Ensure your project contains files with supported extensions.
   - Run with `--debug` to see detailed file filtering information.

2. **Missing Dependencies:**
   - Make sure you have installed all required packages by running:
     
     ```bash
     pip install -r requirements.txt
     ```

3. **Permission Issues:**
   - Make sure you have read permissions for the project directory and write permissions for the output file.

---

## Contributing

Contributions are welcome! If you have ideas for improvements, bug fixes, or additional features, please fork the repository and submit a pull request. For major changes, please open an issue first to discuss what you would like to change.

---

## License

This project is licensed under the [MIT License](LICENSE).

---

## Author

**Shiraz Akmal**

Feel free to reach out if you have any questions or feedback!

---

Happy coding with CodeSmelt!

# File: codesmelt.py
================================================================================

#!/usr/bin/env python3
"""
CodeSmelt: Source Code Concatenator

This tool melts down source code files from a git project into a single file,
including directory structure information.
"""

import argparse
import sys
from pathlib import Path
import os
from typing import Set, List, Optional
import fnmatch
from datetime import datetime
import gitignore_parser
from extensions import SOURCE_EXTENSIONS, IGNORE_PATTERNS

class CodeSmelt:
    def __init__(self, project_path: str, output_file: str):
        self.project_path = Path(project_path).resolve()
        self.output_file = Path(output_file)
        self.gitignore_matcher = self._setup_gitignore()
        self.debug = False
        self.include_structure = True

    def _setup_gitignore(self) -> Optional[callable]:
        """Setup gitignore matcher if .gitignore exists"""
        gitignore_path = self.project_path / '.gitignore'
        if gitignore_path.exists():
            try:
                return gitignore_parser.parse_gitignore(gitignore_path)
            except Exception as e:
                print(f"Warning: Failed to parse .gitignore: {e}")
        return None

    def _should_include_file(self, file_path: Path) -> bool:
        """Check if file should be included based on extension and ignore rules"""
        # Skip common virtual environment and system directories
        excluded_dirs = {
            '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
            '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
            'dist', 'build', 'target'
        }

        try:
            # Convert to relative path for checking
            try:
                rel_path = file_path.relative_to(self.project_path)
            except ValueError:
                if self.debug:
                    print(f"Debug: Skipping file outside project path: {file_path}")
                return False

            # Check for excluded directories in the path
            if any(part in excluded_dirs for part in file_path.parts):
                if self.debug:
                    print(f"Debug: Skipping excluded directory: {file_path}")
                return False

            # Check if file extension is in whitelist
            if file_path.suffix.lower() not in SOURCE_EXTENSIONS:
                if self.debug:
                    print(f"Debug: Skipping non-source file: {file_path}")
                return False

            # Check custom ignore patterns
            for pattern in IGNORE_PATTERNS:
                if fnmatch.fnmatch(str(rel_path), pattern):
                    if self.debug:
                        print(f"Debug: Skipping ignored pattern {pattern}: {file_path}")
                    return False

            # Check .gitignore if available
            if self.gitignore_matcher:
                try:
                    should_include = not self.gitignore_matcher(str(file_path))
                    if self.debug and not should_include:
                        print(f"Debug: Skipping gitignored file: {file_path}")
                    return should_include
                except Exception as e:
                    print(f"Warning: gitignore matching failed for {file_path}: {e}")
                    return True

            if self.debug:
                print(f"Debug: Including file: {file_path}")
            return True

        except Exception as e:
            print(f"Warning: Error checking file {file_path}: {e}")
            return False

    def _get_file_content(self, file_path: Path) -> str:
        """Read file content with proper encoding handling"""
        try:
            # Try UTF-8 first
            with open(file_path, 'r', encoding='utf-8') as f:
                return f.read()
        except UnicodeDecodeError:
            try:
                # Fallback to latin-1
                with open(file_path, 'r', encoding='latin-1') as f:
                    return f.read()
            except Exception as e:
                print(f"Warning: Failed to read {file_path}: {e}")
                return f"ERROR: Could not read file {file_path}\n"

    def _generate_directory_structure(self) -> str:
        """Generate a tree-like directory structure"""
        structure = ["Directory Structure:", ""]

        def add_to_tree(path: Path, prefix: str = ""):
            # Skip excluded directories
            excluded_dirs = {
                '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
                '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
                'dist', 'build', 'target'
            }
            if path.name in excluded_dirs:
                return

            # Add files first
            files = sorted([p for p in path.iterdir() if p.is_file()])
            included_files = [f for f in files if self._should_include_file(f)]

            for idx, file in enumerate(included_files):
                is_last = idx == len(included_files) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {file.name}")

            # Then add directories
            dirs = sorted([p for p in path.iterdir() if p.is_dir()])
            included_dirs = [d for d in dirs if d.name not in excluded_dirs]

            for idx, dir in enumerate(included_dirs):
                is_last = idx == len(included_dirs) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {dir.name}/")
                add_to_tree(dir, prefix + ("    " if is_last else "│   "))

        add_to_tree(self.project_path)
        return "\n".join(structure)

    def concatenate(self, debug: bool = False):
        """Main method to concatenate all source files"""
        self.debug = debug
        if not self.project_path.exists():
            print(f"Error: Project path {self.project_path} does not exist")
            return False

        try:
            with open(self.output_file, 'w', encoding='utf-8') as out:
                # Write header
                header = f"""
# Project Source Code Concatenation
# Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
# Project path: {self.project_path}

"""
                out.write(header)

                # Write directory structure if enabled
                if self.include_structure:
                    out.write(self._generate_directory_structure())
                    out.write("\n\n" + "="*80 + "\n\n")

                # Process all files
                file_count = 0
                for file_path in self.project_path.rglob('*'):
                    if file_path.is_file() and self._should_include_file(file_path):
                        rel_path = file_path.relative_to(self.project_path)

                        # Write file header
                        out.write(f"\n\n# File: {rel_path}\n")
                        out.write("="*80 + "\n\n")

                        # Write file content
                        content = self._get_file_content(file_path)
                        out.write(content)
                        file_count += 1

                print(f"Successfully melted {file_count} files to {self.output_file}")
                return True

        except Exception as e:
            print(f"Error during melting: {e}")
            return False

def main():
    parser = argparse.ArgumentParser(
        description="CodeSmelt: Melt down your git project's source code into a single file",
        usage="%(prog)s project_path [output_file] [-o OUTPUT] [-d] [-n]"
    )

    # Add the project path as required positional argument
    parser.add_argument(
        "project_path",
        help="Path to the git project directory"
    )

    # Add optional positional argument for output file
    parser.add_argument(
        "output_file",
        nargs="?",  # Make it optional
        help="Output file path (alternative to -o)",
        default=None
    )

    # Keep the original -o option for backward compatibility
    parser.add_argument(
        "-o", "--output",
        help="Output file path (default: concatenated_source.txt)",
        default=None
    )

    parser.add_argument(
        "-d", "--debug",
        action="store_true",
        help="Enable debug logging"
    )

    parser.add_argument(
        "-n", "--no-structure",
        action="store_true",
        help="Omit directory structure from output"
    )

    args = parser.parse_args()

    # Determine the output file path, prioritizing command line arguments
    output_file = args.output or args.output_file or "concatenated_source.txt"

    concatenator = CodeSmelt(args.project_path, output_file)
    concatenator.include_structure = not args.no_structure
    success = concatenator.concatenate(debug=args.debug)
    sys.exit(0 if success else 1)

if __name__ == "__main__":
    main()

# File: test_with_structure.txt
================================================================================


# Project Source Code Concatenation
# Generated on: 2025-02-15 23:26:14
# Project path: /home/runner/workspace

Directory Structure:

├── README.md
├── codesmelt.py
├── extensions.py
├── pyproject.toml
├── requirements.txt
└── test_with_structure.txt
└── assets/

================================================================================



# File: extensions.py
================================================================================

"""
Source code file extension configurations
"""

# Common source code file extensions
SOURCE_EXTENSIONS = {
    # Web
    '.js', '.ts', '.jsx', '.tsx', '.vue', '.svelte',
    '.html', '.htm', '.css', '.scss', '.sass', '.less',
    
    # Python
    '.py', '.pyi', '.pyx',
    
    # Java/Kotlin
    '.java', '.kt', '.groovy',
    
    # C-family
    '.c', '.cpp', '.h', '.hpp', '.cc',
    
    # C#
    '.cs', '.cshtml', '.csx',
    
    # Ruby
    '.rb', '.erb',
    
    # PHP
    '.php', '.php5', '.phtml',
    
    # Go
    '.go',
    
    # Rust
    '.rs',
    
    # Swift
    '.swift',
    
    # Shell
    '.sh', '.bash', '.zsh',
    
    # Config/Data
    '.json', '.yaml', '.yml', '.toml', '.xml',
    '.conf', '.ini', '.env',
    
    # Documentation
    '.md', '.rst', '.txt'
}

# Files to always ignore
IGNORE_PATTERNS = {
    # Build outputs
    'build/*', 'dist/*', 'target/*', 'bin/*',
    '*.pyc', '__pycache__/*', '*.class',
    
    # Dependencies
    'node_modules/*', 'vendor/*', 'venv/*',
    
    # IDE files
    '.idea/*', '.vscode/*', '*.swp',
    
    # Package files
    'package-lock.json', 'yarn.lock',
    'Pipfile.lock', 'poetry.lock',
    
    # Large data files
    '*.csv', '*.json.gz', '*.sql',
    
    # Binary/Media files
    '*.pdf', '*.jpg', '*.png', '*.gif',
    '*.mp3', '*.mp4', '*.mov', '*.bin',
    '*.exe', '*.dll', '*.so', '*.dylib'
}


# File: pyproject.toml
================================================================================

[project]
name = "repl-nix-workspace"
version = "0.1.0"
description = "Add your description here"
requires-python = ">=3.11"
dependencies = [
    "gitignore-parser>=0.1.11",
]


# File: requirements.txt
================================================================================

gitignore_parser==0.1.11

# File: README.md
================================================================================

# CodeSmelt: Source Code Concatenator

![CodeSmelt Logo](assets/CodeSmeltLogo.jpg)

**CodeSmelt** is a command-line tool that “melts down” your Git project’s source code into a single, well-organized file. It not only concatenates source files but also embeds a tree-like directory structure to help you quickly understand your project’s layout. This is especially useful for code analysis, preparing inputs for language models, or sharing project snapshots.

---

## Table of Contents

- [Features](#features)
- [Installation](#installation)
- [Usage](#usage)
  - [Basic Usage](#basic-usage)
  - [Custom Output & Debug Mode](#custom-output--debug-mode)
- [Configuration](#configuration)
  - [Source File Extensions](#source-file-extensions)
  - [Ignore Patterns](#ignore-patterns)
- [Tips for Using with LLMs](#tips-for-using-with-llms)
- [Troubleshooting](#troubleshooting)
- [Contributing](#contributing)
- [License](#license)
- [Author](#author)

---

## Features

- **Concatenation with Context:** Combines all source files (with supported extensions) into one file while preserving directory hierarchy.
- **Smart Filtering:** Uses built-in file extension whitelists and ignore patterns. Also honors your project’s `.gitignore` for extra filtering.
- **Encoding Handling:** Automatically handles file encoding issues (tries UTF-8 first, then falls back to Latin-1).
- **Debug Logging:** Option to enable debug logging so you can see which files are being included or skipped.
- **Easy Customization:** Adjust supported file extensions and ignore patterns via the `extensions.py` file.

---

## Installation

1. **Clone the Repository:**

   ```bash
   git clone https://github.com/yourusername/codesmelt.git
   cd codesmelt
   ```

2. **Install Dependencies:**

   CodeSmelt requires Python 3. Instead of installing dependencies individually, you can install all required packages using the `requirements.txt` file:

   ```bash
   pip install -r requirements.txt
   ```

   *(If you use a virtual environment, activate it before installing.)*

3. **Ensure File Structure:**

   Make sure the following files are in the same directory:
   
   - `codesmelt.py`
   - `extensions.py`
   - `README.md`
   - `requirements.txt`
   - `assets/CodeSmeltLogo.jpg` (logo image)

---

## Usage

### Basic Usage

Run CodeSmelt by providing the path to your Git project. For example:

```bash
python codesmelt.py /path/to/project
```

### Custom Output & Debug Mode

- **Specify a Custom Output File:**

  ```bash
  python codesmelt.py -o output.txt /path/to/project
  ```

- **Enable Debug Logging:**

  ```bash
  python codesmelt.py -d -o output.txt /path/to/project
  ```

#### Command-line Arguments

- `project_path` (required): Path to your Git project directory.
- `-o, --output`: Specify the output file path (default: `concatenated_source.txt`).
- `-d, --debug`: Enable debug logging to get detailed information about file selection.

---

## Configuration

CodeSmelt uses the `extensions.py` file to define:

### Source File Extensions

The tool automatically includes many common source code file extensions. Examples include:

- **Web:** `.js`, `.ts`, `.jsx`, `.tsx`, `.vue`, `.svelte`, `.html`, `.css`, etc.
- **Python:** `.py`, `.pyi`, `.pyx`
- **Java/Kotlin:** `.java`, `.kt`, `.groovy`
- **C-family:** `.c`, `.cpp`, `.h`, `.hpp`
- **Other Languages:** Ruby (`.rb`), PHP (`.php`), Go (`.go`), Rust (`.rs`), Swift (`.swift`), Shell (`.sh`), and more.

*To add or remove extensions, edit the `SOURCE_EXTENSIONS` set in `extensions.py`.*

### Ignore Patterns

Files and directories are automatically ignored based on three levels:

1. **Built-in Patterns:** Defined in the `IGNORE_PATTERNS` set in `extensions.py` (e.g., build outputs, dependency directories, IDE files, binary/media files).
2. **Project’s `.gitignore`:** If a `.gitignore` is present at the root of your project, CodeSmelt honors its rules.
3. **Directory-specific Rules:** Additional `.gitignore` files in subdirectories will also be considered.

*To customize, modify the `IGNORE_PATTERNS` in `extensions.py`.*

Example of adding Unity3D-specific ignores:

```python
IGNORE_PATTERNS = {
    # ... existing patterns ...
    'Assets/AssetStoreTools/*',
    'Library/*',
    'Temp/*',
    'Logs/*',
    '*.unity',  # Unity scene files
    '*.meta',   # Unity meta files
    '*.prefab', # Unity prefab files
    # ... other patterns ...
}
```

---

## Tips for Using with LLMs

1. **Token Management:**
   - For very large projects, consider concatenating only specific directories to avoid token limits.
   - Use debug mode (`-d`) to verify which files are included/excluded.

2. **Effective Prompting:**
   - Reference files using their relative paths as shown in the generated directory structure.
   - Ask questions about specific sections of the output using the file headers.

3. **Best Practices:**
   - Always review the concatenated output before sending it to an LLM.
   - For large projects, consider breaking down the analysis into smaller, manageable components.

---

## Troubleshooting

### Common Issues

1. **No Files Found:**
   - Double-check the project path.
   - Ensure your project contains files with supported extensions.
   - Run with `--debug` to see detailed file filtering information.

2. **Missing Dependencies:**
   - Make sure you have installed all required packages by running:
     
     ```bash
     pip install -r requirements.txt
     ```

3. **Permission Issues:**
   - Make sure you have read permissions for the project directory and write permissions for the output file.

---

## Contributing

Contributions are welcome! If you have ideas for improvements, bug fixes, or additional features, please fork the repository and submit a pull request. For major changes, please open an issue first to discuss what you would like to change.

---

## License

This project is licensed under the [MIT License](LICENSE).

---

## Author

**Shiraz Akmal**

Feel free to reach out if you have any questions or feedback!

---

Happy coding with CodeSmelt!

# File: codesmelt.py
================================================================================

#!/usr/bin/env python3
"""
CodeSmelt: Source Code Concatenator

This tool melts down source code files from a git project into a single file,
including directory structure information.
"""

import argparse
import sys
from pathlib import Path
import os
from typing import Set, List, Optional
import fnmatch
from datetime import datetime
import gitignore_parser
from extensions import SOURCE_EXTENSIONS, IGNORE_PATTERNS

class CodeSmelt:
    def __init__(self, project_path: str, output_file: str):
        self.project_path = Path(project_path).resolve()
        self.output_file = Path(output_file)
        self.gitignore_matcher = self._setup_gitignore()
        self.debug = False
        self.include_structure = True

    def _setup_gitignore(self) -> Optional[callable]:
        """Setup gitignore matcher if .gitignore exists"""
        gitignore_path = self.project_path / '.gitignore'
        if gitignore_path.exists():
            try:
                return gitignore_parser.parse_gitignore(gitignore_path)
            except Exception as e:
                print(f"Warning: Failed to parse .gitignore: {e}")
        return None

    def _should_include_file(self, file_path: Path) -> bool:
        """Check if file should be included based on extension and ignore rules"""
        # Skip common virtual environment and system directories
        excluded_dirs = {
            '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
            '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
            'dist', 'build', 'target'
        }

        try:
            # Convert to relative path for checking
            try:
                rel_path = file_path.relative_to(self.project_path)
            except ValueError:
                if self.debug:
                    print(f"Debug: Skipping file outside project path: {file_path}")
                return False

            # Check for excluded directories in the path
            if any(part in excluded_dirs for part in file_path.parts):
                if self.debug:
                    print(f"Debug: Skipping excluded directory: {file_path}")
                return False

            # Check if file extension is in whitelist
            if file_path.suffix.lower() not in SOURCE_EXTENSIONS:
                if self.debug:
                    print(f"Debug: Skipping non-source file: {file_path}")
                return False

            # Check custom ignore patterns
            for pattern in IGNORE_PATTERNS:
                if fnmatch.fnmatch(str(rel_path), pattern):
                    if self.debug:
                        print(f"Debug: Skipping ignored pattern {pattern}: {file_path}")
                    return False

            # Check .gitignore if available
            if self.gitignore_matcher:
                try:
                    should_include = not self.gitignore_matcher(str(file_path))
                    if self.debug and not should_include:
                        print(f"Debug: Skipping gitignored file: {file_path}")
                    return should_include
                except Exception as e:
                    print(f"Warning: gitignore matching failed for {file_path}: {e}")
                    return True

            if self.debug:
                print(f"Debug: Including file: {file_path}")
            return True

        except Exception as e:
            print(f"Warning: Error checking file {file_path}: {e}")
            return False

    def _get_file_content(self, file_path: Path) -> str:
        """Read file content with proper encoding handling"""
        try:
            # Try UTF-8 first
            with open(file_path, 'r', encoding='utf-8') as f:
                return f.read()
        except UnicodeDecodeError:
            try:
                # Fallback to latin-1
                with open(file_path, 'r', encoding='latin-1') as f:
                    return f.read()
            except Exception as e:
                print(f"Warning: Failed to read {file_path}: {e}")
                return f"ERROR: Could not read file {file_path}\n"

    def _generate_directory_structure(self) -> str:
        """Generate a tree-like directory structure"""
        structure = ["Directory Structure:", ""]

        def add_to_tree(path: Path, prefix: str = ""):
            # Skip excluded directories
            excluded_dirs = {
                '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
                '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
                'dist', 'build', 'target'
            }
            if path.name in excluded_dirs:
                return

            # Add files first
            files = sorted([p for p in path.iterdir() if p.is_file()])
            included_files = [f for f in files if self._should_include_file(f)]

            for idx, file in enumerate(included_files):
                is_last = idx == len(included_files) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {file.name}")

            # Then add directories
            dirs = sorted([p for p in path.iterdir() if p.is_dir()])
            included_dirs = [d for d in dirs if d.name not in excluded_dirs]

            for idx, dir in enumerate(included_dirs):
                is_last = idx == len(included_dirs) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {dir.name}/")
                add_to_tree(dir, prefix + ("    " if is_last else "│   "))

        add_to_tree(self.project_path)
        return "\n".join(structure)

    def concatenate(self, debug: bool = False):
        """Main method to concatenate all source files"""
        self.debug = debug
        if not self.project_path.exists():
            print(f"Error: Project path {self.project_path} does not exist")
            return False

        try:
            with open(self.output_file, 'w', encoding='utf-8') as out:
                # Write header
                header = f"""
# Project Source Code Concatenation
# Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
# Project path: {self.project_path}

"""
                out.write(header)

                # Write directory structure if enabled
                if self.include_structure:
                    out.write(self._generate_directory_structure())
                    out.write("\n\n" + "="*80 + "\n\n")

                # Process all files
                file_count = 0
                for file_path in self.project_path.rglob('*'):
                    if file_path.is_file() and self._should_include_file(file_path):
                        rel_path = file_path.relative_to(self.project_path)

                        # Write file header
                        out.write(f"\n\n# File: {rel_path}\n")
                        out.write("="*80 + "\n\n")

                        # Write file content
                        content = self._get_file_content(file_path)
                        out.write(content)
                        file_count += 1

                print(f"Successfully melted {file_count} files to {self.output_file}")
                return True

        except Exception as e:
            print(f"Error during melting: {e}")
            return False

def main():
    parser = argparse.ArgumentParser(
        description="CodeSmelt: Melt down your git project's source code into a single file",
        usage="%(prog)s project_path [output_file] [-o OUTPUT] [-d] [-n]"
    )

    # Add the project path as required positional argument
    parser.add_argument(
        "project_path",
        help="Path to the git project directory"
    )

    # Add optional positional argument for output file
    parser.add_argument(
        "output_file",
        nargs="?",  # Make it optional
        help="Output file path (alternative to -o)",
        default=None
    )

    # Keep the original -o option for backward compatibility
    parser.add_argument(
        "-o", "--output",
        help="Output file path (default: concatenated_source.txt)",
        default=None
    )

    parser.add_argument(
        "-d", "--debug",
        action="store_true",
        help="Enable debug logging"
    )

    parser.add_argument(
        "-n", "--no-structure",
        action="store_true",
        help="Omit directory structure from output"
    )

    args = parser.parse_args()

    # Determine the output file path, prioritizing command line arguments
    output_file = args.output or args.output_file or "concatenated_source.txt"

    concatenator = CodeSmelt(args.project_path, output_file)
    concatenator.include_structure = not args.no_structure
    success = concatenator.concatenate(debug=args.debug)
    sys.exit(0 if success else 1)

if __name__ == "__main__":
    main()

# File: test_without_structure.txt
================================================================================


# Project Source Code Concatenation
# Generated on: 2025-02-15 23:26:14
# Project path: /home/runner/workspace



# File: extensions.py
================================================================================

"""
Source code file extension configurations
"""

# Common source code file extensions
SOURCE_EXTENSIONS = {
    # Web
    '.js', '.ts', '.jsx', '.tsx', '.vue', '.svelte',
    '.html', '.htm', '.css', '.scss', '.sass', '.less',
    
    # Python
    '.py', '.pyi', '.pyx',
    
    # Java/Kotlin
    '.java', '.kt', '.groovy',
    
    # C-family
    '.c', '.cpp', '.h', '.hpp', '.cc',
    
    # C#
    '.cs', '.cshtml', '.csx',
    
    # Ruby
    '.rb', '.erb',
    
    # PHP
    '.php', '.php5', '.phtml',
    
    # Go
    '.go',
    
    # Rust
    '.rs',
    
    # Swift
    '.swift',
    
    # Shell
    '.sh', '.bash', '.zsh',
    
    # Config/Data
    '.json', '.yaml', '.yml', '.toml', '.xml',
    '.conf', '.ini', '.env',
    
    # Documentation
    '.md', '.rst', '.txt'
}

# Files to always ignore
IGNORE_PATTERNS = {
    # Build outputs
    'build/*', 'dist/*', 'target/*', 'bin/*',
    '*.pyc', '__pycache__/*', '*.class',
    
    # Dependencies
    'node_modules/*', 'vendor/*', 'venv/*',
    
    # IDE files
    '.idea/*', '.vscode/*', '*.swp',
    
    # Package files
    'package-lock.json', 'yarn.lock',
    'Pipfile.lock', 'poetry.lock',
    
    # Large data files
    '*.csv', '*.json.gz', '*.sql',
    
    # Binary/Media files
    '*.pdf', '*.jpg', '*.png', '*.gif',
    '*.mp3', '*.mp4', '*.mov', '*.bin',
    '*.exe', '*.dll', '*.so', '*.dylib'
}


# File: pyproject.toml
================================================================================

[project]
name = "repl-nix-workspace"
version = "0.1.0"
description = "Add your description here"
requires-python = ">=3.11"
dependencies = [
    "gitignore-parser>=0.1.11",
]


# File: requirements.txt
================================================================================

gitignore_parser==0.1.11

# File: README.md
================================================================================

# CodeSmelt: Source Code Concatenator

![CodeSmelt Logo](assets/CodeSmeltLogo.jpg)

**CodeSmelt** is a command-line tool that “melts down” your Git project’s source code into a single, well-organized file. It not only concatenates source files but also embeds a tree-like directory structure to help you quickly understand your project’s layout. This is especially useful for code analysis, preparing inputs for language models, or sharing project snapshots.

---

## Table of Contents

- [Features](#features)
- [Installation](#installation)
- [Usage](#usage)
  - [Basic Usage](#basic-usage)
  - [Custom Output & Debug Mode](#custom-output--debug-mode)
- [Configuration](#configuration)
  - [Source File Extensions](#source-file-extensions)
  - [Ignore Patterns](#ignore-patterns)
- [Tips for Using with LLMs](#tips-for-using-with-llms)
- [Troubleshooting](#troubleshooting)
- [Contributing](#contributing)
- [License](#license)
- [Author](#author)

---

## Features

- **Concatenation with Context:** Combines all source files (with supported extensions) into one file while preserving directory hierarchy.
- **Smart Filtering:** Uses built-in file extension whitelists and ignore patterns. Also honors your project’s `.gitignore` for extra filtering.
- **Encoding Handling:** Automatically handles file encoding issues (tries UTF-8 first, then falls back to Latin-1).
- **Debug Logging:** Option to enable debug logging so you can see which files are being included or skipped.
- **Easy Customization:** Adjust supported file extensions and ignore patterns via the `extensions.py` file.

---

## Installation

1. **Clone the Repository:**

   ```bash
   git clone https://github.com/yourusername/codesmelt.git
   cd codesmelt
   ```

2. **Install Dependencies:**

   CodeSmelt requires Python 3. Instead of installing dependencies individually, you can install all required packages using the `requirements.txt` file:

   ```bash
   pip install -r requirements.txt
   ```

   *(If you use a virtual environment, activate it before installing.)*

3. **Ensure File Structure:**

   Make sure the following files are in the same directory:
   
   - `codesmelt.py`
   - `extensions.py`
   - `README.md`
   - `requirements.txt`
   - `assets/CodeSmeltLogo.jpg` (logo image)

---

## Usage

### Basic Usage

Run CodeSmelt by providing the path to your Git project. For example:

```bash
python codesmelt.py /path/to/project
```

### Custom Output & Debug Mode

- **Specify a Custom Output File:**

  ```bash
  python codesmelt.py -o output.txt /path/to/project
  ```

- **Enable Debug Logging:**

  ```bash
  python codesmelt.py -d -o output.txt /path/to/project
  ```

#### Command-line Arguments

- `project_path` (required): Path to your Git project directory.
- `-o, --output`: Specify the output file path (default: `concatenated_source.txt`).
- `-d, --debug`: Enable debug logging to get detailed information about file selection.

---

## Configuration

CodeSmelt uses the `extensions.py` file to define:

### Source File Extensions

The tool automatically includes many common source code file extensions. Examples include:

- **Web:** `.js`, `.ts`, `.jsx`, `.tsx`, `.vue`, `.svelte`, `.html`, `.css`, etc.
- **Python:** `.py`, `.pyi`, `.pyx`
- **Java/Kotlin:** `.java`, `.kt`, `.groovy`
- **C-family:** `.c`, `.cpp`, `.h`, `.hpp`
- **Other Languages:** Ruby (`.rb`), PHP (`.php`), Go (`.go`), Rust (`.rs`), Swift (`.swift`), Shell (`.sh`), and more.

*To add or remove extensions, edit the `SOURCE_EXTENSIONS` set in `extensions.py`.*

### Ignore Patterns

Files and directories are automatically ignored based on three levels:

1. **Built-in Patterns:** Defined in the `IGNORE_PATTERNS` set in `extensions.py` (e.g., build outputs, dependency directories, IDE files, binary/media files).
2. **Project’s `.gitignore`:** If a `.gitignore` is present at the root of your project, CodeSmelt honors its rules.
3. **Directory-specific Rules:** Additional `.gitignore` files in subdirectories will also be considered.

*To customize, modify the `IGNORE_PATTERNS` in `extensions.py`.*

Example of adding Unity3D-specific ignores:

```python
IGNORE_PATTERNS = {
    # ... existing patterns ...
    'Assets/AssetStoreTools/*',
    'Library/*',
    'Temp/*',
    'Logs/*',
    '*.unity',  # Unity scene files
    '*.meta',   # Unity meta files
    '*.prefab', # Unity prefab files
    # ... other patterns ...
}
```

---

## Tips for Using with LLMs

1. **Token Management:**
   - For very large projects, consider concatenating only specific directories to avoid token limits.
   - Use debug mode (`-d`) to verify which files are included/excluded.

2. **Effective Prompting:**
   - Reference files using their relative paths as shown in the generated directory structure.
   - Ask questions about specific sections of the output using the file headers.

3. **Best Practices:**
   - Always review the concatenated output before sending it to an LLM.
   - For large projects, consider breaking down the analysis into smaller, manageable components.

---

## Troubleshooting

### Common Issues

1. **No Files Found:**
   - Double-check the project path.
   - Ensure your project contains files with supported extensions.
   - Run with `--debug` to see detailed file filtering information.

2. **Missing Dependencies:**
   - Make sure you have installed all required packages by running:
     
     ```bash
     pip install -r requirements.txt
     ```

3. **Permission Issues:**
   - Make sure you have read permissions for the project directory and write permissions for the output file.

---

## Contributing

Contributions are welcome! If you have ideas for improvements, bug fixes, or additional features, please fork the repository and submit a pull request. For major changes, please open an issue first to discuss what you would like to change.

---

## License

This project is licensed under the [MIT License](LICENSE).

---

## Author

**Shiraz Akmal**

Feel free to reach out if you have any questions or feedback!

---

Happy coding with CodeSmelt!

# File: codesmelt.py
================================================================================

#!/usr/bin/env python3
"""
CodeSmelt: Source Code Concatenator

This tool melts down source code files from a git project into a single file,
including directory structure information.
"""

import argparse
import sys
from pathlib import Path
import os
from typing import Set, List, Optional
import fnmatch
from datetime import datetime
import gitignore_parser
from extensions import SOURCE_EXTENSIONS, IGNORE_PATTERNS

class CodeSmelt:
    def __init__(self, project_path: str, output_file: str):
        self.project_path = Path(project_path).resolve()
        self.output_file = Path(output_file)
        self.gitignore_matcher = self._setup_gitignore()
        self.debug = False
        self.include_structure = True

    def _setup_gitignore(self) -> Optional[callable]:
        """Setup gitignore matcher if .gitignore exists"""
        gitignore_path = self.project_path / '.gitignore'
        if gitignore_path.exists():
            try:
                return gitignore_parser.parse_gitignore(gitignore_path)
            except Exception as e:
                print(f"Warning: Failed to parse .gitignore: {e}")
        return None

    def _should_include_file(self, file_path: Path) -> bool:
        """Check if file should be included based on extension and ignore rules"""
        # Skip common virtual environment and system directories
        excluded_dirs = {
            '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
            '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
            'dist', 'build', 'target'
        }

        try:
            # Convert to relative path for checking
            try:
                rel_path = file_path.relative_to(self.project_path)
            except ValueError:
                if self.debug:
                    print(f"Debug: Skipping file outside project path: {file_path}")
                return False

            # Check for excluded directories in the path
            if any(part in excluded_dirs for part in file_path.parts):
                if self.debug:
                    print(f"Debug: Skipping excluded directory: {file_path}")
                return False

            # Check if file extension is in whitelist
            if file_path.suffix.lower() not in SOURCE_EXTENSIONS:
                if self.debug:
                    print(f"Debug: Skipping non-source file: {file_path}")
                return False

            # Check custom ignore patterns
            for pattern in IGNORE_PATTERNS:
                if fnmatch.fnmatch(str(rel_path), pattern):
                    if self.debug:
                        print(f"Debug: Skipping ignored pattern {pattern}: {file_path}")
                    return False

            # Check .gitignore if available
            if self.gitignore_matcher:
                try:
                    should_include = not self.gitignore_matcher(str(file_path))
                    if self.debug and not should_include:
                        print(f"Debug: Skipping gitignored file: {file_path}")
                    return should_include
                except Exception as e:
                    print(f"Warning: gitignore matching failed for {file_path}: {e}")
                    return True

            if self.debug:
                print(f"Debug: Including file: {file_path}")
            return True

        except Exception as e:
            print(f"Warning: Error checking file {file_path}: {e}")
            return False

    def _get_file_content(self, file_path: Path) -> str:
        """Read file content with proper encoding handling"""
        try:
            # Try UTF-8 first
            with open(file_path, 'r', encoding='utf-8') as f:
                return f.read()
        except UnicodeDecodeError:
            try:
                # Fallback to latin-1
                with open(file_path, 'r', encoding='latin-1') as f:
                    return f.read()
            except Exception as e:
                print(f"Warning: Failed to read {file_path}: {e}")
                return f"ERROR: Could not read file {file_path}\n"

    def _generate_directory_structure(self) -> str:
        """Generate a tree-like directory structure"""
        structure = ["Directory Structure:", ""]

        def add_to_tree(path: Path, prefix: str = ""):
            # Skip excluded directories
            excluded_dirs = {
                '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
                '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
                'dist', 'build', 'target'
            }
            if path.name in excluded_dirs:
                return

            # Add files first
            files = sorted([p for p in path.iterdir() if p.is_file()])
            included_files = [f for f in files if self._should_include_file(f)]

            for idx, file in enumerate(included_files):
                is_last = idx == len(included_files) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {file.name}")

            # Then add directories
            dirs = sorted([p for p in path.iterdir() if p.is_dir()])
            included_dirs = [d for d in dirs if d.name not in excluded_dirs]

            for idx, dir in enumerate(included_dirs):
                is_last = idx == len(included_dirs) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {dir.name}/")
                add_to_tree(dir, prefix + ("    " if is_last else "│   "))

        add_to_tree(self.project_path)
        return "\n".join(structure)

    def concatenate(self, debug: bool = False):
        """Main method to concatenate all source files"""
        self.debug = debug
        if not self.project_path.exists():
            print(f"Error: Project path {self.project_path} does not exist")
            return False

        try:
            with open(self.output_file, 'w', encoding='utf-8') as out:
                # Write header
                header = f"""
# Project Source Code Concatenation
# Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
# Project path: {self.project_path}

"""
                out.write(header)

                # Write directory structure if enabled
                if self.include_structure:
                    out.write(self._generate_directory_structure())
                    out.write("\n\n" + "="*80 + "\n\n")

                # Process all files
                file_count = 0
                for file_path in self.project_path.rglob('*'):
                    if file_path.is_file() and self._should_include_file(file_path):
                        rel_path = file_path.relative_to(self.project_path)

                        # Write file header
                        out.write(f"\n\n# File: {rel_path}\n")
                        out.write("="*80 + "\n\n")

                        # Write file content
                        content = self._get_file_content(file_path)
                        out.write(content)
                        file_count += 1

                print(f"Successfully melted {file_count} files to {self.output_file}")
                return True

        except Exception as e:
            print(f"Error during melting: {e}")
            return False

def main():
    parser = argparse.ArgumentParser(
        description="CodeSmelt: Melt down your git project's source code into a single file",
        usage="%(prog)s project_path [output_file] [-o OUTPUT] [-d] [-n]"
    )

    # Add the project path as required positional argument
    parser.add_argument(
        "project_path",
        help="Path to the git project directory"
    )

    # Add optional positional argument for output file
    parser.add_argument(
        "output_file",
        nargs="?",  # Make it optional
        help="Output file path (alternative to -o)",
        default=None
    )

    # Keep the original -o option for backward compatibility
    parser.add_argument(
        "-o", "--output",
        help="Output file path (default: concatenated_source.txt)",
        default=None
    )

    parser.add_argument(
        "-d", "--debug",
        action="store_true",
        help="Enable debug logging"
    )

    parser.add_argument(
        "-n", "--no-structure",
        action="store_true",
        help="Omit directory structure from output"
    )

    args = parser.parse_args()

    # Determine the output file path, prioritizing command line arguments
    output_file = args.output or args.output_file or "concatenated_source.txt"

    concatenator = CodeSmelt(args.project_path, output_file)
    concatenator.include_structure = not args.no_structure
    success = concatenator.concatenate(debug=args.debug)
    sys.exit(0 if success else 1)

if __name__ == "__main__":
    main()

# File: test_with_structure.txt
================================================================================


# Project Source Code Concatenation
# Generated on: 2025-02-15 23:26:14
# Project path: /home/runner/workspace

Directory Structure:

├── README.md
├── codesmelt.py
├── extensions.py
├── pyproject.toml
├── requirements.txt
└── test_with_structure.txt
└── assets/

================================================================================



# File: extensions.py
================================================================================

"""
Source code file extension configurations
"""

# Common source code file extensions
SOURCE_EXTENSIONS = {
    # Web
    '.js', '.ts', '.jsx', '.tsx', '.vue', '.svelte',
    '.html', '.htm', '.css', '.scss', '.sass', '.less',
    
    # Python
    '.py', '.pyi', '.pyx',
    
    # Java/Kotlin
    '.java', '.kt', '.groovy',
    
    # C-family
    '.c', '.cpp', '.h', '.hpp', '.cc',
    
    # C#
    '.cs', '.cshtml', '.csx',
    
    # Ruby
    '.rb', '.erb',
    
    # PHP
    '.php', '.php5', '.phtml',
    
    # Go
    '.go',
    
    # Rust
    '.rs',
    
    # Swift
    '.swift',
    
    # Shell
    '.sh', '.bash', '.zsh',
    
    # Config/Data
    '.json', '.yaml', '.yml', '.toml', '.xml',
    '.conf', '.ini', '.env',
    
    # Documentation
    '.md', '.rst', '.txt'
}

# Files to always ignore
IGNORE_PATTERNS = {
    # Build outputs
    'build/*', 'dist/*', 'target/*', 'bin/*',
    '*.pyc', '__pycache__/*', '*.class',
    
    # Dependencies
    'node_modules/*', 'vendor/*', 'venv/*',
    
    # IDE files
    '.idea/*', '.vscode/*', '*.swp',
    
    # Package files
    'package-lock.json', 'yarn.lock',
    'Pipfile.lock', 'poetry.lock',
    
    # Large data files
    '*.csv', '*.json.gz', '*.sql',
    
    # Binary/Media files
    '*.pdf', '*.jpg', '*.png', '*.gif',
    '*.mp3', '*.mp4', '*.mov', '*.bin',
    '*.exe', '*.dll', '*.so', '*.dylib'
}


# File: pyproject.toml
================================================================================

[project]
name = "repl-nix-workspace"
version = "0.1.0"
description = "Add your description here"
requires-python = ">=3.11"
dependencies = [
    "gitignore-parser>=0.1.11",
]


# File: requirements.txt
================================================================================

gitignore_parser==0.1.11

# File: README.md
================================================================================

# CodeSmelt: Source Code Concatenator

![CodeSmelt Logo](assets/CodeSmeltLogo.jpg)

**CodeSmelt** is a command-line tool that “melts down” your Git project’s source code into a single, well-organized file. It not only concatenates source files but also embeds a tree-like directory structure to help you quickly understand your project’s layout. This is especially useful for code analysis, preparing inputs for language models, or sharing project snapshots.

---

## Table of Contents

- [Features](#features)
- [Installation](#installation)
- [Usage](#usage)
  - [Basic Usage](#basic-usage)
  - [Custom Output & Debug Mode](#custom-output--debug-mode)
- [Configuration](#configuration)
  - [Source File Extensions](#source-file-extensions)
  - [Ignore Patterns](#ignore-patterns)
- [Tips for Using with LLMs](#tips-for-using-with-llms)
- [Troubleshooting](#troubleshooting)
- [Contributing](#contributing)
- [License](#license)
- [Author](#author)

---

## Features

- **Concatenation with Context:** Combines all source files (with supported extensions) into one file while preserving directory hierarchy.
- **Smart Filtering:** Uses built-in file extension whitelists and ignore patterns. Also honors your project’s `.gitignore` for extra filtering.
- **Encoding Handling:** Automatically handles file encoding issues (tries UTF-8 first, then falls back to Latin-1).
- **Debug Logging:** Option to enable debug logging so you can see which files are being included or skipped.
- **Easy Customization:** Adjust supported file extensions and ignore patterns via the `extensions.py` file.

---

## Installation

1. **Clone the Repository:**

   ```bash
   git clone https://github.com/yourusername/codesmelt.git
   cd codesmelt
   ```

2. **Install Dependencies:**

   CodeSmelt requires Python 3. Instead of installing dependencies individually, you can install all required packages using the `requirements.txt` file:

   ```bash
   pip install -r requirements.txt
   ```

   *(If you use a virtual environment, activate it before installing.)*

3. **Ensure File Structure:**

   Make sure the following files are in the same directory:
   
   - `codesmelt.py`
   - `extensions.py`
   - `README.md`
   - `requirements.txt`
   - `assets/CodeSmeltLogo.jpg` (logo image)

---

## Usage

### Basic Usage

Run CodeSmelt by providing the path to your Git project. For example:

```bash
python codesmelt.py /path/to/project
```

### Custom Output & Debug Mode

- **Specify a Custom Output File:**

  ```bash
  python codesmelt.py -o output.txt /path/to/project
  ```

- **Enable Debug Logging:**

  ```bash
  python codesmelt.py -d -o output.txt /path/to/project
  ```

#### Command-line Arguments

- `project_path` (required): Path to your Git project directory.
- `-o, --output`: Specify the output file path (default: `concatenated_source.txt`).
- `-d, --debug`: Enable debug logging to get detailed information about file selection.

---

## Configuration

CodeSmelt uses the `extensions.py` file to define:

### Source File Extensions

The tool automatically includes many common source code file extensions. Examples include:

- **Web:** `.js`, `.ts`, `.jsx`, `.tsx`, `.vue`, `.svelte`, `.html`, `.css`, etc.
- **Python:** `.py`, `.pyi`, `.pyx`
- **Java/Kotlin:** `.java`, `.kt`, `.groovy`
- **C-family:** `.c`, `.cpp`, `.h`, `.hpp`
- **Other Languages:** Ruby (`.rb`), PHP (`.php`), Go (`.go`), Rust (`.rs`), Swift (`.swift`), Shell (`.sh`), and more.

*To add or remove extensions, edit the `SOURCE_EXTENSIONS` set in `extensions.py`.*

### Ignore Patterns

Files and directories are automatically ignored based on three levels:

1. **Built-in Patterns:** Defined in the `IGNORE_PATTERNS` set in `extensions.py` (e.g., build outputs, dependency directories, IDE files, binary/media files).
2. **Project’s `.gitignore`:** If a `.gitignore` is present at the root of your project, CodeSmelt honors its rules.
3. **Directory-specific Rules:** Additional `.gitignore` files in subdirectories will also be considered.

*To customize, modify the `IGNORE_PATTERNS` in `extensions.py`.*

Example of adding Unity3D-specific ignores:

```python
IGNORE_PATTERNS = {
    # ... existing patterns ...
    'Assets/AssetStoreTools/*',
    'Library/*',
    'Temp/*',
    'Logs/*',
    '*.unity',  # Unity scene files
    '*.meta',   # Unity meta files
    '*.prefab', # Unity prefab files
    # ... other patterns ...
}
```

---

## Tips for Using with LLMs

1. **Token Management:**
   - For very large projects, consider concatenating only specific directories to avoid token limits.
   - Use debug mode (`-d`) to verify which files are included/excluded.

2. **Effective Prompting:**
   - Reference files using their relative paths as shown in the generated directory structure.
   - Ask questions about specific sections of the output using the file headers.

3. **Best Practices:**
   - Always review the concatenated output before sending it to an LLM.
   - For large projects, consider breaking down the analysis into smaller, manageable components.

---

## Troubleshooting

### Common Issues

1. **No Files Found:**
   - Double-check the project path.
   - Ensure your project contains files with supported extensions.
   - Run with `--debug` to see detailed file filtering information.

2. **Missing Dependencies:**
   - Make sure you have installed all required packages by running:
     
     ```bash
     pip install -r requirements.txt
     ```

3. **Permission Issues:**
   - Make sure you have read permissions for the project directory and write permissions for the output file.

---

## Contributing

Contributions are welcome! If you have ideas for improvements, bug fixes, or additional features, please fork the repository and submit a pull request. For major changes, please open an issue first to discuss what you would like to change.

---

## License

This project is licensed under the [MIT License](LICENSE).

---

## Author

**Shiraz Akmal**

Feel free to reach out if you have any questions or feedback!

---

Happy coding with CodeSmelt!

# File: codesmelt.py
================================================================================

#!/usr/bin/env python3
"""
CodeSmelt: Source Code Concatenator

This tool melts down source code files from a git project into a single file,
including directory structure information.
"""

import argparse
import sys
from pathlib import Path
import os
from typing import Set, List, Optional
import fnmatch
from datetime import datetime
import gitignore_parser
from extensions import SOURCE_EXTENSIONS, IGNORE_PATTERNS

class CodeSmelt:
    def __init__(self, project_path: str, output_file: str):
        self.project_path = Path(project_path).resolve()
        self.output_file = Path(output_file)
        self.gitignore_matcher = self._setup_gitignore()
        self.debug = False
        self.include_structure = True

    def _setup_gitignore(self) -> Optional[callable]:
        """Setup gitignore matcher if .gitignore exists"""
        gitignore_path = self.project_path / '.gitignore'
        if gitignore_path.exists():
            try:
                return gitignore_parser.parse_gitignore(gitignore_path)
            except Exception as e:
                print(f"Warning: Failed to parse .gitignore: {e}")
        return None

    def _should_include_file(self, file_path: Path) -> bool:
        """Check if file should be included based on extension and ignore rules"""
        # Skip common virtual environment and system directories
        excluded_dirs = {
            '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
            '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
            'dist', 'build', 'target'
        }

        try:
            # Convert to relative path for checking
            try:
                rel_path = file_path.relative_to(self.project_path)
            except ValueError:
                if self.debug:
                    print(f"Debug: Skipping file outside project path: {file_path}")
                return False

            # Check for excluded directories in the path
            if any(part in excluded_dirs for part in file_path.parts):
                if self.debug:
                    print(f"Debug: Skipping excluded directory: {file_path}")
                return False

            # Check if file extension is in whitelist
            if file_path.suffix.lower() not in SOURCE_EXTENSIONS:
                if self.debug:
                    print(f"Debug: Skipping non-source file: {file_path}")
                return False

            # Check custom ignore patterns
            for pattern in IGNORE_PATTERNS:
                if fnmatch.fnmatch(str(rel_path), pattern):
                    if self.debug:
                        print(f"Debug: Skipping ignored pattern {pattern}: {file_path}")
                    return False

            # Check .gitignore if available
            if self.gitignore_matcher:
                try:
                    should_include = not self.gitignore_matcher(str(file_path))
                    if self.debug and not should_include:
                        print(f"Debug: Skipping gitignored file: {file_path}")
                    return should_include
                except Exception as e:
                    print(f"Warning: gitignore matching failed for {file_path}: {e}")
                    return True

            if self.debug:
                print(f"Debug: Including file: {file_path}")
            return True

        except Exception as e:
            print(f"Warning: Error checking file {file_path}: {e}")
            return False

    def _get_file_content(self, file_path: Path) -> str:
        """Read file content with proper encoding handling"""
        try:
            # Try UTF-8 first
            with open(file_path, 'r', encoding='utf-8') as f:
                return f.read()
        except UnicodeDecodeError:
            try:
                # Fallback to latin-1
                with open(file_path, 'r', encoding='latin-1') as f:
                    return f.read()
            except Exception as e:
                print(f"Warning: Failed to read {file_path}: {e}")
                return f"ERROR: Could not read file {file_path}\n"

    def _generate_directory_structure(self) -> str:
        """Generate a tree-like directory structure"""
        structure = ["Directory Structure:", ""]

        def add_to_tree(path: Path, prefix: str = ""):
            # Skip excluded directories
            excluded_dirs = {
                '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
                '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
                'dist', 'build', 'target'
            }
            if path.name in excluded_dirs:
                return

            # Add files first
            files = sorted([p for p in path.iterdir() if p.is_file()])
            included_files = [f for f in files if self._should_include_file(f)]

            for idx, file in enumerate(included_files):
                is_last = idx == len(included_files) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {file.name}")

            # Then add directories
            dirs = sorted([p for p in path.iterdir() if p.is_dir()])
            included_dirs = [d for d in dirs if d.name not in excluded_dirs]

            for idx, dir in enumerate(included_dirs):
                is_last = idx == len(included_dirs) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {dir.name}/")
                add_to_tree(dir, prefix + ("    " if is_last else "│   "))

        add_to_tree(self.project_path)
        return "\n".join(structure)

    def concatenate(self, debug: bool = False):
        """Main method to concatenate all source files"""
        self.debug = debug
        if not self.project_path.exists():
            print(f"Error: Project path {self.project_path} does not exist")
            return False

        try:
            with open(self.output_file, 'w', encoding='utf-8') as out:
                # Write header
                header = f"""
# Project Source Code Concatenation
# Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
# Project path: {self.project_path}

"""
                out.write(header)

                # Write directory structure if enabled
                if self.include_structure:
                    out.write(self._generate_directory_structure())
                    out.write("\n\n" + "="*80 + "\n\n")

                # Process all files
                file_count = 0
                for file_path in self.project_path.rglob('*'):
                    if file_path.is_file() and self._should_include_file(file_path):
                        rel_path = file_path.relative_to(self.project_path)

                        # Write file header
                        out.write(f"\n\n# File: {rel_path}\n")
                        out.write("="*80 + "\n\n")

                        # Write file content
                        content = self._get_file_content(file_path)
                        out.write(content)
                        file_count += 1

                print(f"Successfully melted {file_count} files to {self.output_file}")
                return True

        except Exception as e:
            print(f"Error during melting: {e}")
            return False

def main():
    parser = argparse.ArgumentParser(
        description="CodeSmelt: Melt down your git project's source code into a single file",
        usage="%(prog)s project_path [output_file] [-o OUTPUT] [-d] [-n]"
    )

    # Add the project path as required positional argument
    parser.add_argument(
        "project_path",
        help="Path to the git project directory"
    )

    # Add optional positional argument for output file
    parser.add_argument(
        "output_file",
        nargs="?",  # Make it optional
        help="Output file path (alternative to -o)",
        default=None
    )

    # Keep the original -o option for backward compatibility
    parser.add_argument(
        "-o", "--output",
        help="Output file path (default: concatenated_source.txt)",
        default=None
    )

    parser.add_argument(
        "-d", "--debug",
        action="store_true",
        help="Enable debug logging"
    )

    parser.add_argument(
        "-n", "--no-structure",
        action="store_true",
        help="Omit directory structure from output"
    )

    args = parser.parse_args()

    # Determine the output file path, prioritizing command line arguments
    output_file = args.output or args.output_file or "concatenated_source.txt"

    concatenator = CodeSmelt(args.project_path, output_file)
    concatenator.include_structure = not args.no_structure
    success = concatenator.concatenate(debug=args.debug)
    sys.exit(0 if success else 1)

if __name__ == "__main__":
    main()

# File: test_with_structure.txt
================================================================================


# Project Source Code Concatenation
# Generated on: 2025-02-15 23:26:14
# Project path: /home/runner/workspace

Directory Structure:

├── README.md
├── codesmelt.py
├── extensions.py
├── pyproject.toml
├── requirements.txt
└── test_with_structure.txt
└── assets/

================================================================================



# File: extensions.py
================================================================================

"""
Source code file extension configurations
"""

# Common source code file extensions
SOURCE_EXTENSIONS = {
    # Web
    '.js', '.ts', '.jsx', '.tsx', '.vue', '.svelte',
    '.html', '.htm', '.css', '.scss', '.sass', '.less',
    
    # Python
    '.py', '.pyi', '.pyx',
    
    # Java/Kotlin
    '.java', '.kt', '.groovy',
    
    # C-family
    '.c', '.cpp', '.h', '.hpp', '.cc',
    
    # C#
    '.cs', '.cshtml', '.csx',
    
    # Ruby
    '.rb', '.erb',
    
    # PHP
    '.php', '.php5', '.phtml',
    
    # Go
    '.go',
    
    # Rust
    '.rs',
    
    # Swift
    '.swift',
    
    # Shell
    '.sh', '.bash', '.zsh',
    
    # Config/Data
    '.json', '.yaml', '.yml', '.toml', '.xml',
    '.conf', '.ini', '.env',
    
    # Documentation
    '.md', '.rst', '.txt'
}

# Files to always ignore
IGNORE_PATTERNS = {
    # Build outputs
    'build/*', 'dist/*', 'target/*', 'bin/*',
    '*.pyc', '__pycache__/*', '*.class',
    
    # Dependencies
    'node_modules/*', 'vendor/*', 'venv/*',
    
    # IDE files
    '.idea/*', '.vscode/*', '*.swp',
    
    # Package files
    'package-lock.json', 'yarn.lock',
    'Pipfile.lock', 'poetry.lock',
    
    # Large data files
    '*.csv', '*.json.gz', '*.sql',
    
    # Binary/Media files
    '*.pdf', '*.jpg', '*.png', '*.gif',
    '*.mp3', '*.mp4', '*.mov', '*.bin',
    '*.exe', '*.dll', '*.so', '*.dylib'
}


# File: pyproject.toml
================================================================================

[project]
name = "repl-nix-workspace"
version = "0.1.0"
description = "Add your description here"
requires-python = ">=3.11"
dependencies = [
    "gitignore-parser>=0.1.11",
]


# File: requirements.txt
================================================================================

gitignore_parser==0.1.11

# File: README.md
================================================================================

# CodeSmelt: Source Code Concatenator

![CodeSmelt Logo](assets/CodeSmeltLogo.jpg)

**CodeSmelt** is a command-line tool that “melts down” your Git project’s source code into a single, well-organized file. It not only concatenates source files but also embeds a tree-like directory structure to help you quickly understand your project’s layout. This is especially useful for code analysis, preparing inputs for language models, or sharing project snapshots.

---

## Table of Contents

- [Features](#features)
- [Installation](#installation)
- [Usage](#usage)
  - [Basic Usage](#basic-usage)
  - [Custom Output & Debug Mode](#custom-output--debug-mode)
- [Configuration](#configuration)
  - [Source File Extensions](#source-file-extensions)
  - [Ignore Patterns](#ignore-patterns)
- [Tips for Using with LLMs](#tips-for-using-with-llms)
- [Troubleshooting](#troubleshooting)
- [Contributing](#contributing)
- [License](#license)
- [Author](#author)

---

## Features

- **Concatenation with Context:** Combines all source files (with supported extensions) into one file while preserving directory hierarchy.
- **Smart Filtering:** Uses built-in file extension whitelists and ignore patterns. Also honors your project’s `.gitignore` for extra filtering.
- **Encoding Handling:** Automatically handles file encoding issues (tries UTF-8 first, then falls back to Latin-1).
- **Debug Logging:** Option to enable debug logging so you can see which files are being included or skipped.
- **Easy Customization:** Adjust supported file extensions and ignore patterns via the `extensions.py` file.

---

## Installation

1. **Clone the Repository:**

   ```bash
   git clone https://github.com/yourusername/codesmelt.git
   cd codesmelt
   ```

2. **Install Dependencies:**

   CodeSmelt requires Python 3. Instead of installing dependencies individually, you can install all required packages using the `requirements.txt` file:

   ```bash
   pip install -r requirements.txt
   ```

   *(If you use a virtual environment, activate it before installing.)*

3. **Ensure File Structure:**

   Make sure the following files are in the same directory:
   
   - `codesmelt.py`
   - `extensions.py`
   - `README.md`
   - `requirements.txt`
   - `assets/CodeSmeltLogo.jpg` (logo image)

---

## Usage

### Basic Usage

Run CodeSmelt by providing the path to your Git project. For example:

```bash
python codesmelt.py /path/to/project
```

### Custom Output & Debug Mode

- **Specify a Custom Output File:**

  ```bash
  python codesmelt.py -o output.txt /path/to/project
  ```

- **Enable Debug Logging:**

  ```bash
  python codesmelt.py -d -o output.txt /path/to/project
  ```

#### Command-line Arguments

- `project_path` (required): Path to your Git project directory.
- `-o, --output`: Specify the output file path (default: `concatenated_source.txt`).
- `-d, --debug`: Enable debug logging to get detailed information about file selection.

---

## Configuration

CodeSmelt uses the `extensions.py` file to define:

### Source File Extensions

The tool automatically includes many common source code file extensions. Examples include:

- **Web:** `.js`, `.ts`, `.jsx`, `.tsx`, `.vue`, `.svelte`, `.html`, `.css`, etc.
- **Python:** `.py`, `.pyi`, `.pyx`
- **Java/Kotlin:** `.java`, `.kt`, `.groovy`
- **C-family:** `.c`, `.cpp`, `.h`, `.hpp`
- **Other Languages:** Ruby (`.rb`), PHP (`.php`), Go (`.go`), Rust (`.rs`), Swift (`.swift`), Shell (`.sh`), and more.

*To add or remove extensions, edit the `SOURCE_EXTENSIONS` set in `extensions.py`.*

### Ignore Patterns

Files and directories are automatically ignored based on three levels:

1. **Built-in Patterns:** Defined in the `IGNORE_PATTERNS` set in `extensions.py` (e.g., build outputs, dependency directories, IDE files, binary/media files).
2. **Project’s `.gitignore`:** If a `.gitignore` is present at the root of your project, CodeSmelt honors its rules.
3. **Directory-specific Rules:** Additional `.gitignore` files in subdirectories will also be considered.

*To customize, modify the `IGNORE_PATTERNS` in `extensions.py`.*

Example of adding Unity3D-specific ignores:

```python
IGNORE_PATTERNS = {
    # ... existing patterns ...
    'Assets/AssetStoreTools/*',
    'Library/*',
    'Temp/*',
    'Logs/*',
    '*.unity',  # Unity scene files
    '*.meta',   # Unity meta files
    '*.prefab', # Unity prefab files
    # ... other patterns ...
}
```

---

## Tips for Using with LLMs

1. **Token Management:**
   - For very large projects, consider concatenating only specific directories to avoid token limits.
   - Use debug mode (`-d`) to verify which files are included/excluded.

2. **Effective Prompting:**
   - Reference files using their relative paths as shown in the generated directory structure.
   - Ask questions about specific sections of the output using the file headers.

3. **Best Practices:**
   - Always review the concatenated output before sending it to an LLM.
   - For large projects, consider breaking down the analysis into smaller, manageable components.

---

## Troubleshooting

### Common Issues

1. **No Files Found:**
   - Double-check the project path.
   - Ensure your project contains files with supported extensions.
   - Run with `--debug` to see detailed file filtering information.

2. **Missing Dependencies:**
   - Make sure you have installed all required packages by running:
     
     ```bash
     pip install -r requirements.txt
     ```

3. **Permission Issues:**
   - Make sure you have read permissions for the project directory and write permissions for the output file.

---

## Contributing

Contributions are welcome! If you have ideas for improvements, bug fixes, or additional features, please fork the repository and submit a pull request. For major changes, please open an issue first to discuss what you would like to change.

---

## License

This project is licensed under the [MIT License](LICENSE).

---

## Author

**Shiraz Akmal**

Feel free to reach out if you have any questions or feedback!

---

Happy coding with CodeSmelt!

# File: codesmelt.py
================================================================================

#!/usr/bin/env python3
"""
CodeSmelt: Source Code Concatenator

This tool melts down source code files from a git project into a single file,
including directory structure information.
"""

import argparse
import sys
from pathlib import Path
import os
from typing import Set, List, Optional
import fnmatch
from datetime import datetime
import gitignore_parser
from extensions import SOURCE_EXTENSIONS, IGNORE_PATTERNS

class CodeSmelt:
    def __init__(self, project_path: str, output_file: str):
        self.project_path = Path(project_path).resolve()
        self.output_file = Path(output_file)
        self.gitignore_matcher = self._setup_gitignore()
        self.debug = False
        self.include_structure = True

    def _setup_gitignore(self) -> Optional[callable]:
        """Setup gitignore matcher if .gitignore exists"""
        gitignore_path = self.project_path / '.gitignore'
        if gitignore_path.exists():
            try:
                return gitignore_parser.parse_gitignore(gitignore_path)
            except Exception as e:
                print(f"Warning: Failed to parse .gitignore: {e}")
        return None

    def _should_include_file(self, file_path: Path) -> bool:
        """Check if file should be included based on extension and ignore rules"""
        # Skip common virtual environment and system directories
        excluded_dirs = {
            '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
            '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
            'dist', 'build', 'target'
        }

        try:
            # Convert to relative path for checking
            try:
                rel_path = file_path.relative_to(self.project_path)
            except ValueError:
                if self.debug:
                    print(f"Debug: Skipping file outside project path: {file_path}")
                return False

            # Check for excluded directories in the path
            if any(part in excluded_dirs for part in file_path.parts):
                if self.debug:
                    print(f"Debug: Skipping excluded directory: {file_path}")
                return False

            # Check if file extension is in whitelist
            if file_path.suffix.lower() not in SOURCE_EXTENSIONS:
                if self.debug:
                    print(f"Debug: Skipping non-source file: {file_path}")
                return False

            # Check custom ignore patterns
            for pattern in IGNORE_PATTERNS:
                if fnmatch.fnmatch(str(rel_path), pattern):
                    if self.debug:
                        print(f"Debug: Skipping ignored pattern {pattern}: {file_path}")
                    return False

            # Check .gitignore if available
            if self.gitignore_matcher:
                try:
                    should_include = not self.gitignore_matcher(str(file_path))
                    if self.debug and not should_include:
                        print(f"Debug: Skipping gitignored file: {file_path}")
                    return should_include
                except Exception as e:
                    print(f"Warning: gitignore matching failed for {file_path}: {e}")
                    return True

            if self.debug:
                print(f"Debug: Including file: {file_path}")
            return True

        except Exception as e:
            print(f"Warning: Error checking file {file_path}: {e}")
            return False

    def _get_file_content(self, file_path: Path) -> str:
        """Read file content with proper encoding handling"""
        try:
            # Try UTF-8 first
            with open(file_path, 'r', encoding='utf-8') as f:
                return f.read()
        except UnicodeDecodeError:
            try:
                # Fallback to latin-1
                with open(file_path, 'r', encoding='latin-1') as f:
                    return f.read()
            except Exception as e:
                print(f"Warning: Failed to read {file_path}: {e}")
                return f"ERROR: Could not read file {file_path}\n"

    def _generate_directory_structure(self) -> str:
        """Generate a tree-like directory structure"""
        structure = ["Directory Structure:", ""]

        def add_to_tree(path: Path, prefix: str = ""):
            # Skip excluded directories
            excluded_dirs = {
                '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
                '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
                'dist', 'build', 'target'
            }
            if path.name in excluded_dirs:
                return

            # Add files first
            files = sorted([p for p in path.iterdir() if p.is_file()])
            included_files = [f for f in files if self._should_include_file(f)]

            for idx, file in enumerate(included_files):
                is_last = idx == len(included_files) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {file.name}")

            # Then add directories
            dirs = sorted([p for p in path.iterdir() if p.is_dir()])
            included_dirs = [d for d in dirs if d.name not in excluded_dirs]

            for idx, dir in enumerate(included_dirs):
                is_last = idx == len(included_dirs) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {dir.name}/")
                add_to_tree(dir, prefix + ("    " if is_last else "│   "))

        add_to_tree(self.project_path)
        return "\n".join(structure)

    def concatenate(self, debug: bool = False):
        """Main method to concatenate all source files"""
        self.debug = debug
        if not self.project_path.exists():
            print(f"Error: Project path {self.project_path} does not exist")
            return False

        try:
            with open(self.output_file, 'w', encoding='utf-8') as out:
                # Write header
                header = f"""
# Project Source Code Concatenation
# Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
# Project path: {self.project_path}

"""
                out.write(header)

                # Write directory structure if enabled
                if self.include_structure:
                    out.write(self._generate_directory_structure())
                    out.write("\n\n" + "="*80 + "\n\n")

                # Process all files
                file_count = 0
                for file_path in self.project_path.rglob('*'):
                    if file_path.is_file() and self._should_include_file(file_path):
                        rel_path = file_path.relative_to(self.project_path)

                        # Write file header
                        out.write(f"\n\n# File: {rel_path}\n")
                        out.write("="*80 + "\n\n")

                        # Write file content
                        content = self._get_file_content(file_path)
                        out.write(content)
                        file_count += 1

                print(f"Successfully melted {file_count} files to {self.output_file}")
                return True

        except Exception as e:
            print(f"Error during melting: {e}")
            return False

def main():
    parser = argparse.ArgumentParser(
        description="CodeSmelt: Melt down your git project's source code into a single file",
        usage="%(prog)s project_path [output_file] [-o OUTPUT] [-d] [-n]"
    )

    # Add the project path as required positional argument
    parser.add_argument(
        "project_path",
        help="Path to the git project directory"
    )

    # Add optional positional argument for output file
    parser.add_argument(
        "output_file",
        nargs="?",  # Make it optional
        help="Output file path (alternative to -o)",
        default=None
    )

    # Keep the original -o option for backward compatibility
    parser.add_argument(
        "-o", "--output",
        help="Output file path (default: concatenated_source.txt)",
        default=None
    )

    parser.add_argument(
        "-d", "--debug",
        action="store_true",
        help="Enable debug logging"
    )

    parser.add_argument(
        "-n", "--no-structure",
        action="store_true",
        help="Omit directory structure from output"
    )

    args = parser.parse_args()

    # Determine the output file path, prioritizing command line arguments
    output_file = args.output or args.output_file or "concatenated_source.txt"

    concatenator = CodeSmelt(args.project_path, output_file)
    concatenator.include_structure = not args.no_structure
    success = concatenator.concatenate(debug=args.debug)
    sys.exit(0 if success else 1)

if __name__ == "__main__":
    main()

# File: test_without_structure.txt
================================================================================


# Project Source Code Concatenation
# Generated on: 2025-02-15 23:26:14
# Project path: /home/runner/workspace



# File: extensions.py
================================================================================

"""
Source code file extension configurations
"""

# Common source code file extensions
SOURCE_EXTENSIONS = {
    # Web
    '.js', '.ts', '.jsx', '.tsx', '.vue', '.svelte',
    '.html', '.htm', '.css', '.scss', '.sass', '.less',
    
    # Python
    '.py', '.pyi', '.pyx',
    
    # Java/Kotlin
    '.java', '.kt', '.groovy',
    
    # C-family
    '.c', '.cpp', '.h', '.hpp', '.cc',
    
    # C#
    '.cs', '.cshtml', '.csx',
    
    # Ruby
    '.rb', '.erb',
    
    # PHP
    '.php', '.php5', '.phtml',
    
    # Go
    '.go',
    
    # Rust
    '.rs',
    
    # Swift
    '.swift',
    
    # Shell
    '.sh', '.bash', '.zsh',
    
    # Config/Data
    '.json', '.yaml', '.yml', '.toml', '.xml',
    '.conf', '.ini', '.env',
    
    # Documentation
    '.md', '.rst', '.txt'
}

# Files to always ignore
IGNORE_PATTERNS = {
    # Build outputs
    'build/*', 'dist/*', 'target/*', 'bin/*',
    '*.pyc', '__pycache__/*', '*.class',
    
    # Dependencies
    'node_modules/*', 'vendor/*', 'venv/*',
    
    # IDE files
    '.idea/*', '.vscode/*', '*.swp',
    
    # Package files
    'package-lock.json', 'yarn.lock',
    'Pipfile.lock', 'poetry.lock',
    
    # Large data files
    '*.csv', '*.json.gz', '*.sql',
    
    # Binary/Media files
    '*.pdf', '*.jpg', '*.png', '*.gif',
    '*.mp3', '*.mp4', '*.mov', '*.bin',
    '*.exe', '*.dll', '*.so', '*.dylib'
}


# File: pyproject.toml
================================================================================

[project]
name = "repl-nix-workspace"
version = "0.1.0"
description = "Add your description here"
requires-python = ">=3.11"
dependencies = [
    "gitignore-parser>=0.1.11",
]


# File: requirements.txt
================================================================================

gitignore_parser==0.1.11

# File: README.md
================================================================================

# CodeSmelt: Source Code Concatenator

![CodeSmelt Logo](assets/CodeSmeltLogo.jpg)

**CodeSmelt** is a command-line tool that “melts down” your Git project’s source code into a single, well-organized file. It not only concatenates source files but also embeds a tree-like directory structure to help you quickly understand your project’s layout. This is especially useful for code analysis, preparing inputs for language models, or sharing project snapshots.

---

## Table of Contents

- [Features](#features)
- [Installation](#installation)
- [Usage](#usage)
  - [Basic Usage](#basic-usage)
  - [Custom Output & Debug Mode](#custom-output--debug-mode)
- [Configuration](#configuration)
  - [Source File Extensions](#source-file-extensions)
  - [Ignore Patterns](#ignore-patterns)
- [Tips for Using with LLMs](#tips-for-using-with-llms)
- [Troubleshooting](#troubleshooting)
- [Contributing](#contributing)
- [License](#license)
- [Author](#author)

---

## Features

- **Concatenation with Context:** Combines all source files (with supported extensions) into one file while preserving directory hierarchy.
- **Smart Filtering:** Uses built-in file extension whitelists and ignore patterns. Also honors your project’s `.gitignore` for extra filtering.
- **Encoding Handling:** Automatically handles file encoding issues (tries UTF-8 first, then falls back to Latin-1).
- **Debug Logging:** Option to enable debug logging so you can see which files are being included or skipped.
- **Easy Customization:** Adjust supported file extensions and ignore patterns via the `extensions.py` file.

---

## Installation

1. **Clone the Repository:**

   ```bash
   git clone https://github.com/yourusername/codesmelt.git
   cd codesmelt
   ```

2. **Install Dependencies:**

   CodeSmelt requires Python 3. Instead of installing dependencies individually, you can install all required packages using the `requirements.txt` file:

   ```bash
   pip install -r requirements.txt
   ```

   *(If you use a virtual environment, activate it before installing.)*

3. **Ensure File Structure:**

   Make sure the following files are in the same directory:
   
   - `codesmelt.py`
   - `extensions.py`
   - `README.md`
   - `requirements.txt`
   - `assets/CodeSmeltLogo.jpg` (logo image)

---

## Usage

### Basic Usage

Run CodeSmelt by providing the path to your Git project. For example:

```bash
python codesmelt.py /path/to/project
```

### Custom Output & Debug Mode

- **Specify a Custom Output File:**

  ```bash
  python codesmelt.py -o output.txt /path/to/project
  ```

- **Enable Debug Logging:**

  ```bash
  python codesmelt.py -d -o output.txt /path/to/project
  ```

#### Command-line Arguments

- `project_path` (required): Path to your Git project directory.
- `-o, --output`: Specify the output file path (default: `concatenated_source.txt`).
- `-d, --debug`: Enable debug logging to get detailed information about file selection.

---

## Configuration

CodeSmelt uses the `extensions.py` file to define:

### Source File Extensions

The tool automatically includes many common source code file extensions. Examples include:

- **Web:** `.js`, `.ts`, `.jsx`, `.tsx`, `.vue`, `.svelte`, `.html`, `.css`, etc.
- **Python:** `.py`, `.pyi`, `.pyx`
- **Java/Kotlin:** `.java`, `.kt`, `.groovy`
- **C-family:** `.c`, `.cpp`, `.h`, `.hpp`
- **Other Languages:** Ruby (`.rb`), PHP (`.php`), Go (`.go`), Rust (`.rs`), Swift (`.swift`), Shell (`.sh`), and more.

*To add or remove extensions, edit the `SOURCE_EXTENSIONS` set in `extensions.py`.*

### Ignore Patterns

Files and directories are automatically ignored based on three levels:

1. **Built-in Patterns:** Defined in the `IGNORE_PATTERNS` set in `extensions.py` (e.g., build outputs, dependency directories, IDE files, binary/media files).
2. **Project’s `.gitignore`:** If a `.gitignore` is present at the root of your project, CodeSmelt honors its rules.
3. **Directory-specific Rules:** Additional `.gitignore` files in subdirectories will also be considered.

*To customize, modify the `IGNORE_PATTERNS` in `extensions.py`.*

Example of adding Unity3D-specific ignores:

```python
IGNORE_PATTERNS = {
    # ... existing patterns ...
    'Assets/AssetStoreTools/*',
    'Library/*',
    'Temp/*',
    'Logs/*',
    '*.unity',  # Unity scene files
    '*.meta',   # Unity meta files
    '*.prefab', # Unity prefab files
    # ... other patterns ...
}
```

---

## Tips for Using with LLMs

1. **Token Management:**
   - For very large projects, consider concatenating only specific directories to avoid token limits.
   - Use debug mode (`-d`) to verify which files are included/excluded.

2. **Effective Prompting:**
   - Reference files using their relative paths as shown in the generated directory structure.
   - Ask questions about specific sections of the output using the file headers.

3. **Best Practices:**
   - Always review the concatenated output before sending it to an LLM.
   - For large projects, consider breaking down the analysis into smaller, manageable components.

---

## Troubleshooting

### Common Issues

1. **No Files Found:**
   - Double-check the project path.
   - Ensure your project contains files with supported extensions.
   - Run with `--debug` to see detailed file filtering information.

2. **Missing Dependencies:**
   - Make sure you have installed all required packages by running:
     
     ```bash
     pip install -r requirements.txt
     ```

3. **Permission Issues:**
   - Make sure you have read permissions for the project directory and write permissions for the output file.

---

## Contributing

Contributions are welcome! If you have ideas for improvements, bug fixes, or additional features, please fork the repository and submit a pull request. For major changes, please open an issue first to discuss what you would like to change.

---

## License

This project is licensed under the [MIT License](LICENSE).

---

## Author

**Shiraz Akmal**

Feel free to reach out if you have any questions or feedback!

---

Happy coding with CodeSmelt!

# File: codesmelt.py
================================================================================

#!/usr/bin/env python3
"""
CodeSmelt: Source Code Concatenator

This tool melts down source code files from a git project into a single file,
including directory structure information.
"""

import argparse
import sys
from pathlib import Path
import os
from typing import Set, List, Optional
import fnmatch
from datetime import datetime
import gitignore_parser
from extensions import SOURCE_EXTENSIONS, IGNORE_PATTERNS

class CodeSmelt:
    def __init__(self, project_path: str, output_file: str):
        self.project_path = Path(project_path).resolve()
        self.output_file = Path(output_file)
        self.gitignore_matcher = self._setup_gitignore()
        self.debug = False
        self.include_structure = True

    def _setup_gitignore(self) -> Optional[callable]:
        """Setup gitignore matcher if .gitignore exists"""
        gitignore_path = self.project_path / '.gitignore'
        if gitignore_path.exists():
            try:
                return gitignore_parser.parse_gitignore(gitignore_path)
            except Exception as e:
                print(f"Warning: Failed to parse .gitignore: {e}")
        return None

    def _should_include_file(self, file_path: Path) -> bool:
        """Check if file should be included based on extension and ignore rules"""
        # Skip common virtual environment and system directories
        excluded_dirs = {
            '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
            '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
            'dist', 'build', 'target'
        }

        try:
            # Convert to relative path for checking
            try:
                rel_path = file_path.relative_to(self.project_path)
            except ValueError:
                if self.debug:
                    print(f"Debug: Skipping file outside project path: {file_path}")
                return False

            # Check for excluded directories in the path
            if any(part in excluded_dirs for part in file_path.parts):
                if self.debug:
                    print(f"Debug: Skipping excluded directory: {file_path}")
                return False

            # Check if file extension is in whitelist
            if file_path.suffix.lower() not in SOURCE_EXTENSIONS:
                if self.debug:
                    print(f"Debug: Skipping non-source file: {file_path}")
                return False

            # Check custom ignore patterns
            for pattern in IGNORE_PATTERNS:
                if fnmatch.fnmatch(str(rel_path), pattern):
                    if self.debug:
                        print(f"Debug: Skipping ignored pattern {pattern}: {file_path}")
                    return False

            # Check .gitignore if available
            if self.gitignore_matcher:
                try:
                    should_include = not self.gitignore_matcher(str(file_path))
                    if self.debug and not should_include:
                        print(f"Debug: Skipping gitignored file: {file_path}")
                    return should_include
                except Exception as e:
                    print(f"Warning: gitignore matching failed for {file_path}: {e}")
                    return True

            if self.debug:
                print(f"Debug: Including file: {file_path}")
            return True

        except Exception as e:
            print(f"Warning: Error checking file {file_path}: {e}")
            return False

    def _get_file_content(self, file_path: Path) -> str:
        """Read file content with proper encoding handling"""
        try:
            # Try UTF-8 first
            with open(file_path, 'r', encoding='utf-8') as f:
                return f.read()
        except UnicodeDecodeError:
            try:
                # Fallback to latin-1
                with open(file_path, 'r', encoding='latin-1') as f:
                    return f.read()
            except Exception as e:
                print(f"Warning: Failed to read {file_path}: {e}")
                return f"ERROR: Could not read file {file_path}\n"

    def _generate_directory_structure(self) -> str:
        """Generate a tree-like directory structure"""
        structure = ["Directory Structure:", ""]

        def add_to_tree(path: Path, prefix: str = ""):
            # Skip excluded directories
            excluded_dirs = {
                '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
                '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
                'dist', 'build', 'target'
            }
            if path.name in excluded_dirs:
                return

            # Add files first
            files = sorted([p for p in path.iterdir() if p.is_file()])
            included_files = [f for f in files if self._should_include_file(f)]

            for idx, file in enumerate(included_files):
                is_last = idx == len(included_files) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {file.name}")

            # Then add directories
            dirs = sorted([p for p in path.iterdir() if p.is_dir()])
            included_dirs = [d for d in dirs if d.name not in excluded_dirs]

            for idx, dir in enumerate(included_dirs):
                is_last = idx == len(included_dirs) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {dir.name}/")
                add_to_tree(dir, prefix + ("    " if is_last else "│   "))

        add_to_tree(self.project_path)
        return "\n".join(structure)

    def concatenate(self, debug: bool = False):
        """Main method to concatenate all source files"""
        self.debug = debug
        if not self.project_path.exists():
            print(f"Error: Project path {self.project_path} does not exist")
            return False

        try:
            with open(self.output_file, 'w', encoding='utf-8') as out:
                # Write header
                header = f"""
# Project Source Code Concatenation
# Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
# Project path: {self.project_path}

"""
                out.write(header)

                # Write directory structure if enabled
                if self.include_structure:
                    out.write(self._generate_directory_structure())
                    out.write("\n\n" + "="*80 + "\n\n")

                # Process all files
                file_count = 0
                for file_path in self.project_path.rglob('*'):
                    if file_path.is_file() and self._should_include_file(file_path):
                        rel_path = file_path.relative_to(self.project_path)

                        # Write file header
                        out.write(f"\n\n# File: {rel_path}\n")
                        out.write("="*80 + "\n\n")

                        # Write file content
                        content = self._get_file_content(file_path)
                        out.write(content)
                        file_count += 1

                print(f"Successfully melted {file_count} files to {self.output_file}")
                return True

        except Exception as e:
            print(f"Error during melting: {e}")
            return False

def main():
    parser = argparse.ArgumentParser(
        description="CodeSmelt: Melt down your git project's source code into a single file",
        usage="%(prog)s project_path [output_file] [-o OUTPUT] [-d] [-n]"
    )

    # Add the project path as required positional argument
    parser.add_argument(
        "project_path",
        help="Path to the git project directory"
    )

    # Add optional positional argument for output file
    parser.add_argument(
        "output_file",
        nargs="?",  # Make it optional
        help="Output file path (alternative to -o)",
        default=None
    )

    # Keep the original -o option for backward compatibility
    parser.add_argument(
        "-o", "--output",
        help="Output file path (default: concatenated_source.txt)",
        default=None
    )

    parser.add_argument(
        "-d", "--debug",
        action="store_true",
        help="Enable debug logging"
    )

    parser.add_argument(
        "-n", "--no-structure",
        action="store_true",
        help="Omit directory structure from output"
    )

    args = parser.parse_args()

    # Determine the output file path, prioritizing command line arguments
    output_file = args.output or args.output_file or "concatenated_source.txt"

    concatenator = CodeSmelt(args.project_path, output_file)
    concatenator.include_structure = not args.no_structure
    success = concatenator.concatenate(debug=args.debug)
    sys.exit(0 if success else 1)

if __name__ == "__main__":
    main()

# File: test_with_structure.txt
================================================================================


# Project Source Code Concatenation
# Generated on: 2025-02-15 23:26:14
# Project path: /home/runner/workspace

Directory Structure:

├── README.md
├── codesmelt.py
├── extensions.py
├── pyproject.toml
├── requirements.txt
└── test_with_structure.txt
└── assets/

================================================================================



# File: extensions.py
================================================================================

"""
Source code file extension configurations
"""

# Common source code file extensions
SOURCE_EXTENSIONS = {
    # Web
    '.js', '.ts', '.jsx', '.tsx', '.vue', '.svelte',
    '.html', '.htm', '.css', '.scss', '.sass', '.less',
    
    # Python
    '.py', '.pyi', '.pyx',
    
    # Java/Kotlin
    '.java', '.kt', '.groovy',
    
    # C-family
    '.c', '.cpp', '.h', '.hpp', '.cc',
    
    # C#
    '.cs', '.cshtml', '.csx',
    
    # Ruby
    '.rb', '.erb',
    
    # PHP
    '.php', '.php5', '.phtml',
    
    # Go
    '.go',
    
    # Rust
    '.rs',
    
    # Swift
    '.swift',
    
    # Shell
    '.sh', '.bash', '.zsh',
    
    # Config/Data
    '.json', '.yaml', '.yml', '.toml', '.xml',
    '.conf', '.ini', '.env',
    
    # Documentation
    '.md', '.rst', '.txt'
}

# Files to always ignore
IGNORE_PATTERNS = {
    # Build outputs
    'build/*', 'dist/*', 'target/*', 'bin/*',
    '*.pyc', '__pycache__/*', '*.class',
    
    # Dependencies
    'node_modules/*', 'vendor/*', 'venv/*',
    
    # IDE files
    '.idea/*', '.vscode/*', '*.swp',
    
    # Package files
    'package-lock.json', 'yarn.lock',
    'Pipfile.lock', 'poetry.lock',
    
    # Large data files
    '*.csv', '*.json.gz', '*.sql',
    
    # Binary/Media files
    '*.pdf', '*.jpg', '*.png', '*.gif',
    '*.mp3', '*.mp4', '*.mov', '*.bin',
    '*.exe', '*.dll', '*.so', '*.dylib'
}


# File: pyproject.toml
================================================================================

[project]
name = "repl-nix-workspace"
version = "0.1.0"
description = "Add your description here"
requires-python = ">=3.11"
dependencies = [
    "gitignore-parser>=0.1.11",
]


# File: requirements.txt
================================================================================

gitignore_parser==0.1.11

# File: README.md
================================================================================

# CodeSmelt: Source Code Concatenator

![CodeSmelt Logo](assets/CodeSmeltLogo.jpg)

**CodeSmelt** is a command-line tool that “melts down” your Git project’s source code into a single, well-organized file. It not only concatenates source files but also embeds a tree-like directory structure to help you quickly understand your project’s layout. This is especially useful for code analysis, preparing inputs for language models, or sharing project snapshots.

---

## Table of Contents

- [Features](#features)
- [Installation](#installation)
- [Usage](#usage)
  - [Basic Usage](#basic-usage)
  - [Custom Output & Debug Mode](#custom-output--debug-mode)
- [Configuration](#configuration)
  - [Source File Extensions](#source-file-extensions)
  - [Ignore Patterns](#ignore-patterns)
- [Tips for Using with LLMs](#tips-for-using-with-llms)
- [Troubleshooting](#troubleshooting)
- [Contributing](#contributing)
- [License](#license)
- [Author](#author)

---

## Features

- **Concatenation with Context:** Combines all source files (with supported extensions) into one file while preserving directory hierarchy.
- **Smart Filtering:** Uses built-in file extension whitelists and ignore patterns. Also honors your project’s `.gitignore` for extra filtering.
- **Encoding Handling:** Automatically handles file encoding issues (tries UTF-8 first, then falls back to Latin-1).
- **Debug Logging:** Option to enable debug logging so you can see which files are being included or skipped.
- **Easy Customization:** Adjust supported file extensions and ignore patterns via the `extensions.py` file.

---

## Installation

1. **Clone the Repository:**

   ```bash
   git clone https://github.com/yourusername/codesmelt.git
   cd codesmelt
   ```

2. **Install Dependencies:**

   CodeSmelt requires Python 3. Instead of installing dependencies individually, you can install all required packages using the `requirements.txt` file:

   ```bash
   pip install -r requirements.txt
   ```

   *(If you use a virtual environment, activate it before installing.)*

3. **Ensure File Structure:**

   Make sure the following files are in the same directory:
   
   - `codesmelt.py`
   - `extensions.py`
   - `README.md`
   - `requirements.txt`
   - `assets/CodeSmeltLogo.jpg` (logo image)

---

## Usage

### Basic Usage

Run CodeSmelt by providing the path to your Git project. For example:

```bash
python codesmelt.py /path/to/project
```

### Custom Output & Debug Mode

- **Specify a Custom Output File:**

  ```bash
  python codesmelt.py -o output.txt /path/to/project
  ```

- **Enable Debug Logging:**

  ```bash
  python codesmelt.py -d -o output.txt /path/to/project
  ```

#### Command-line Arguments

- `project_path` (required): Path to your Git project directory.
- `-o, --output`: Specify the output file path (default: `concatenated_source.txt`).
- `-d, --debug`: Enable debug logging to get detailed information about file selection.

---

## Configuration

CodeSmelt uses the `extensions.py` file to define:

### Source File Extensions

The tool automatically includes many common source code file extensions. Examples include:

- **Web:** `.js`, `.ts`, `.jsx`, `.tsx`, `.vue`, `.svelte`, `.html`, `.css`, etc.
- **Python:** `.py`, `.pyi`, `.pyx`
- **Java/Kotlin:** `.java`, `.kt`, `.groovy`
- **C-family:** `.c`, `.cpp`, `.h`, `.hpp`
- **Other Languages:** Ruby (`.rb`), PHP (`.php`), Go (`.go`), Rust (`.rs`), Swift (`.swift`), Shell (`.sh`), and more.

*To add or remove extensions, edit the `SOURCE_EXTENSIONS` set in `extensions.py`.*

### Ignore Patterns

Files and directories are automatically ignored based on three levels:

1. **Built-in Patterns:** Defined in the `IGNORE_PATTERNS` set in `extensions.py` (e.g., build outputs, dependency directories, IDE files, binary/media files).
2. **Project’s `.gitignore`:** If a `.gitignore` is present at the root of your project, CodeSmelt honors its rules.
3. **Directory-specific Rules:** Additional `.gitignore` files in subdirectories will also be considered.

*To customize, modify the `IGNORE_PATTERNS` in `extensions.py`.*

Example of adding Unity3D-specific ignores:

```python
IGNORE_PATTERNS = {
    # ... existing patterns ...
    'Assets/AssetStoreTools/*',
    'Library/*',
    'Temp/*',
    'Logs/*',
    '*.unity',  # Unity scene files
    '*.meta',   # Unity meta files
    '*.prefab', # Unity prefab files
    # ... other patterns ...
}
```

---

## Tips for Using with LLMs

1. **Token Management:**
   - For very large projects, consider concatenating only specific directories to avoid token limits.
   - Use debug mode (`-d`) to verify which files are included/excluded.

2. **Effective Prompting:**
   - Reference files using their relative paths as shown in the generated directory structure.
   - Ask questions about specific sections of the output using the file headers.

3. **Best Practices:**
   - Always review the concatenated output before sending it to an LLM.
   - For large projects, consider breaking down the analysis into smaller, manageable components.

---

## Troubleshooting

### Common Issues

1. **No Files Found:**
   - Double-check the project path.
   - Ensure your project contains files with supported extensions.
   - Run with `--debug` to see detailed file filtering information.

2. **Missing Dependencies:**
   - Make sure you have installed all required packages by running:
     
     ```bash
     pip install -r requirements.txt
     ```

3. **Permission Issues:**
   - Make sure you have read permissions for the project directory and write permissions for the output file.

---

## Contributing

Contributions are welcome! If you have ideas for improvements, bug fixes, or additional features, please fork the repository and submit a pull request. For major changes, please open an issue first to discuss what you would like to change.

---

## License

This project is licensed under the [MIT License](LICENSE).

---

## Author

**Shiraz Akmal**

Feel free to reach out if you have any questions or feedback!

---

Happy coding with CodeSmelt!

# File: codesmelt.py
================================================================================

#!/usr/bin/env python3
"""
CodeSmelt: Source Code Concatenator

This tool melts down source code files from a git project into a single file,
including directory structure information.
"""

import argparse
import sys
from pathlib import Path
import os
from typing import Set, List, Optional
import fnmatch
from datetime import datetime
import gitignore_parser
from extensions import SOURCE_EXTENSIONS, IGNORE_PATTERNS

class CodeSmelt:
    def __init__(self, project_path: str, output_file: str):
        self.project_path = Path(project_path).resolve()
        self.output_file = Path(output_file)
        self.gitignore_matcher = self._setup_gitignore()
        self.debug = False
        self.include_structure = True

    def _setup_gitignore(self) -> Optional[callable]:
        """Setup gitignore matcher if .gitignore exists"""
        gitignore_path = self.project_path / '.gitignore'
        if gitignore_path.exists():
            try:
                return gitignore_parser.parse_gitignore(gitignore_path)
            except Exception as e:
                print(f"Warning: Failed to parse .gitignore: {e}")
        return None

    def _should_include_file(self, file_path: Path) -> bool:
        """Check if file should be included based on extension and ignore rules"""
        # Skip common virtual environment and system directories
        excluded_dirs = {
            '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
            '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
            'dist', 'build', 'target'
        }

        try:
            # Convert to relative path for checking
            try:
                rel_path = file_path.relative_to(self.project_path)
            except ValueError:
                if self.debug:
                    print(f"Debug: Skipping file outside project path: {file_path}")
                return False

            # Check for excluded directories in the path
            if any(part in excluded_dirs for part in file_path.parts):
                if self.debug:
                    print(f"Debug: Skipping excluded directory: {file_path}")
                return False

            # Check if file extension is in whitelist
            if file_path.suffix.lower() not in SOURCE_EXTENSIONS:
                if self.debug:
                    print(f"Debug: Skipping non-source file: {file_path}")
                return False

            # Check custom ignore patterns
            for pattern in IGNORE_PATTERNS:
                if fnmatch.fnmatch(str(rel_path), pattern):
                    if self.debug:
                        print(f"Debug: Skipping ignored pattern {pattern}: {file_path}")
                    return False

            # Check .gitignore if available
            if self.gitignore_matcher:
                try:
                    should_include = not self.gitignore_matcher(str(file_path))
                    if self.debug and not should_include:
                        print(f"Debug: Skipping gitignored file: {file_path}")
                    return should_include
                except Exception as e:
                    print(f"Warning: gitignore matching failed for {file_path}: {e}")
                    return True

            if self.debug:
                print(f"Debug: Including file: {file_path}")
            return True

        except Exception as e:
            print(f"Warning: Error checking file {file_path}: {e}")
            return False

    def _get_file_content(self, file_path: Path) -> str:
        """Read file content with proper encoding handling"""
        try:
            # Try UTF-8 first
            with open(file_path, 'r', encoding='utf-8') as f:
                return f.read()
        except UnicodeDecodeError:
            try:
                # Fallback to latin-1
                with open(file_path, 'r', encoding='latin-1') as f:
                    return f.read()
            except Exception as e:
                print(f"Warning: Failed to read {file_path}: {e}")
                return f"ERROR: Could not read file {file_path}\n"

    def _generate_directory_structure(self) -> str:
        """Generate a tree-like directory structure"""
        structure = ["Directory Structure:", ""]

        def add_to_tree(path: Path, prefix: str = ""):
            # Skip excluded directories
            excluded_dirs = {
                '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
                '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
                'dist', 'build', 'target'
            }
            if path.name in excluded_dirs:
                return

            # Add files first
            files = sorted([p for p in path.iterdir() if p.is_file()])
            included_files = [f for f in files if self._should_include_file(f)]

            for idx, file in enumerate(included_files):
                is_last = idx == len(included_files) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {file.name}")

            # Then add directories
            dirs = sorted([p for p in path.iterdir() if p.is_dir()])
            included_dirs = [d for d in dirs if d.name not in excluded_dirs]

            for idx, dir in enumerate(included_dirs):
                is_last = idx == len(included_dirs) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {dir.name}/")
                add_to_tree(dir, prefix + ("    " if is_last else "│   "))

        add_to_tree(self.project_path)
        return "\n".join(structure)

    def concatenate(self, debug: bool = False):
        """Main method to concatenate all source files"""
        self.debug = debug
        if not self.project_path.exists():
            print(f"Error: Project path {self.project_path} does not exist")
            return False

        try:
            with open(self.output_file, 'w', encoding='utf-8') as out:
                # Write header
                header = f"""
# Project Source Code Concatenation
# Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
# Project path: {self.project_path}

"""
                out.write(header)

                # Write directory structure if enabled
                if self.include_structure:
                    out.write(self._generate_directory_structure())
                    out.write("\n\n" + "="*80 + "\n\n")

                # Process all files
                file_count = 0
                for file_path in self.project_path.rglob('*'):
                    if file_path.is_file() and self._should_include_file(file_path):
                        rel_path = file_path.relative_to(self.project_path)

                        # Write file header
                        out.write(f"\n\n# File: {rel_path}\n")
                        out.write("="*80 + "\n\n")

                        # Write file content
                        content = self._get_file_content(file_path)
                        out.write(content)
                        file_count += 1

                print(f"Successfully melted {file_count} files to {self.output_file}")
                return True

        except Exception as e:
            print(f"Error during melting: {e}")
            return False

def main():
    parser = argparse.ArgumentParser(
        description="CodeSmelt: Melt down your git project's source code into a single file",
        usage="%(prog)s project_path [output_file] [-o OUTPUT] [-d] [-n]"
    )

    # Add the project path as required positional argument
    parser.add_argument(
        "project_path",
        help="Path to the git project directory"
    )

    # Add optional positional argument for output file
    parser.add_argument(
        "output_file",
        nargs="?",  # Make it optional
        help="Output file path (alternative to -o)",
        default=None
    )

    # Keep the original -o option for backward compatibility
    parser.add_argument(
        "-o", "--output",
        help="Output file path (default: concatenated_source.txt)",
        default=None
    )

    parser.add_argument(
        "-d", "--debug",
        action="store_true",
        help="Enable debug logging"
    )

    parser.add_argument(
        "-n", "--no-structure",
        action="store_true",
        help="Omit directory structure from output"
    )

    args = parser.parse_args()

    # Determine the output file path, prioritizing command line arguments
    output_file = args.output or args.output_file or "concatenated_source.txt"

    concatenator = CodeSmelt(args.project_path, output_file)
    concatenator.include_structure = not args.no_structure
    success = concatenator.concatenate(debug=args.debug)
    sys.exit(0 if success else 1)

if __name__ == "__main__":
    main()

# File: test_with_structure.txt
================================================================================


# Project Source Code Concatenation
# Generated on: 2025-02-15 23:26:14
# Project path: /home/runner/workspace

Directory Structure:

├── README.md
├── codesmelt.py
├── extensions.py
├── pyproject.toml
├── requirements.txt
└── test_with_structure.txt
└── assets/

================================================================================



# File: extensions.py
================================================================================

"""
Source code file extension configurations
"""

# Common source code file extensions
SOURCE_EXTENSIONS = {
    # Web
    '.js', '.ts', '.jsx', '.tsx', '.vue', '.svelte',
    '.html', '.htm', '.css', '.scss', '.sass', '.less',
    
    # Python
    '.py', '.pyi', '.pyx',
    
    # Java/Kotlin
    '.java', '.kt', '.groovy',
    
    # C-family
    '.c', '.cpp', '.h', '.hpp', '.cc',
    
    # C#
    '.cs', '.cshtml', '.csx',
    
    # Ruby
    '.rb', '.erb',
    
    # PHP
    '.php', '.php5', '.phtml',
    
    # Go
    '.go',
    
    # Rust
    '.rs',
    
    # Swift
    '.swift',
    
    # Shell
    '.sh', '.bash', '.zsh',
    
    # Config/Data
    '.json', '.yaml', '.yml', '.toml', '.xml',
    '.conf', '.ini', '.env',
    
    # Documentation
    '.md', '.rst', '.txt'
}

# Files to always ignore
IGNORE_PATTERNS = {
    # Build outputs
    'build/*', 'dist/*', 'target/*', 'bin/*',
    '*.pyc', '__pycache__/*', '*.class',
    
    # Dependencies
    'node_modules/*', 'vendor/*', 'venv/*',
    
    # IDE files
    '.idea/*', '.vscode/*', '*.swp',
    
    # Package files
    'package-lock.json', 'yarn.lock',
    'Pipfile.lock', 'poetry.lock',
    
    # Large data files
    '*.csv', '*.json.gz', '*.sql',
    
    # Binary/Media files
    '*.pdf', '*.jpg', '*.png', '*.gif',
    '*.mp3', '*.mp4', '*.mov', '*.bin',
    '*.exe', '*.dll', '*.so', '*.dylib'
}


# File: pyproject.toml
================================================================================

[project]
name = "repl-nix-workspace"
version = "0.1.0"
description = "Add your description here"
requires-python = ">=3.11"
dependencies = [
    "gitignore-parser>=0.1.11",
]


# File: requirements.txt
================================================================================

gitignore_parser==0.1.11

# File: README.md
================================================================================

# CodeSmelt: Source Code Concatenator

![CodeSmelt Logo](assets/CodeSmeltLogo.jpg)

**CodeSmelt** is a command-line tool that “melts down” your Git project’s source code into a single, well-organized file. It not only concatenates source files but also embeds a tree-like directory structure to help you quickly understand your project’s layout. This is especially useful for code analysis, preparing inputs for language models, or sharing project snapshots.

---

## Table of Contents

- [Features](#features)
- [Installation](#installation)
- [Usage](#usage)
  - [Basic Usage](#basic-usage)
  - [Custom Output & Debug Mode](#custom-output--debug-mode)
- [Configuration](#configuration)
  - [Source File Extensions](#source-file-extensions)
  - [Ignore Patterns](#ignore-patterns)
- [Tips for Using with LLMs](#tips-for-using-with-llms)
- [Troubleshooting](#troubleshooting)
- [Contributing](#contributing)
- [License](#license)
- [Author](#author)

---

## Features

- **Concatenation with Context:** Combines all source files (with supported extensions) into one file while preserving directory hierarchy.
- **Smart Filtering:** Uses built-in file extension whitelists and ignore patterns. Also honors your project’s `.gitignore` for extra filtering.
- **Encoding Handling:** Automatically handles file encoding issues (tries UTF-8 first, then falls back to Latin-1).
- **Debug Logging:** Option to enable debug logging so you can see which files are being included or skipped.
- **Easy Customization:** Adjust supported file extensions and ignore patterns via the `extensions.py` file.

---

## Installation

1. **Clone the Repository:**

   ```bash
   git clone https://github.com/yourusername/codesmelt.git
   cd codesmelt
   ```

2. **Install Dependencies:**

   CodeSmelt requires Python 3. Instead of installing dependencies individually, you can install all required packages using the `requirements.txt` file:

   ```bash
   pip install -r requirements.txt
   ```

   *(If you use a virtual environment, activate it before installing.)*

3. **Ensure File Structure:**

   Make sure the following files are in the same directory:
   
   - `codesmelt.py`
   - `extensions.py`
   - `README.md`
   - `requirements.txt`
   - `assets/CodeSmeltLogo.jpg` (logo image)

---

## Usage

### Basic Usage

Run CodeSmelt by providing the path to your Git project. For example:

```bash
python codesmelt.py /path/to/project
```

### Custom Output & Debug Mode

- **Specify a Custom Output File:**

  ```bash
  python codesmelt.py -o output.txt /path/to/project
  ```

- **Enable Debug Logging:**

  ```bash
  python codesmelt.py -d -o output.txt /path/to/project
  ```

#### Command-line Arguments

- `project_path` (required): Path to your Git project directory.
- `-o, --output`: Specify the output file path (default: `concatenated_source.txt`).
- `-d, --debug`: Enable debug logging to get detailed information about file selection.

---

## Configuration

CodeSmelt uses the `extensions.py` file to define:

### Source File Extensions

The tool automatically includes many common source code file extensions. Examples include:

- **Web:** `.js`, `.ts`, `.jsx`, `.tsx`, `.vue`, `.svelte`, `.html`, `.css`, etc.
- **Python:** `.py`, `.pyi`, `.pyx`
- **Java/Kotlin:** `.java`, `.kt`, `.groovy`
- **C-family:** `.c`, `.cpp`, `.h`, `.hpp`
- **Other Languages:** Ruby (`.rb`), PHP (`.php`), Go (`.go`), Rust (`.rs`), Swift (`.swift`), Shell (`.sh`), and more.

*To add or remove extensions, edit the `SOURCE_EXTENSIONS` set in `extensions.py`.*

### Ignore Patterns

Files and directories are automatically ignored based on three levels:

1. **Built-in Patterns:** Defined in the `IGNORE_PATTERNS` set in `extensions.py` (e.g., build outputs, dependency directories, IDE files, binary/media files).
2. **Project’s `.gitignore`:** If a `.gitignore` is present at the root of your project, CodeSmelt honors its rules.
3. **Directory-specific Rules:** Additional `.gitignore` files in subdirectories will also be considered.

*To customize, modify the `IGNORE_PATTERNS` in `extensions.py`.*

Example of adding Unity3D-specific ignores:

```python
IGNORE_PATTERNS = {
    # ... existing patterns ...
    'Assets/AssetStoreTools/*',
    'Library/*',
    'Temp/*',
    'Logs/*',
    '*.unity',  # Unity scene files
    '*.meta',   # Unity meta files
    '*.prefab', # Unity prefab files
    # ... other patterns ...
}
```

---

## Tips for Using with LLMs

1. **Token Management:**
   - For very large projects, consider concatenating only specific directories to avoid token limits.
   - Use debug mode (`-d`) to verify which files are included/excluded.

2. **Effective Prompting:**
   - Reference files using their relative paths as shown in the generated directory structure.
   - Ask questions about specific sections of the output using the file headers.

3. **Best Practices:**
   - Always review the concatenated output before sending it to an LLM.
   - For large projects, consider breaking down the analysis into smaller, manageable components.

---

## Troubleshooting

### Common Issues

1. **No Files Found:**
   - Double-check the project path.
   - Ensure your project contains files with supported extensions.
   - Run with `--debug` to see detailed file filtering information.

2. **Missing Dependencies:**
   - Make sure you have installed all required packages by running:
     
     ```bash
     pip install -r requirements.txt
     ```

3. **Permission Issues:**
   - Make sure you have read permissions for the project directory and write permissions for the output file.

---

## Contributing

Contributions are welcome! If you have ideas for improvements, bug fixes, or additional features, please fork the repository and submit a pull request. For major changes, please open an issue first to discuss what you would like to change.

---

## License

This project is licensed under the [MIT License](LICENSE).

---

## Author

**Shiraz Akmal**

Feel free to reach out if you have any questions or feedback!

---

Happy coding with CodeSmelt!

# File: codesmelt.py
================================================================================

#!/usr/bin/env python3
"""
CodeSmelt: Source Code Concatenator

This tool melts down source code files from a git project into a single file,
including directory structure information.
"""

import argparse
import sys
from pathlib import Path
import os
from typing import Set, List, Optional
import fnmatch
from datetime import datetime
import gitignore_parser
from extensions import SOURCE_EXTENSIONS, IGNORE_PATTERNS

class CodeSmelt:
    def __init__(self, project_path: str, output_file: str):
        self.project_path = Path(project_path).resolve()
        self.output_file = Path(output_file)
        self.gitignore_matcher = self._setup_gitignore()
        self.debug = False
        self.include_structure = True

    def _setup_gitignore(self) -> Optional[callable]:
        """Setup gitignore matcher if .gitignore exists"""
        gitignore_path = self.project_path / '.gitignore'
        if gitignore_path.exists():
            try:
                return gitignore_parser.parse_gitignore(gitignore_path)
            except Exception as e:
                print(f"Warning: Failed to parse .gitignore: {e}")
        return None

    def _should_include_file(self, file_path: Path) -> bool:
        """Check if file should be included based on extension and ignore rules"""
        # Skip common virtual environment and system directories
        excluded_dirs = {
            '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
            '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
            'dist', 'build', 'target'
        }

        try:
            # Convert to relative path for checking
            try:
                rel_path = file_path.relative_to(self.project_path)
            except ValueError:
                if self.debug:
                    print(f"Debug: Skipping file outside project path: {file_path}")
                return False

            # Check for excluded directories in the path
            if any(part in excluded_dirs for part in file_path.parts):
                if self.debug:
                    print(f"Debug: Skipping excluded directory: {file_path}")
                return False

            # Check if file extension is in whitelist
            if file_path.suffix.lower() not in SOURCE_EXTENSIONS:
                if self.debug:
                    print(f"Debug: Skipping non-source file: {file_path}")
                return False

            # Check custom ignore patterns
            for pattern in IGNORE_PATTERNS:
                if fnmatch.fnmatch(str(rel_path), pattern):
                    if self.debug:
                        print(f"Debug: Skipping ignored pattern {pattern}: {file_path}")
                    return False

            # Check .gitignore if available
            if self.gitignore_matcher:
                try:
                    should_include = not self.gitignore_matcher(str(file_path))
                    if self.debug and not should_include:
                        print(f"Debug: Skipping gitignored file: {file_path}")
                    return should_include
                except Exception as e:
                    print(f"Warning: gitignore matching failed for {file_path}: {e}")
                    return True

            if self.debug:
                print(f"Debug: Including file: {file_path}")
            return True

        except Exception as e:
            print(f"Warning: Error checking file {file_path}: {e}")
            return False

    def _get_file_content(self, file_path: Path) -> str:
        """Read file content with proper encoding handling"""
        try:
            # Try UTF-8 first
            with open(file_path, 'r', encoding='utf-8') as f:
                return f.read()
        except UnicodeDecodeError:
            try:
                # Fallback to latin-1
                with open(file_path, 'r', encoding='latin-1') as f:
                    return f.read()
            except Exception as e:
                print(f"Warning: Failed to read {file_path}: {e}")
                return f"ERROR: Could not read file {file_path}\n"

    def _generate_directory_structure(self) -> str:
        """Generate a tree-like directory structure"""
        structure = ["Directory Structure:", ""]

        def add_to_tree(path: Path, prefix: str = ""):
            # Skip excluded directories
            excluded_dirs = {
                '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
                '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
                'dist', 'build', 'target'
            }
            if path.name in excluded_dirs:
                return

            # Add files first
            files = sorted([p for p in path.iterdir() if p.is_file()])
            included_files = [f for f in files if self._should_include_file(f)]

            for idx, file in enumerate(included_files):
                is_last = idx == len(included_files) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {file.name}")

            # Then add directories
            dirs = sorted([p for p in path.iterdir() if p.is_dir()])
            included_dirs = [d for d in dirs if d.name not in excluded_dirs]

            for idx, dir in enumerate(included_dirs):
                is_last = idx == len(included_dirs) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {dir.name}/")
                add_to_tree(dir, prefix + ("    " if is_last else "│   "))

        add_to_tree(self.project_path)
        return "\n".join(structure)

    def concatenate(self, debug: bool = False):
        """Main method to concatenate all source files"""
        self.debug = debug
        if not self.project_path.exists():
            print(f"Error: Project path {self.project_path} does not exist")
            return False

        try:
            with open(self.output_file, 'w', encoding='utf-8') as out:
                # Write header
                header = f"""
# Project Source Code Concatenation
# Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
# Project path: {self.project_path}

"""
                out.write(header)

                # Write directory structure if enabled
                if self.include_structure:
                    out.write(self._generate_directory_structure())
                    out.write("\n\n" + "="*80 + "\n\n")

                # Process all files
                file_count = 0
                for file_path in self.project_path.rglob('*'):
                    if file_path.is_file() and self._should_include_file(file_path):
                        rel_path = file_path.relative_to(self.project_path)

                        # Write file header
                        out.write(f"\n\n# File: {rel_path}\n")
                        out.write("="*80 + "\n\n")

                        # Write file content
                        content = self._get_file_content(file_path)
                        out.write(content)
                        file_count += 1

                print(f"Successfully melted {file_count} files to {self.output_file}")
                return True

        except Exception as e:
            print(f"Error during melting: {e}")
            return False

def main():
    parser = argparse.ArgumentParser(
        description="CodeSmelt: Melt down your git project's source code into a single file",
        usage="%(prog)s project_path [output_file] [-o OUTPUT] [-d] [-n]"
    )

    # Add the project path as required positional argument
    parser.add_argument(
        "project_path",
        help="Path to the git project directory"
    )

    # Add optional positional argument for output file
    parser.add_argument(
        "output_file",
        nargs="?",  # Make it optional
        help="Output file path (alternative to -o)",
        default=None
    )

    # Keep the original -o option for backward compatibility
    parser.add_argument(
        "-o", "--output",
        help="Output file path (default: concatenated_source.txt)",
        default=None
    )

    parser.add_argument(
        "-d", "--debug",
        action="store_true",
        help="Enable debug logging"
    )

    parser.add_argument(
        "-n", "--no-structure",
        action="store_true",
        help="Omit directory structure from output"
    )

    args = parser.parse_args()

    # Determine the output file path, prioritizing command line arguments
    output_file = args.output or args.output_file or "concatenated_source.txt"

    concatenator = CodeSmelt(args.project_path, output_file)
    concatenator.include_structure = not args.no_structure
    success = concatenator.concatenate(debug=args.debug)
    sys.exit(0 if success else 1)

if __name__ == "__main__":
    main()

# File: README.md
================================================================================

2. **Install Dependencies:**

   CodeSmelt requires Python 3. Instead of installing dependencies individually, you can install all required packages using the `requirements.txt` file:

   ```bash
   pip install -r requirements.txt
   ```

   *(If you use a virtual environment, activate it before installing.)*

3. **Ensure File Structure:**

   Make sure the following files are in the same directory:
   
   - `codesmelt.py`
   - `extensions.py`
   - `README.md`
   - `requirements.txt`
   - `assets/CodeSmeltLogo.jpg` (logo image)

---

## Usage

### Basic Usage

Run CodeSmelt by providing the path to your Git project. For example:

```bash
python codesmelt.py /path/to/project
```

### Custom Output & Debug Mode

- **Specify a Custom Output File:**

  ```bash
  python codesmelt.py -o output.txt /path/to/project
  ```

- **Enable Debug Logging:**

  ```bash
  python codesmelt.py -d -o output.txt /path/to/project
  ```

- **Omit Directory Structure:**

  ```bash
  python codesmelt.py -n -o output.txt /path/to/project
  ```

#### Command-line Arguments

- `project_path` (required): Path to your Git project directory.
- `-o, --output`: Specify the output file path (default: `concatenated_source.txt`).
- `-d, --debug`: Enable debug logging to get detailed information about file selection.
- `-n, --no-structure`: Omit the directory structure from the output file.


---

## Configuration

CodeSmelt uses the `extensions.py` file to define:

### Source File Extensions

The tool automatically includes many common source code file extensions. Examples include:

- **Web:** `.js`, `.ts`, `.jsx`, `.tsx`, `.vue`, `.svelte`, `.html`, `.css`, etc.
- **Python:** `.py`, `.pyi`, `.pyx`
- **Java/Kotlin:** `.java`, `.kt`, `.groovy`
- **C-family:** `.c`, `.cpp`, `.h`, `.hpp`
- **Other Languages:** Ruby (`.rb`), PHP (`.php`), Go (`.go`), Rust (`.rs`), Swift (`.swift`), Shell (`.sh`), and more.

*To add or remove extensions, edit the `SOURCE_EXTENSIONS` set in `extensions.py`.*

### Ignore Patterns

Files and directories are automatically ignored based on three levels:

1. **Built-in Patterns:** Defined in the `IGNORE_PATTERNS` set in `extensions.py` (e.g., build outputs, dependency directories, IDE files, binary/media files).
2. **Project’s `.gitignore`:** If a `.gitignore` is present at the root of your project, CodeSmelt honors its rules.
3. **Directory-specific Rules:** Additional `.gitignore` files in subdirectories will also be considered.

*To customize, modify the `IGNORE_PATTERNS` in `extensions.py`.*

Example of adding Unity3D-specific ignores:

```python
IGNORE_PATTERNS = {
    # ... existing patterns ...
    'Assets/AssetStoreTools/*',
    'Library/*',
    'Temp/*',
    'Logs/*',
    '*.unity',  # Unity scene files
    '*.meta',   # Unity meta files
    '*.prefab', # Unity prefab files
    # ... other patterns ...
}
```

---

## Tips for Using with LLMs

1. **Token Management:**
   - For very large projects, consider concatenating only specific directories to avoid token limits.
   - Use debug mode (`-d`) to verify which files are included/excluded.

2. **Effective Prompting:**
   - Reference files using their relative paths as shown in the generated directory structure.
   - Ask questions about specific sections of the output using the file headers.

3. **Best Practices:**
   - Always review the concatenated output before sending it to an LLM.
   - For large projects, consider breaking down the analysis into smaller, manageable components.

---

## Troubleshooting

### Common Issues

1. **No Files Found:**
   - Double-check the project path.
   - Ensure your project contains files with supported extensions.
   - Run with `--debug` to see detailed file filtering information.

2. **Missing Dependencies:**
   - Make sure you have installed all required packages by running:
     
     ```bash
     pip install -r requirements.txt

# File: test_output.txt
================================================================================


# Project Source Code Concatenation
# Generated on: 2025-02-15 23:27:30
# Project path: /home/runner/workspace



# File: extensions.py
================================================================================

"""
Source code file extension configurations
"""

# Common source code file extensions
SOURCE_EXTENSIONS = {
    # Web
    '.js', '.ts', '.jsx', '.tsx', '.vue', '.svelte',
    '.html', '.htm', '.css', '.scss', '.sass', '.less',
    
    # Python
    '.py', '.pyi', '.pyx',
    
    # Java/Kotlin
    '.java', '.kt', '.groovy',
    
    # C-family
    '.c', '.cpp', '.h', '.hpp', '.cc',
    
    # C#
    '.cs', '.cshtml', '.csx',
    
    # Ruby
    '.rb', '.erb',
    
    # PHP
    '.php', '.php5', '.phtml',
    
    # Go
    '.go',
    
    # Rust
    '.rs',
    
    # Swift
    '.swift',
    
    # Shell
    '.sh', '.bash', '.zsh',
    
    # Config/Data
    '.json', '.yaml', '.yml', '.toml', '.xml',
    '.conf', '.ini', '.env',
    
    # Documentation
    '.md', '.rst', '.txt'
}

# Files to always ignore
IGNORE_PATTERNS = {
    # Build outputs
    'build/*', 'dist/*', 'target/*', 'bin/*',
    '*.pyc', '__pycache__/*', '*.class',
    
    # Dependencies
    'node_modules/*', 'vendor/*', 'venv/*',
    
    # IDE files
    '.idea/*', '.vscode/*', '*.swp',
    
    # Package files
    'package-lock.json', 'yarn.lock',
    'Pipfile.lock', 'poetry.lock',
    
    # Large data files
    '*.csv', '*.json.gz', '*.sql',
    
    # Binary/Media files
    '*.pdf', '*.jpg', '*.png', '*.gif',
    '*.mp3', '*.mp4', '*.mov', '*.bin',
    '*.exe', '*.dll', '*.so', '*.dylib'
}


# File: pyproject.toml
================================================================================

[project]
name = "repl-nix-workspace"
version = "0.1.0"
description = "Add your description here"
requires-python = ">=3.11"
dependencies = [
    "gitignore-parser>=0.1.11",
]


# File: requirements.txt
================================================================================

gitignore_parser==0.1.11

# File: codesmelt.py
================================================================================

#!/usr/bin/env python3
"""
CodeSmelt: Source Code Concatenator

This tool melts down source code files from a git project into a single file,
including directory structure information.
"""

import argparse
import sys
from pathlib import Path
import os
from typing import Set, List, Optional
import fnmatch
from datetime import datetime
import gitignore_parser
from extensions import SOURCE_EXTENSIONS, IGNORE_PATTERNS

class CodeSmelt:
    def __init__(self, project_path: str, output_file: str):
        self.project_path = Path(project_path).resolve()
        self.output_file = Path(output_file)
        self.gitignore_matcher = self._setup_gitignore()
        self.debug = False
        self.include_structure = True

    def _setup_gitignore(self) -> Optional[callable]:
        """Setup gitignore matcher if .gitignore exists"""
        gitignore_path = self.project_path / '.gitignore'
        if gitignore_path.exists():
            try:
                return gitignore_parser.parse_gitignore(gitignore_path)
            except Exception as e:
                print(f"Warning: Failed to parse .gitignore: {e}")
        return None

    def _should_include_file(self, file_path: Path) -> bool:
        """Check if file should be included based on extension and ignore rules"""
        # Skip common virtual environment and system directories
        excluded_dirs = {
            '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
            '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
            'dist', 'build', 'target'
        }

        try:
            # Convert to relative path for checking
            try:
                rel_path = file_path.relative_to(self.project_path)
            except ValueError:
                if self.debug:
                    print(f"Debug: Skipping file outside project path: {file_path}")
                return False

            # Check for excluded directories in the path
            if any(part in excluded_dirs for part in file_path.parts):
                if self.debug:
                    print(f"Debug: Skipping excluded directory: {file_path}")
                return False

            # Check if file extension is in whitelist
            if file_path.suffix.lower() not in SOURCE_EXTENSIONS:
                if self.debug:
                    print(f"Debug: Skipping non-source file: {file_path}")
                return False

            # Check custom ignore patterns
            for pattern in IGNORE_PATTERNS:
                if fnmatch.fnmatch(str(rel_path), pattern):
                    if self.debug:
                        print(f"Debug: Skipping ignored pattern {pattern}: {file_path}")
                    return False

            # Check .gitignore if available
            if self.gitignore_matcher:
                try:
                    should_include = not self.gitignore_matcher(str(file_path))
                    if self.debug and not should_include:
                        print(f"Debug: Skipping gitignored file: {file_path}")
                    return should_include
                except Exception as e:
                    print(f"Warning: gitignore matching failed for {file_path}: {e}")
                    return True

            if self.debug:
                print(f"Debug: Including file: {file_path}")
            return True

        except Exception as e:
            print(f"Warning: Error checking file {file_path}: {e}")
            return False

    def _get_file_content(self, file_path: Path) -> str:
        """Read file content with proper encoding handling"""
        try:
            # Try UTF-8 first
            with open(file_path, 'r', encoding='utf-8') as f:
                return f.read()
        except UnicodeDecodeError:
            try:
                # Fallback to latin-1
                with open(file_path, 'r', encoding='latin-1') as f:
                    return f.read()
            except Exception as e:
                print(f"Warning: Failed to read {file_path}: {e}")
                return f"ERROR: Could not read file {file_path}\n"

    def _generate_directory_structure(self) -> str:
        """Generate a tree-like directory structure"""
        structure = ["Directory Structure:", ""]

        def add_to_tree(path: Path, prefix: str = ""):
            # Skip excluded directories
            excluded_dirs = {
                '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
                '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
                'dist', 'build', 'target'
            }
            if path.name in excluded_dirs:
                return

            # Add files first
            files = sorted([p for p in path.iterdir() if p.is_file()])
            included_files = [f for f in files if self._should_include_file(f)]

            for idx, file in enumerate(included_files):
                is_last = idx == len(included_files) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {file.name}")

            # Then add directories
            dirs = sorted([p for p in path.iterdir() if p.is_dir()])
            included_dirs = [d for d in dirs if d.name not in excluded_dirs]

            for idx, dir in enumerate(included_dirs):
                is_last = idx == len(included_dirs) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {dir.name}/")
                add_to_tree(dir, prefix + ("    " if is_last else "│   "))

        add_to_tree(self.project_path)
        return "\n".join(structure)

    def concatenate(self, debug: bool = False):
        """Main method to concatenate all source files"""
        self.debug = debug
        if not self.project_path.exists():
            print(f"Error: Project path {self.project_path} does not exist")
            return False

        try:
            with open(self.output_file, 'w', encoding='utf-8') as out:
                # Write header
                header = f"""
# Project Source Code Concatenation
# Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
# Project path: {self.project_path}

"""
                out.write(header)

                # Write directory structure if enabled
                if self.include_structure:
                    out.write(self._generate_directory_structure())
                    out.write("\n\n" + "="*80 + "\n\n")

                # Process all files
                file_count = 0
                for file_path in self.project_path.rglob('*'):
                    if file_path.is_file() and self._should_include_file(file_path):
                        rel_path = file_path.relative_to(self.project_path)

                        # Write file header
                        out.write(f"\n\n# File: {rel_path}\n")
                        out.write("="*80 + "\n\n")

                        # Write file content
                        content = self._get_file_content(file_path)
                        out.write(content)
                        file_count += 1

                print(f"Successfully melted {file_count} files to {self.output_file}")
                return True

        except Exception as e:
            print(f"Error during melting: {e}")
            return False

def main():
    parser = argparse.ArgumentParser(
        description="CodeSmelt: Melt down your git project's source code into a single file",
        usage="%(prog)s project_path [output_file] [-o OUTPUT] [-d] [-n]"
    )

    # Add the project path as required positional argument
    parser.add_argument(
        "project_path",
        help="Path to the git project directory"
    )

    # Add optional positional argument for output file
    parser.add_argument(
        "output_file",
        nargs="?",  # Make it optional
        help="Output file path (alternative to -o)",
        default=None
    )

    # Keep the original -o option for backward compatibility
    parser.add_argument(
        "-o", "--output",
        help="Output file path (default: concatenated_source.txt)",
        default=None
    )

    parser.add_argument(
        "-d", "--debug",
        action="store_true",
        help="Enable debug logging"
    )

    parser.add_argument(
        "-n", "--no-structure",
        action="store_true",
        help="Omit directory structure from output"
    )

    args = parser.parse_args()

    # Determine the output file path, prioritizing command line arguments
    output_file = args.output or args.output_file or "concatenated_source.txt"

    concatenator = CodeSmelt(args.project_path, output_file)
    concatenator.include_structure = not args.no_structure
    success = concatenator.concatenate(debug=args.debug)
    sys.exit(0 if success else 1)

if __name__ == "__main__":
    main()

# File: test_with_structure.txt
================================================================================


# Project Source Code Concatenation
# Generated on: 2025-02-15 23:26:14
# Project path: /home/runner/workspace

Directory Structure:

├── README.md
├── codesmelt.py
├── extensions.py
├── pyproject.toml
├── requirements.txt
└── test_with_structure.txt
└── assets/

================================================================================



# File: extensions.py
================================================================================

"""
Source code file extension configurations
"""

# Common source code file extensions
SOURCE_EXTENSIONS = {
    # Web
    '.js', '.ts', '.jsx', '.tsx', '.vue', '.svelte',
    '.html', '.htm', '.css', '.scss', '.sass', '.less',
    
    # Python
    '.py', '.pyi', '.pyx',
    
    # Java/Kotlin
    '.java', '.kt', '.groovy',
    
    # C-family
    '.c', '.cpp', '.h', '.hpp', '.cc',
    
    # C#
    '.cs', '.cshtml', '.csx',
    
    # Ruby
    '.rb', '.erb',
    
    # PHP
    '.php', '.php5', '.phtml',
    
    # Go
    '.go',
    
    # Rust
    '.rs',
    
    # Swift
    '.swift',
    
    # Shell
    '.sh', '.bash', '.zsh',
    
    # Config/Data
    '.json', '.yaml', '.yml', '.toml', '.xml',
    '.conf', '.ini', '.env',
    
    # Documentation
    '.md', '.rst', '.txt'
}

# Files to always ignore
IGNORE_PATTERNS = {
    # Build outputs
    'build/*', 'dist/*', 'target/*', 'bin/*',
    '*.pyc', '__pycache__/*', '*.class',
    
    # Dependencies
    'node_modules/*', 'vendor/*', 'venv/*',
    
    # IDE files
    '.idea/*', '.vscode/*', '*.swp',
    
    # Package files
    'package-lock.json', 'yarn.lock',
    'Pipfile.lock', 'poetry.lock',
    
    # Large data files
    '*.csv', '*.json.gz', '*.sql',
    
    # Binary/Media files
    '*.pdf', '*.jpg', '*.png', '*.gif',
    '*.mp3', '*.mp4', '*.mov', '*.bin',
    '*.exe', '*.dll', '*.so', '*.dylib'
}


# File: pyproject.toml
================================================================================

[project]
name = "repl-nix-workspace"
version = "0.1.0"
description = "Add your description here"
requires-python = ">=3.11"
dependencies = [
    "gitignore-parser>=0.1.11",
]


# File: requirements.txt
================================================================================

gitignore_parser==0.1.11

# File: README.md
================================================================================

# CodeSmelt: Source Code Concatenator

![CodeSmelt Logo](assets/CodeSmeltLogo.jpg)

**CodeSmelt** is a command-line tool that “melts down” your Git project’s source code into a single, well-organized file. It not only concatenates source files but also embeds a tree-like directory structure to help you quickly understand your project’s layout. This is especially useful for code analysis, preparing inputs for language models, or sharing project snapshots.

---

## Table of Contents

- [Features](#features)
- [Installation](#installation)
- [Usage](#usage)
  - [Basic Usage](#basic-usage)
  - [Custom Output & Debug Mode](#custom-output--debug-mode)
- [Configuration](#configuration)
  - [Source File Extensions](#source-file-extensions)
  - [Ignore Patterns](#ignore-patterns)
- [Tips for Using with LLMs](#tips-for-using-with-llms)
- [Troubleshooting](#troubleshooting)
- [Contributing](#contributing)
- [License](#license)
- [Author](#author)

---

## Features

- **Concatenation with Context:** Combines all source files (with supported extensions) into one file while preserving directory hierarchy.
- **Smart Filtering:** Uses built-in file extension whitelists and ignore patterns. Also honors your project’s `.gitignore` for extra filtering.
- **Encoding Handling:** Automatically handles file encoding issues (tries UTF-8 first, then falls back to Latin-1).
- **Debug Logging:** Option to enable debug logging so you can see which files are being included or skipped.
- **Easy Customization:** Adjust supported file extensions and ignore patterns via the `extensions.py` file.

---

## Installation

1. **Clone the Repository:**

   ```bash
   git clone https://github.com/yourusername/codesmelt.git
   cd codesmelt
   ```

2. **Install Dependencies:**

   CodeSmelt requires Python 3. Instead of installing dependencies individually, you can install all required packages using the `requirements.txt` file:

   ```bash
   pip install -r requirements.txt
   ```

   *(If you use a virtual environment, activate it before installing.)*

3. **Ensure File Structure:**

   Make sure the following files are in the same directory:
   
   - `codesmelt.py`
   - `extensions.py`
   - `README.md`
   - `requirements.txt`
   - `assets/CodeSmeltLogo.jpg` (logo image)

---

## Usage

### Basic Usage

Run CodeSmelt by providing the path to your Git project. For example:

```bash
python codesmelt.py /path/to/project
```

### Custom Output & Debug Mode

- **Specify a Custom Output File:**

  ```bash
  python codesmelt.py -o output.txt /path/to/project
  ```

- **Enable Debug Logging:**

  ```bash
  python codesmelt.py -d -o output.txt /path/to/project
  ```

#### Command-line Arguments

- `project_path` (required): Path to your Git project directory.
- `-o, --output`: Specify the output file path (default: `concatenated_source.txt`).
- `-d, --debug`: Enable debug logging to get detailed information about file selection.

---

## Configuration

CodeSmelt uses the `extensions.py` file to define:

### Source File Extensions

The tool automatically includes many common source code file extensions. Examples include:

- **Web:** `.js`, `.ts`, `.jsx`, `.tsx`, `.vue`, `.svelte`, `.html`, `.css`, etc.
- **Python:** `.py`, `.pyi`, `.pyx`
- **Java/Kotlin:** `.java`, `.kt`, `.groovy`
- **C-family:** `.c`, `.cpp`, `.h`, `.hpp`
- **Other Languages:** Ruby (`.rb`), PHP (`.php`), Go (`.go`), Rust (`.rs`), Swift (`.swift`), Shell (`.sh`), and more.

*To add or remove extensions, edit the `SOURCE_EXTENSIONS` set in `extensions.py`.*

### Ignore Patterns

Files and directories are automatically ignored based on three levels:

1. **Built-in Patterns:** Defined in the `IGNORE_PATTERNS` set in `extensions.py` (e.g., build outputs, dependency directories, IDE files, binary/media files).
2. **Project’s `.gitignore`:** If a `.gitignore` is present at the root of your project, CodeSmelt honors its rules.
3. **Directory-specific Rules:** Additional `.gitignore` files in subdirectories will also be considered.

*To customize, modify the `IGNORE_PATTERNS` in `extensions.py`.*

Example of adding Unity3D-specific ignores:

```python
IGNORE_PATTERNS = {
    # ... existing patterns ...
    'Assets/AssetStoreTools/*',
    'Library/*',
    'Temp/*',
    'Logs/*',
    '*.unity',  # Unity scene files
    '*.meta',   # Unity meta files
    '*.prefab', # Unity prefab files
    # ... other patterns ...
}
```

---

## Tips for Using with LLMs

1. **Token Management:**
   - For very large projects, consider concatenating only specific directories to avoid token limits.
   - Use debug mode (`-d`) to verify which files are included/excluded.

2. **Effective Prompting:**
   - Reference files using their relative paths as shown in the generated directory structure.
   - Ask questions about specific sections of the output using the file headers.

3. **Best Practices:**
   - Always review the concatenated output before sending it to an LLM.
   - For large projects, consider breaking down the analysis into smaller, manageable components.

---

## Troubleshooting

### Common Issues

1. **No Files Found:**
   - Double-check the project path.
   - Ensure your project contains files with supported extensions.
   - Run with `--debug` to see detailed file filtering information.

2. **Missing Dependencies:**
   - Make sure you have installed all required packages by running:
     
     ```bash
     pip install -r requirements.txt
     ```

3. **Permission Issues:**
   - Make sure you have read permissions for the project directory and write permissions for the output file.

---

## Contributing

Contributions are welcome! If you have ideas for improvements, bug fixes, or additional features, please fork the repository and submit a pull request. For major changes, please open an issue first to discuss what you would like to change.

---

## License

This project is licensed under the [MIT License](LICENSE).

---

## Author

**Shiraz Akmal**

Feel free to reach out if you have any questions or feedback!

---

Happy coding with CodeSmelt!

# File: codesmelt.py
================================================================================

#!/usr/bin/env python3
"""
CodeSmelt: Source Code Concatenator

This tool melts down source code files from a git project into a single file,
including directory structure information.
"""

import argparse
import sys
from pathlib import Path
import os
from typing import Set, List, Optional
import fnmatch
from datetime import datetime
import gitignore_parser
from extensions import SOURCE_EXTENSIONS, IGNORE_PATTERNS

class CodeSmelt:
    def __init__(self, project_path: str, output_file: str):
        self.project_path = Path(project_path).resolve()
        self.output_file = Path(output_file)
        self.gitignore_matcher = self._setup_gitignore()
        self.debug = False
        self.include_structure = True

    def _setup_gitignore(self) -> Optional[callable]:
        """Setup gitignore matcher if .gitignore exists"""
        gitignore_path = self.project_path / '.gitignore'
        if gitignore_path.exists():
            try:
                return gitignore_parser.parse_gitignore(gitignore_path)
            except Exception as e:
                print(f"Warning: Failed to parse .gitignore: {e}")
        return None

    def _should_include_file(self, file_path: Path) -> bool:
        """Check if file should be included based on extension and ignore rules"""
        # Skip common virtual environment and system directories
        excluded_dirs = {
            '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
            '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
            'dist', 'build', 'target'
        }

        try:
            # Convert to relative path for checking
            try:
                rel_path = file_path.relative_to(self.project_path)
            except ValueError:
                if self.debug:
                    print(f"Debug: Skipping file outside project path: {file_path}")
                return False

            # Check for excluded directories in the path
            if any(part in excluded_dirs for part in file_path.parts):
                if self.debug:
                    print(f"Debug: Skipping excluded directory: {file_path}")
                return False

            # Check if file extension is in whitelist
            if file_path.suffix.lower() not in SOURCE_EXTENSIONS:
                if self.debug:
                    print(f"Debug: Skipping non-source file: {file_path}")
                return False

            # Check custom ignore patterns
            for pattern in IGNORE_PATTERNS:
                if fnmatch.fnmatch(str(rel_path), pattern):
                    if self.debug:
                        print(f"Debug: Skipping ignored pattern {pattern}: {file_path}")
                    return False

            # Check .gitignore if available
            if self.gitignore_matcher:
                try:
                    should_include = not self.gitignore_matcher(str(file_path))
                    if self.debug and not should_include:
                        print(f"Debug: Skipping gitignored file: {file_path}")
                    return should_include
                except Exception as e:
                    print(f"Warning: gitignore matching failed for {file_path}: {e}")
                    return True

            if self.debug:
                print(f"Debug: Including file: {file_path}")
            return True

        except Exception as e:
            print(f"Warning: Error checking file {file_path}: {e}")
            return False

    def _get_file_content(self, file_path: Path) -> str:
        """Read file content with proper encoding handling"""
        try:
            # Try UTF-8 first
            with open(file_path, 'r', encoding='utf-8') as f:
                return f.read()
        except UnicodeDecodeError:
            try:
                # Fallback to latin-1
                with open(file_path, 'r', encoding='latin-1') as f:
                    return f.read()
            except Exception as e:
                print(f"Warning: Failed to read {file_path}: {e}")
                return f"ERROR: Could not read file {file_path}\n"

    def _generate_directory_structure(self) -> str:
        """Generate a tree-like directory structure"""
        structure = ["Directory Structure:", ""]

        def add_to_tree(path: Path, prefix: str = ""):
            # Skip excluded directories
            excluded_dirs = {
                '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
                '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
                'dist', 'build', 'target'
            }
            if path.name in excluded_dirs:
                return

            # Add files first
            files = sorted([p for p in path.iterdir() if p.is_file()])
            included_files = [f for f in files if self._should_include_file(f)]

            for idx, file in enumerate(included_files):
                is_last = idx == len(included_files) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {file.name}")

            # Then add directories
            dirs = sorted([p for p in path.iterdir() if p.is_dir()])
            included_dirs = [d for d in dirs if d.name not in excluded_dirs]

            for idx, dir in enumerate(included_dirs):
                is_last = idx == len(included_dirs) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {dir.name}/")
                add_to_tree(dir, prefix + ("    " if is_last else "│   "))

        add_to_tree(self.project_path)
        return "\n".join(structure)

    def concatenate(self, debug: bool = False):
        """Main method to concatenate all source files"""
        self.debug = debug
        if not self.project_path.exists():
            print(f"Error: Project path {self.project_path} does not exist")
            return False

        try:
            with open(self.output_file, 'w', encoding='utf-8') as out:
                # Write header
                header = f"""
# Project Source Code Concatenation
# Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
# Project path: {self.project_path}

"""
                out.write(header)

                # Write directory structure if enabled
                if self.include_structure:
                    out.write(self._generate_directory_structure())
                    out.write("\n\n" + "="*80 + "\n\n")

                # Process all files
                file_count = 0
                for file_path in self.project_path.rglob('*'):
                    if file_path.is_file() and self._should_include_file(file_path):
                        rel_path = file_path.relative_to(self.project_path)

                        # Write file header
                        out.write(f"\n\n# File: {rel_path}\n")
                        out.write("="*80 + "\n\n")

                        # Write file content
                        content = self._get_file_content(file_path)
                        out.write(content)
                        file_count += 1

                print(f"Successfully melted {file_count} files to {self.output_file}")
                return True

        except Exception as e:
            print(f"Error during melting: {e}")
            return False

def main():
    parser = argparse.ArgumentParser(
        description="CodeSmelt: Melt down your git project's source code into a single file",
        usage="%(prog)s project_path [output_file] [-o OUTPUT] [-d] [-n]"
    )

    # Add the project path as required positional argument
    parser.add_argument(
        "project_path",
        help="Path to the git project directory"
    )

    # Add optional positional argument for output file
    parser.add_argument(
        "output_file",
        nargs="?",  # Make it optional
        help="Output file path (alternative to -o)",
        default=None
    )

    # Keep the original -o option for backward compatibility
    parser.add_argument(
        "-o", "--output",
        help="Output file path (default: concatenated_source.txt)",
        default=None
    )

    parser.add_argument(
        "-d", "--debug",
        action="store_true",
        help="Enable debug logging"
    )

    parser.add_argument(
        "-n", "--no-structure",
        action="store_true",
        help="Omit directory structure from output"
    )

    args = parser.parse_args()

    # Determine the output file path, prioritizing command line arguments
    output_file = args.output or args.output_file or "concatenated_source.txt"

    concatenator = CodeSmelt(args.project_path, output_file)
    concatenator.include_structure = not args.no_structure
    success = concatenator.concatenate(debug=args.debug)
    sys.exit(0 if success else 1)

if __name__ == "__main__":
    main()

# File: test_with_structure.txt
================================================================================


# Project Source Code Concatenation
# Generated on: 2025-02-15 23:26:14
# Project path: /home/runner/workspace

Directory Structure:

├── README.md
├── codesmelt.py
├── extensions.py
├── pyproject.toml
├── requirements.txt
└── test_with_structure.txt
└── assets/

================================================================================



# File: extensions.py
================================================================================

"""
Source code file extension configurations
"""

# Common source code file extensions
SOURCE_EXTENSIONS = {
    # Web
    '.js', '.ts', '.jsx', '.tsx', '.vue', '.svelte',
    '.html', '.htm', '.css', '.scss', '.sass', '.less',
    
    # Python
    '.py', '.pyi', '.pyx',
    
    # Java/Kotlin
    '.java', '.kt', '.groovy',
    
    # C-family
    '.c', '.cpp', '.h', '.hpp', '.cc',
    
    # C#
    '.cs', '.cshtml', '.csx',
    
    # Ruby
    '.rb', '.erb',
    
    # PHP
    '.php', '.php5', '.phtml',
    
    # Go
    '.go',
    
    # Rust
    '.rs',
    
    # Swift
    '.swift',
    
    # Shell
    '.sh', '.bash', '.zsh',
    
    # Config/Data
    '.json', '.yaml', '.yml', '.toml', '.xml',
    '.conf', '.ini', '.env',
    
    # Documentation
    '.md', '.rst', '.txt'
}

# Files to always ignore
IGNORE_PATTERNS = {
    # Build outputs
    'build/*', 'dist/*', 'target/*', 'bin/*',
    '*.pyc', '__pycache__/*', '*.class',
    
    # Dependencies
    'node_modules/*', 'vendor/*', 'venv/*',
    
    # IDE files
    '.idea/*', '.vscode/*', '*.swp',
    
    # Package files
    'package-lock.json', 'yarn.lock',
    'Pipfile.lock', 'poetry.lock',
    
    # Large data files
    '*.csv', '*.json.gz', '*.sql',
    
    # Binary/Media files
    '*.pdf', '*.jpg', '*.png', '*.gif',
    '*.mp3', '*.mp4', '*.mov', '*.bin',
    '*.exe', '*.dll', '*.so', '*.dylib'
}


# File: pyproject.toml
================================================================================

[project]
name = "repl-nix-workspace"
version = "0.1.0"
description = "Add your description here"
requires-python = ">=3.11"
dependencies = [
    "gitignore-parser>=0.1.11",
]


# File: requirements.txt
================================================================================

gitignore_parser==0.1.11

# File: README.md
================================================================================

# CodeSmelt: Source Code Concatenator

![CodeSmelt Logo](assets/CodeSmeltLogo.jpg)

**CodeSmelt** is a command-line tool that “melts down” your Git project’s source code into a single, well-organized file. It not only concatenates source files but also embeds a tree-like directory structure to help you quickly understand your project’s layout. This is especially useful for code analysis, preparing inputs for language models, or sharing project snapshots.

---

## Table of Contents

- [Features](#features)
- [Installation](#installation)
- [Usage](#usage)
  - [Basic Usage](#basic-usage)
  - [Custom Output & Debug Mode](#custom-output--debug-mode)
- [Configuration](#configuration)
  - [Source File Extensions](#source-file-extensions)
  - [Ignore Patterns](#ignore-patterns)
- [Tips for Using with LLMs](#tips-for-using-with-llms)
- [Troubleshooting](#troubleshooting)
- [Contributing](#contributing)
- [License](#license)
- [Author](#author)

---

## Features

- **Concatenation with Context:** Combines all source files (with supported extensions) into one file while preserving directory hierarchy.
- **Smart Filtering:** Uses built-in file extension whitelists and ignore patterns. Also honors your project’s `.gitignore` for extra filtering.
- **Encoding Handling:** Automatically handles file encoding issues (tries UTF-8 first, then falls back to Latin-1).
- **Debug Logging:** Option to enable debug logging so you can see which files are being included or skipped.
- **Easy Customization:** Adjust supported file extensions and ignore patterns via the `extensions.py` file.

---

## Installation

1. **Clone the Repository:**

   ```bash
   git clone https://github.com/yourusername/codesmelt.git
   cd codesmelt
   ```

2. **Install Dependencies:**

   CodeSmelt requires Python 3. Instead of installing dependencies individually, you can install all required packages using the `requirements.txt` file:

   ```bash
   pip install -r requirements.txt
   ```

   *(If you use a virtual environment, activate it before installing.)*

3. **Ensure File Structure:**

   Make sure the following files are in the same directory:
   
   - `codesmelt.py`
   - `extensions.py`
   - `README.md`
   - `requirements.txt`
   - `assets/CodeSmeltLogo.jpg` (logo image)

---

## Usage

### Basic Usage

Run CodeSmelt by providing the path to your Git project. For example:

```bash
python codesmelt.py /path/to/project
```

### Custom Output & Debug Mode

- **Specify a Custom Output File:**

  ```bash
  python codesmelt.py -o output.txt /path/to/project
  ```

- **Enable Debug Logging:**

  ```bash
  python codesmelt.py -d -o output.txt /path/to/project
  ```

#### Command-line Arguments

- `project_path` (required): Path to your Git project directory.
- `-o, --output`: Specify the output file path (default: `concatenated_source.txt`).
- `-d, --debug`: Enable debug logging to get detailed information about file selection.

---

## Configuration

CodeSmelt uses the `extensions.py` file to define:

### Source File Extensions

The tool automatically includes many common source code file extensions. Examples include:

- **Web:** `.js`, `.ts`, `.jsx`, `.tsx`, `.vue`, `.svelte`, `.html`, `.css`, etc.
- **Python:** `.py`, `.pyi`, `.pyx`
- **Java/Kotlin:** `.java`, `.kt`, `.groovy`
- **C-family:** `.c`, `.cpp`, `.h`, `.hpp`
- **Other Languages:** Ruby (`.rb`), PHP (`.php`), Go (`.go`), Rust (`.rs`), Swift (`.swift`), Shell (`.sh`), and more.

*To add or remove extensions, edit the `SOURCE_EXTENSIONS` set in `extensions.py`.*

### Ignore Patterns

Files and directories are automatically ignored based on three levels:

1. **Built-in Patterns:** Defined in the `IGNORE_PATTERNS` set in `extensions.py` (e.g., build outputs, dependency directories, IDE files, binary/media files).
2. **Project’s `.gitignore`:** If a `.gitignore` is present at the root of your project, CodeSmelt honors its rules.
3. **Directory-specific Rules:** Additional `.gitignore` files in subdirectories will also be considered.

*To customize, modify the `IGNORE_PATTERNS` in `extensions.py`.*

Example of adding Unity3D-specific ignores:

```python
IGNORE_PATTERNS = {
    # ... existing patterns ...
    'Assets/AssetStoreTools/*',
    'Library/*',
    'Temp/*',
    'Logs/*',
    '*.unity',  # Unity scene files
    '*.meta',   # Unity meta files
    '*.prefab', # Unity prefab files
    # ... other patterns ...
}
```

---

## Tips for Using with LLMs

1. **Token Management:**
   - For very large projects, consider concatenating only specific directories to avoid token limits.
   - Use debug mode (`-d`) to verify which files are included/excluded.

2. **Effective Prompting:**
   - Reference files using their relative paths as shown in the generated directory structure.
   - Ask questions about specific sections of the output using the file headers.

3. **Best Practices:**
   - Always review the concatenated output before sending it to an LLM.
   - For large projects, consider breaking down the analysis into smaller, manageable components.

---

## Troubleshooting

### Common Issues

1. **No Files Found:**
   - Double-check the project path.
   - Ensure your project contains files with supported extensions.
   - Run with `--debug` to see detailed file filtering information.

2. **Missing Dependencies:**
   - Make sure you have installed all required packages by running:
     
     ```bash
     pip install -r requirements.txt
     ```

3. **Permission Issues:**
   - Make sure you have read permissions for the project directory and write permissions for the output file.

---

## Contributing

Contributions are welcome! If you have ideas for improvements, bug fixes, or additional features, please fork the repository and submit a pull request. For major changes, please open an issue first to discuss what you would like to change.

---

## License

This project is licensed under the [MIT License](LICENSE).

---

## Author

**Shiraz Akmal**

Feel free to reach out if you have any questions or feedback!

---

Happy coding with CodeSmelt!

# File: codesmelt.py
================================================================================

#!/usr/bin/env python3
"""
CodeSmelt: Source Code Concatenator

This tool melts down source code files from a git project into a single file,
including directory structure information.
"""

import argparse
import sys
from pathlib import Path
import os
from typing import Set, List, Optional
import fnmatch
from datetime import datetime
import gitignore_parser
from extensions import SOURCE_EXTENSIONS, IGNORE_PATTERNS

class CodeSmelt:
    def __init__(self, project_path: str, output_file: str):
        self.project_path = Path(project_path).resolve()
        self.output_file = Path(output_file)
        self.gitignore_matcher = self._setup_gitignore()
        self.debug = False
        self.include_structure = True

    def _setup_gitignore(self) -> Optional[callable]:
        """Setup gitignore matcher if .gitignore exists"""
        gitignore_path = self.project_path / '.gitignore'
        if gitignore_path.exists():
            try:
                return gitignore_parser.parse_gitignore(gitignore_path)
            except Exception as e:
                print(f"Warning: Failed to parse .gitignore: {e}")
        return None

    def _should_include_file(self, file_path: Path) -> bool:
        """Check if file should be included based on extension and ignore rules"""
        # Skip common virtual environment and system directories
        excluded_dirs = {
            '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
            '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
            'dist', 'build', 'target'
        }

        try:
            # Convert to relative path for checking
            try:
                rel_path = file_path.relative_to(self.project_path)
            except ValueError:
                if self.debug:
                    print(f"Debug: Skipping file outside project path: {file_path}")
                return False

            # Check for excluded directories in the path
            if any(part in excluded_dirs for part in file_path.parts):
                if self.debug:
                    print(f"Debug: Skipping excluded directory: {file_path}")
                return False

            # Check if file extension is in whitelist
            if file_path.suffix.lower() not in SOURCE_EXTENSIONS:
                if self.debug:
                    print(f"Debug: Skipping non-source file: {file_path}")
                return False

            # Check custom ignore patterns
            for pattern in IGNORE_PATTERNS:
                if fnmatch.fnmatch(str(rel_path), pattern):
                    if self.debug:
                        print(f"Debug: Skipping ignored pattern {pattern}: {file_path}")
                    return False

            # Check .gitignore if available
            if self.gitignore_matcher:
                try:
                    should_include = not self.gitignore_matcher(str(file_path))
                    if self.debug and not should_include:
                        print(f"Debug: Skipping gitignored file: {file_path}")
                    return should_include
                except Exception as e:
                    print(f"Warning: gitignore matching failed for {file_path}: {e}")
                    return True

            if self.debug:
                print(f"Debug: Including file: {file_path}")
            return True

        except Exception as e:
            print(f"Warning: Error checking file {file_path}: {e}")
            return False

    def _get_file_content(self, file_path: Path) -> str:
        """Read file content with proper encoding handling"""
        try:
            # Try UTF-8 first
            with open(file_path, 'r', encoding='utf-8') as f:
                return f.read()
        except UnicodeDecodeError:
            try:
                # Fallback to latin-1
                with open(file_path, 'r', encoding='latin-1') as f:
                    return f.read()
            except Exception as e:
                print(f"Warning: Failed to read {file_path}: {e}")
                return f"ERROR: Could not read file {file_path}\n"

    def _generate_directory_structure(self) -> str:
        """Generate a tree-like directory structure"""
        structure = ["Directory Structure:", ""]

        def add_to_tree(path: Path, prefix: str = ""):
            # Skip excluded directories
            excluded_dirs = {
                '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
                '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
                'dist', 'build', 'target'
            }
            if path.name in excluded_dirs:
                return

            # Add files first
            files = sorted([p for p in path.iterdir() if p.is_file()])
            included_files = [f for f in files if self._should_include_file(f)]

            for idx, file in enumerate(included_files):
                is_last = idx == len(included_files) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {file.name}")

            # Then add directories
            dirs = sorted([p for p in path.iterdir() if p.is_dir()])
            included_dirs = [d for d in dirs if d.name not in excluded_dirs]

            for idx, dir in enumerate(included_dirs):
                is_last = idx == len(included_dirs) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {dir.name}/")
                add_to_tree(dir, prefix + ("    " if is_last else "│   "))

        add_to_tree(self.project_path)
        return "\n".join(structure)

    def concatenate(self, debug: bool = False):
        """Main method to concatenate all source files"""
        self.debug = debug
        if not self.project_path.exists():
            print(f"Error: Project path {self.project_path} does not exist")
            return False

        try:
            with open(self.output_file, 'w', encoding='utf-8') as out:
                # Write header
                header = f"""
# Project Source Code Concatenation
# Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
# Project path: {self.project_path}

"""
                out.write(header)

                # Write directory structure if enabled
                if self.include_structure:
                    out.write(self._generate_directory_structure())
                    out.write("\n\n" + "="*80 + "\n\n")

                # Process all files
                file_count = 0
                for file_path in self.project_path.rglob('*'):
                    if file_path.is_file() and self._should_include_file(file_path):
                        rel_path = file_path.relative_to(self.project_path)

                        # Write file header
                        out.write(f"\n\n# File: {rel_path}\n")
                        out.write("="*80 + "\n\n")

                        # Write file content
                        content = self._get_file_content(file_path)
                        out.write(content)
                        file_count += 1

                print(f"Successfully melted {file_count} files to {self.output_file}")
                return True

        except Exception as e:
            print(f"Error during melting: {e}")
            return False

def main():
    parser = argparse.ArgumentParser(
        description="CodeSmelt: Melt down your git project's source code into a single file",
        usage="%(prog)s project_path [output_file] [-o OUTPUT] [-d] [-n]"
    )

    # Add the project path as required positional argument
    parser.add_argument(
        "project_path",
        help="Path to the git project directory"
    )

    # Add optional positional argument for output file
    parser.add_argument(
        "output_file",
        nargs="?",  # Make it optional
        help="Output file path (alternative to -o)",
        default=None
    )

    # Keep the original -o option for backward compatibility
    parser.add_argument(
        "-o", "--output",
        help="Output file path (default: concatenated_source.txt)",
        default=None
    )

    parser.add_argument(
        "-d", "--debug",
        action="store_true",
        help="Enable debug logging"
    )

    parser.add_argument(
        "-n", "--no-structure",
        action="store_true",
        help="Omit directory structure from output"
    )

    args = parser.parse_args()

    # Determine the output file path, prioritizing command line arguments
    output_file = args.output or args.output_file or "concatenated_source.txt"

    concatenator = CodeSmelt(args.project_path, output_file)
    concatenator.include_structure = not args.no_structure
    success = concatenator.concatenate(debug=args.debug)
    sys.exit(0 if success else 1)

if __name__ == "__main__":
    main()

# File: test_without_structure.txt
================================================================================


# Project Source Code Concatenation
# Generated on: 2025-02-15 23:26:14
# Project path: /home/runner/workspace



# File: extensions.py
================================================================================

"""
Source code file extension configurations
"""

# Common source code file extensions
SOURCE_EXTENSIONS = {
    # Web
    '.js', '.ts', '.jsx', '.tsx', '.vue', '.svelte',
    '.html', '.htm', '.css', '.scss', '.sass', '.less',
    
    # Python
    '.py', '.pyi', '.pyx',
    
    # Java/Kotlin
    '.java', '.kt', '.groovy',
    
    # C-family
    '.c', '.cpp', '.h', '.hpp', '.cc',
    
    # C#
    '.cs', '.cshtml', '.csx',
    
    # Ruby
    '.rb', '.erb',
    
    # PHP
    '.php', '.php5', '.phtml',
    
    # Go
    '.go',
    
    # Rust
    '.rs',
    
    # Swift
    '.swift',
    
    # Shell
    '.sh', '.bash', '.zsh',
    
    # Config/Data
    '.json', '.yaml', '.yml', '.toml', '.xml',
    '.conf', '.ini', '.env',
    
    # Documentation
    '.md', '.rst', '.txt'
}

# Files to always ignore
IGNORE_PATTERNS = {
    # Build outputs
    'build/*', 'dist/*', 'target/*', 'bin/*',
    '*.pyc', '__pycache__/*', '*.class',
    
    # Dependencies
    'node_modules/*', 'vendor/*', 'venv/*',
    
    # IDE files
    '.idea/*', '.vscode/*', '*.swp',
    
    # Package files
    'package-lock.json', 'yarn.lock',
    'Pipfile.lock', 'poetry.lock',
    
    # Large data files
    '*.csv', '*.json.gz', '*.sql',
    
    # Binary/Media files
    '*.pdf', '*.jpg', '*.png', '*.gif',
    '*.mp3', '*.mp4', '*.mov', '*.bin',
    '*.exe', '*.dll', '*.so', '*.dylib'
}


# File: pyproject.toml
================================================================================

[project]
name = "repl-nix-workspace"
version = "0.1.0"
description = "Add your description here"
requires-python = ">=3.11"
dependencies = [
    "gitignore-parser>=0.1.11",
]


# File: requirements.txt
================================================================================

gitignore_parser==0.1.11

# File: README.md
================================================================================

# CodeSmelt: Source Code Concatenator

![CodeSmelt Logo](assets/CodeSmeltLogo.jpg)

**CodeSmelt** is a command-line tool that “melts down” your Git project’s source code into a single, well-organized file. It not only concatenates source files but also embeds a tree-like directory structure to help you quickly understand your project’s layout. This is especially useful for code analysis, preparing inputs for language models, or sharing project snapshots.

---

## Table of Contents

- [Features](#features)
- [Installation](#installation)
- [Usage](#usage)
  - [Basic Usage](#basic-usage)
  - [Custom Output & Debug Mode](#custom-output--debug-mode)
- [Configuration](#configuration)
  - [Source File Extensions](#source-file-extensions)
  - [Ignore Patterns](#ignore-patterns)
- [Tips for Using with LLMs](#tips-for-using-with-llms)
- [Troubleshooting](#troubleshooting)
- [Contributing](#contributing)
- [License](#license)
- [Author](#author)

---

## Features

- **Concatenation with Context:** Combines all source files (with supported extensions) into one file while preserving directory hierarchy.
- **Smart Filtering:** Uses built-in file extension whitelists and ignore patterns. Also honors your project’s `.gitignore` for extra filtering.
- **Encoding Handling:** Automatically handles file encoding issues (tries UTF-8 first, then falls back to Latin-1).
- **Debug Logging:** Option to enable debug logging so you can see which files are being included or skipped.
- **Easy Customization:** Adjust supported file extensions and ignore patterns via the `extensions.py` file.

---

## Installation

1. **Clone the Repository:**

   ```bash
   git clone https://github.com/yourusername/codesmelt.git
   cd codesmelt
   ```

2. **Install Dependencies:**

   CodeSmelt requires Python 3. Instead of installing dependencies individually, you can install all required packages using the `requirements.txt` file:

   ```bash
   pip install -r requirements.txt
   ```

   *(If you use a virtual environment, activate it before installing.)*

3. **Ensure File Structure:**

   Make sure the following files are in the same directory:
   
   - `codesmelt.py`
   - `extensions.py`
   - `README.md`
   - `requirements.txt`
   - `assets/CodeSmeltLogo.jpg` (logo image)

---

## Usage

### Basic Usage

Run CodeSmelt by providing the path to your Git project. For example:

```bash
python codesmelt.py /path/to/project
```

### Custom Output & Debug Mode

- **Specify a Custom Output File:**

  ```bash
  python codesmelt.py -o output.txt /path/to/project
  ```

- **Enable Debug Logging:**

  ```bash
  python codesmelt.py -d -o output.txt /path/to/project
  ```

#### Command-line Arguments

- `project_path` (required): Path to your Git project directory.
- `-o, --output`: Specify the output file path (default: `concatenated_source.txt`).
- `-d, --debug`: Enable debug logging to get detailed information about file selection.

---

## Configuration

CodeSmelt uses the `extensions.py` file to define:

### Source File Extensions

The tool automatically includes many common source code file extensions. Examples include:

- **Web:** `.js`, `.ts`, `.jsx`, `.tsx`, `.vue`, `.svelte`, `.html`, `.css`, etc.
- **Python:** `.py`, `.pyi`, `.pyx`
- **Java/Kotlin:** `.java`, `.kt`, `.groovy`
- **C-family:** `.c`, `.cpp`, `.h`, `.hpp`
- **Other Languages:** Ruby (`.rb`), PHP (`.php`), Go (`.go`), Rust (`.rs`), Swift (`.swift`), Shell (`.sh`), and more.

*To add or remove extensions, edit the `SOURCE_EXTENSIONS` set in `extensions.py`.*

### Ignore Patterns

Files and directories are automatically ignored based on three levels:

1. **Built-in Patterns:** Defined in the `IGNORE_PATTERNS` set in `extensions.py` (e.g., build outputs, dependency directories, IDE files, binary/media files).
2. **Project’s `.gitignore`:** If a `.gitignore` is present at the root of your project, CodeSmelt honors its rules.
3. **Directory-specific Rules:** Additional `.gitignore` files in subdirectories will also be considered.

*To customize, modify the `IGNORE_PATTERNS` in `extensions.py`.*

Example of adding Unity3D-specific ignores:

```python
IGNORE_PATTERNS = {
    # ... existing patterns ...
    'Assets/AssetStoreTools/*',
    'Library/*',
    'Temp/*',
    'Logs/*',
    '*.unity',  # Unity scene files
    '*.meta',   # Unity meta files
    '*.prefab', # Unity prefab files
    # ... other patterns ...
}
```

---

## Tips for Using with LLMs

1. **Token Management:**
   - For very large projects, consider concatenating only specific directories to avoid token limits.
   - Use debug mode (`-d`) to verify which files are included/excluded.

2. **Effective Prompting:**
   - Reference files using their relative paths as shown in the generated directory structure.
   - Ask questions about specific sections of the output using the file headers.

3. **Best Practices:**
   - Always review the concatenated output before sending it to an LLM.
   - For large projects, consider breaking down the analysis into smaller, manageable components.

---

## Troubleshooting

### Common Issues

1. **No Files Found:**
   - Double-check the project path.
   - Ensure your project contains files with supported extensions.
   - Run with `--debug` to see detailed file filtering information.

2. **Missing Dependencies:**
   - Make sure you have installed all required packages by running:
     
     ```bash
     pip install -r requirements.txt
     ```

3. **Permission Issues:**
   - Make sure you have read permissions for the project directory and write permissions for the output file.

---

## Contributing

Contributions are welcome! If you have ideas for improvements, bug fixes, or additional features, please fork the repository and submit a pull request. For major changes, please open an issue first to discuss what you would like to change.

---

## License

This project is licensed under the [MIT License](LICENSE).

---

## Author

**Shiraz Akmal**

Feel free to reach out if you have any questions or feedback!

---

Happy coding with CodeSmelt!

# File: codesmelt.py
================================================================================

#!/usr/bin/env python3
"""
CodeSmelt: Source Code Concatenator

This tool melts down source code files from a git project into a single file,
including directory structure information.
"""

import argparse
import sys
from pathlib import Path
import os
from typing import Set, List, Optional
import fnmatch
from datetime import datetime
import gitignore_parser
from extensions import SOURCE_EXTENSIONS, IGNORE_PATTERNS

class CodeSmelt:
    def __init__(self, project_path: str, output_file: str):
        self.project_path = Path(project_path).resolve()
        self.output_file = Path(output_file)
        self.gitignore_matcher = self._setup_gitignore()
        self.debug = False
        self.include_structure = True

    def _setup_gitignore(self) -> Optional[callable]:
        """Setup gitignore matcher if .gitignore exists"""
        gitignore_path = self.project_path / '.gitignore'
        if gitignore_path.exists():
            try:
                return gitignore_parser.parse_gitignore(gitignore_path)
            except Exception as e:
                print(f"Warning: Failed to parse .gitignore: {e}")
        return None

    def _should_include_file(self, file_path: Path) -> bool:
        """Check if file should be included based on extension and ignore rules"""
        # Skip common virtual environment and system directories
        excluded_dirs = {
            '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
            '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
            'dist', 'build', 'target'
        }

        try:
            # Convert to relative path for checking
            try:
                rel_path = file_path.relative_to(self.project_path)
            except ValueError:
                if self.debug:
                    print(f"Debug: Skipping file outside project path: {file_path}")
                return False

            # Check for excluded directories in the path
            if any(part in excluded_dirs for part in file_path.parts):
                if self.debug:
                    print(f"Debug: Skipping excluded directory: {file_path}")
                return False

            # Check if file extension is in whitelist
            if file_path.suffix.lower() not in SOURCE_EXTENSIONS:
                if self.debug:
                    print(f"Debug: Skipping non-source file: {file_path}")
                return False

            # Check custom ignore patterns
            for pattern in IGNORE_PATTERNS:
                if fnmatch.fnmatch(str(rel_path), pattern):
                    if self.debug:
                        print(f"Debug: Skipping ignored pattern {pattern}: {file_path}")
                    return False

            # Check .gitignore if available
            if self.gitignore_matcher:
                try:
                    should_include = not self.gitignore_matcher(str(file_path))
                    if self.debug and not should_include:
                        print(f"Debug: Skipping gitignored file: {file_path}")
                    return should_include
                except Exception as e:
                    print(f"Warning: gitignore matching failed for {file_path}: {e}")
                    return True

            if self.debug:
                print(f"Debug: Including file: {file_path}")
            return True

        except Exception as e:
            print(f"Warning: Error checking file {file_path}: {e}")
            return False

    def _get_file_content(self, file_path: Path) -> str:
        """Read file content with proper encoding handling"""
        try:
            # Try UTF-8 first
            with open(file_path, 'r', encoding='utf-8') as f:
                return f.read()
        except UnicodeDecodeError:
            try:
                # Fallback to latin-1
                with open(file_path, 'r', encoding='latin-1') as f:
                    return f.read()
            except Exception as e:
                print(f"Warning: Failed to read {file_path}: {e}")
                return f"ERROR: Could not read file {file_path}\n"

    def _generate_directory_structure(self) -> str:
        """Generate a tree-like directory structure"""
        structure = ["Directory Structure:", ""]

        def add_to_tree(path: Path, prefix: str = ""):
            # Skip excluded directories
            excluded_dirs = {
                '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
                '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
                'dist', 'build', 'target'
            }
            if path.name in excluded_dirs:
                return

            # Add files first
            files = sorted([p for p in path.iterdir() if p.is_file()])
            included_files = [f for f in files if self._should_include_file(f)]

            for idx, file in enumerate(included_files):
                is_last = idx == len(included_files) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {file.name}")

            # Then add directories
            dirs = sorted([p for p in path.iterdir() if p.is_dir()])
            included_dirs = [d for d in dirs if d.name not in excluded_dirs]

            for idx, dir in enumerate(included_dirs):
                is_last = idx == len(included_dirs) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {dir.name}/")
                add_to_tree(dir, prefix + ("    " if is_last else "│   "))

        add_to_tree(self.project_path)
        return "\n".join(structure)

    def concatenate(self, debug: bool = False):
        """Main method to concatenate all source files"""
        self.debug = debug
        if not self.project_path.exists():
            print(f"Error: Project path {self.project_path} does not exist")
            return False

        try:
            with open(self.output_file, 'w', encoding='utf-8') as out:
                # Write header
                header = f"""
# Project Source Code Concatenation
# Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
# Project path: {self.project_path}

"""
                out.write(header)

                # Write directory structure if enabled
                if self.include_structure:
                    out.write(self._generate_directory_structure())
                    out.write("\n\n" + "="*80 + "\n\n")

                # Process all files
                file_count = 0
                for file_path in self.project_path.rglob('*'):
                    if file_path.is_file() and self._should_include_file(file_path):
                        rel_path = file_path.relative_to(self.project_path)

                        # Write file header
                        out.write(f"\n\n# File: {rel_path}\n")
                        out.write("="*80 + "\n\n")

                        # Write file content
                        content = self._get_file_content(file_path)
                        out.write(content)
                        file_count += 1

                print(f"Successfully melted {file_count} files to {self.output_file}")
                return True

        except Exception as e:
            print(f"Error during melting: {e}")
            return False

def main():
    parser = argparse.ArgumentParser(
        description="CodeSmelt: Melt down your git project's source code into a single file",
        usage="%(prog)s project_path [output_file] [-o OUTPUT] [-d] [-n]"
    )

    # Add the project path as required positional argument
    parser.add_argument(
        "project_path",
        help="Path to the git project directory"
    )

    # Add optional positional argument for output file
    parser.add_argument(
        "output_file",
        nargs="?",  # Make it optional
        help="Output file path (alternative to -o)",
        default=None
    )

    # Keep the original -o option for backward compatibility
    parser.add_argument(
        "-o", "--output",
        help="Output file path (default: concatenated_source.txt)",
        default=None
    )

    parser.add_argument(
        "-d", "--debug",
        action="store_true",
        help="Enable debug logging"
    )

    parser.add_argument(
        "-n", "--no-structure",
        action="store_true",
        help="Omit directory structure from output"
    )

    args = parser.parse_args()

    # Determine the output file path, prioritizing command line arguments
    output_file = args.output or args.output_file or "concatenated_source.txt"

    concatenator = CodeSmelt(args.project_path, output_file)
    concatenator.include_structure = not args.no_structure
    success = concatenator.concatenate(debug=args.debug)
    sys.exit(0 if success else 1)

if __name__ == "__main__":
    main()

# File: test_with_structure.txt
================================================================================


# Project Source Code Concatenation
# Generated on: 2025-02-15 23:26:14
# Project path: /home/runner/workspace

Directory Structure:

├── README.md
├── codesmelt.py
├── extensions.py
├── pyproject.toml
├── requirements.txt
└── test_with_structure.txt
└── assets/

================================================================================



# File: extensions.py
================================================================================

"""
Source code file extension configurations
"""

# Common source code file extensions
SOURCE_EXTENSIONS = {
    # Web
    '.js', '.ts', '.jsx', '.tsx', '.vue', '.svelte',
    '.html', '.htm', '.css', '.scss', '.sass', '.less',
    
    # Python
    '.py', '.pyi', '.pyx',
    
    # Java/Kotlin
    '.java', '.kt', '.groovy',
    
    # C-family
    '.c', '.cpp', '.h', '.hpp', '.cc',
    
    # C#
    '.cs', '.cshtml', '.csx',
    
    # Ruby
    '.rb', '.erb',
    
    # PHP
    '.php', '.php5', '.phtml',
    
    # Go
    '.go',
    
    # Rust
    '.rs',
    
    # Swift
    '.swift',
    
    # Shell
    '.sh', '.bash', '.zsh',
    
    # Config/Data
    '.json', '.yaml', '.yml', '.toml', '.xml',
    '.conf', '.ini', '.env',
    
    # Documentation
    '.md', '.rst', '.txt'
}

# Files to always ignore
IGNORE_PATTERNS = {
    # Build outputs
    'build/*', 'dist/*', 'target/*', 'bin/*',
    '*.pyc', '__pycache__/*', '*.class',
    
    # Dependencies
    'node_modules/*', 'vendor/*', 'venv/*',
    
    # IDE files
    '.idea/*', '.vscode/*', '*.swp',
    
    # Package files
    'package-lock.json', 'yarn.lock',
    'Pipfile.lock', 'poetry.lock',
    
    # Large data files
    '*.csv', '*.json.gz', '*.sql',
    
    # Binary/Media files
    '*.pdf', '*.jpg', '*.png', '*.gif',
    '*.mp3', '*.mp4', '*.mov', '*.bin',
    '*.exe', '*.dll', '*.so', '*.dylib'
}


# File: pyproject.toml
================================================================================

[project]
name = "repl-nix-workspace"
version = "0.1.0"
description = "Add your description here"
requires-python = ">=3.11"
dependencies = [
    "gitignore-parser>=0.1.11",
]


# File: requirements.txt
================================================================================

gitignore_parser==0.1.11

# File: README.md
================================================================================

# CodeSmelt: Source Code Concatenator

![CodeSmelt Logo](assets/CodeSmeltLogo.jpg)

**CodeSmelt** is a command-line tool that “melts down” your Git project’s source code into a single, well-organized file. It not only concatenates source files but also embeds a tree-like directory structure to help you quickly understand your project’s layout. This is especially useful for code analysis, preparing inputs for language models, or sharing project snapshots.

---

## Table of Contents

- [Features](#features)
- [Installation](#installation)
- [Usage](#usage)
  - [Basic Usage](#basic-usage)
  - [Custom Output & Debug Mode](#custom-output--debug-mode)
- [Configuration](#configuration)
  - [Source File Extensions](#source-file-extensions)
  - [Ignore Patterns](#ignore-patterns)
- [Tips for Using with LLMs](#tips-for-using-with-llms)
- [Troubleshooting](#troubleshooting)
- [Contributing](#contributing)
- [License](#license)
- [Author](#author)

---

## Features

- **Concatenation with Context:** Combines all source files (with supported extensions) into one file while preserving directory hierarchy.
- **Smart Filtering:** Uses built-in file extension whitelists and ignore patterns. Also honors your project’s `.gitignore` for extra filtering.
- **Encoding Handling:** Automatically handles file encoding issues (tries UTF-8 first, then falls back to Latin-1).
- **Debug Logging:** Option to enable debug logging so you can see which files are being included or skipped.
- **Easy Customization:** Adjust supported file extensions and ignore patterns via the `extensions.py` file.

---

## Installation

1. **Clone the Repository:**

   ```bash
   git clone https://github.com/yourusername/codesmelt.git
   cd codesmelt
   ```

2. **Install Dependencies:**

   CodeSmelt requires Python 3. Instead of installing dependencies individually, you can install all required packages using the `requirements.txt` file:

   ```bash
   pip install -r requirements.txt
   ```

   *(If you use a virtual environment, activate it before installing.)*

3. **Ensure File Structure:**

   Make sure the following files are in the same directory:
   
   - `codesmelt.py`
   - `extensions.py`
   - `README.md`
   - `requirements.txt`
   - `assets/CodeSmeltLogo.jpg` (logo image)

---

## Usage

### Basic Usage

Run CodeSmelt by providing the path to your Git project. For example:

```bash
python codesmelt.py /path/to/project
```

### Custom Output & Debug Mode

- **Specify a Custom Output File:**

  ```bash
  python codesmelt.py -o output.txt /path/to/project
  ```

- **Enable Debug Logging:**

  ```bash
  python codesmelt.py -d -o output.txt /path/to/project
  ```

#### Command-line Arguments

- `project_path` (required): Path to your Git project directory.
- `-o, --output`: Specify the output file path (default: `concatenated_source.txt`).
- `-d, --debug`: Enable debug logging to get detailed information about file selection.

---

## Configuration

CodeSmelt uses the `extensions.py` file to define:

### Source File Extensions

The tool automatically includes many common source code file extensions. Examples include:

- **Web:** `.js`, `.ts`, `.jsx`, `.tsx`, `.vue`, `.svelte`, `.html`, `.css`, etc.
- **Python:** `.py`, `.pyi`, `.pyx`
- **Java/Kotlin:** `.java`, `.kt`, `.groovy`
- **C-family:** `.c`, `.cpp`, `.h`, `.hpp`
- **Other Languages:** Ruby (`.rb`), PHP (`.php`), Go (`.go`), Rust (`.rs`), Swift (`.swift`), Shell (`.sh`), and more.

*To add or remove extensions, edit the `SOURCE_EXTENSIONS` set in `extensions.py`.*

### Ignore Patterns

Files and directories are automatically ignored based on three levels:

1. **Built-in Patterns:** Defined in the `IGNORE_PATTERNS` set in `extensions.py` (e.g., build outputs, dependency directories, IDE files, binary/media files).
2. **Project’s `.gitignore`:** If a `.gitignore` is present at the root of your project, CodeSmelt honors its rules.
3. **Directory-specific Rules:** Additional `.gitignore` files in subdirectories will also be considered.

*To customize, modify the `IGNORE_PATTERNS` in `extensions.py`.*

Example of adding Unity3D-specific ignores:

```python
IGNORE_PATTERNS = {
    # ... existing patterns ...
    'Assets/AssetStoreTools/*',
    'Library/*',
    'Temp/*',
    'Logs/*',
    '*.unity',  # Unity scene files
    '*.meta',   # Unity meta files
    '*.prefab', # Unity prefab files
    # ... other patterns ...
}
```

---

## Tips for Using with LLMs

1. **Token Management:**
   - For very large projects, consider concatenating only specific directories to avoid token limits.
   - Use debug mode (`-d`) to verify which files are included/excluded.

2. **Effective Prompting:**
   - Reference files using their relative paths as shown in the generated directory structure.
   - Ask questions about specific sections of the output using the file headers.

3. **Best Practices:**
   - Always review the concatenated output before sending it to an LLM.
   - For large projects, consider breaking down the analysis into smaller, manageable components.

---

## Troubleshooting

### Common Issues

1. **No Files Found:**
   - Double-check the project path.
   - Ensure your project contains files with supported extensions.
   - Run with `--debug` to see detailed file filtering information.

2. **Missing Dependencies:**
   - Make sure you have installed all required packages by running:
     
     ```bash
     pip install -r requirements.txt
     ```

3. **Permission Issues:**
   - Make sure you have read permissions for the project directory and write permissions for the output file.

---

## Contributing

Contributions are welcome! If you have ideas for improvements, bug fixes, or additional features, please fork the repository and submit a pull request. For major changes, please open an issue first to discuss what you would like to change.

---

## License

This project is licensed under the [MIT License](LICENSE).

---

## Author

**Shiraz Akmal**

Feel free to reach out if you have any questions or feedback!

---

Happy coding with CodeSmelt!

# File: codesmelt.py
================================================================================

#!/usr/bin/env python3
"""
CodeSmelt: Source Code Concatenator

This tool melts down source code files from a git project into a single file,
including directory structure information.
"""

import argparse
import sys
from pathlib import Path
import os
from typing import Set, List, Optional
import fnmatch
from datetime import datetime
import gitignore_parser
from extensions import SOURCE_EXTENSIONS, IGNORE_PATTERNS

class CodeSmelt:
    def __init__(self, project_path: str, output_file: str):
        self.project_path = Path(project_path).resolve()
        self.output_file = Path(output_file)
        self.gitignore_matcher = self._setup_gitignore()
        self.debug = False
        self.include_structure = True

    def _setup_gitignore(self) -> Optional[callable]:
        """Setup gitignore matcher if .gitignore exists"""
        gitignore_path = self.project_path / '.gitignore'
        if gitignore_path.exists():
            try:
                return gitignore_parser.parse_gitignore(gitignore_path)
            except Exception as e:
                print(f"Warning: Failed to parse .gitignore: {e}")
        return None

    def _should_include_file(self, file_path: Path) -> bool:
        """Check if file should be included based on extension and ignore rules"""
        # Skip common virtual environment and system directories
        excluded_dirs = {
            '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
            '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
            'dist', 'build', 'target'
        }

        try:
            # Convert to relative path for checking
            try:
                rel_path = file_path.relative_to(self.project_path)
            except ValueError:
                if self.debug:
                    print(f"Debug: Skipping file outside project path: {file_path}")
                return False

            # Check for excluded directories in the path
            if any(part in excluded_dirs for part in file_path.parts):
                if self.debug:
                    print(f"Debug: Skipping excluded directory: {file_path}")
                return False

            # Check if file extension is in whitelist
            if file_path.suffix.lower() not in SOURCE_EXTENSIONS:
                if self.debug:
                    print(f"Debug: Skipping non-source file: {file_path}")
                return False

            # Check custom ignore patterns
            for pattern in IGNORE_PATTERNS:
                if fnmatch.fnmatch(str(rel_path), pattern):
                    if self.debug:
                        print(f"Debug: Skipping ignored pattern {pattern}: {file_path}")
                    return False

            # Check .gitignore if available
            if self.gitignore_matcher:
                try:
                    should_include = not self.gitignore_matcher(str(file_path))
                    if self.debug and not should_include:
                        print(f"Debug: Skipping gitignored file: {file_path}")
                    return should_include
                except Exception as e:
                    print(f"Warning: gitignore matching failed for {file_path}: {e}")
                    return True

            if self.debug:
                print(f"Debug: Including file: {file_path}")
            return True

        except Exception as e:
            print(f"Warning: Error checking file {file_path}: {e}")
            return False

    def _get_file_content(self, file_path: Path) -> str:
        """Read file content with proper encoding handling"""
        try:
            # Try UTF-8 first
            with open(file_path, 'r', encoding='utf-8') as f:
                return f.read()
        except UnicodeDecodeError:
            try:
                # Fallback to latin-1
                with open(file_path, 'r', encoding='latin-1') as f:
                    return f.read()
            except Exception as e:
                print(f"Warning: Failed to read {file_path}: {e}")
                return f"ERROR: Could not read file {file_path}\n"

    def _generate_directory_structure(self) -> str:
        """Generate a tree-like directory structure"""
        structure = ["Directory Structure:", ""]

        def add_to_tree(path: Path, prefix: str = ""):
            # Skip excluded directories
            excluded_dirs = {
                '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
                '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
                'dist', 'build', 'target'
            }
            if path.name in excluded_dirs:
                return

            # Add files first
            files = sorted([p for p in path.iterdir() if p.is_file()])
            included_files = [f for f in files if self._should_include_file(f)]

            for idx, file in enumerate(included_files):
                is_last = idx == len(included_files) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {file.name}")

            # Then add directories
            dirs = sorted([p for p in path.iterdir() if p.is_dir()])
            included_dirs = [d for d in dirs if d.name not in excluded_dirs]

            for idx, dir in enumerate(included_dirs):
                is_last = idx == len(included_dirs) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {dir.name}/")
                add_to_tree(dir, prefix + ("    " if is_last else "│   "))

        add_to_tree(self.project_path)
        return "\n".join(structure)

    def concatenate(self, debug: bool = False):
        """Main method to concatenate all source files"""
        self.debug = debug
        if not self.project_path.exists():
            print(f"Error: Project path {self.project_path} does not exist")
            return False

        try:
            with open(self.output_file, 'w', encoding='utf-8') as out:
                # Write header
                header = f"""
# Project Source Code Concatenation
# Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
# Project path: {self.project_path}

"""
                out.write(header)

                # Write directory structure if enabled
                if self.include_structure:
                    out.write(self._generate_directory_structure())
                    out.write("\n\n" + "="*80 + "\n\n")

                # Process all files
                file_count = 0
                for file_path in self.project_path.rglob('*'):
                    if file_path.is_file() and self._should_include_file(file_path):
                        rel_path = file_path.relative_to(self.project_path)

                        # Write file header
                        out.write(f"\n\n# File: {rel_path}\n")
                        out.write("="*80 + "\n\n")

                        # Write file content
                        content = self._get_file_content(file_path)
                        out.write(content)
                        file_count += 1

                print(f"Successfully melted {file_count} files to {self.output_file}")
                return True

        except Exception as e:
            print(f"Error during melting: {e}")
            return False

def main():
    parser = argparse.ArgumentParser(
        description="CodeSmelt: Melt down your git project's source code into a single file",
        usage="%(prog)s project_path [output_file] [-o OUTPUT] [-d] [-n]"
    )

    # Add the project path as required positional argument
    parser.add_argument(
        "project_path",
        help="Path to the git project directory"
    )

    # Add optional positional argument for output file
    parser.add_argument(
        "output_file",
        nargs="?",  # Make it optional
        help="Output file path (alternative to -o)",
        default=None
    )

    # Keep the original -o option for backward compatibility
    parser.add_argument(
        "-o", "--output",
        help="Output file path (default: concatenated_source.txt)",
        default=None
    )

    parser.add_argument(
        "-d", "--debug",
        action="store_true",
        help="Enable debug logging"
    )

    parser.add_argument(
        "-n", "--no-structure",
        action="store_true",
        help="Omit directory structure from output"
    )

    args = parser.parse_args()

    # Determine the output file path, prioritizing command line arguments
    output_file = args.output or args.output_file or "concatenated_source.txt"

    concatenator = CodeSmelt(args.project_path, output_file)
    concatenator.include_structure = not args.no_structure
    success = concatenator.concatenate(debug=args.debug)
    sys.exit(0 if success else 1)

if __name__ == "__main__":
    main()

# File: test_with_structure.txt
================================================================================


# Project Source Code Concatenation
# Generated on: 2025-02-15 23:26:14
# Project path: /home/runner/workspace

Directory Structure:

├── README.md
├── codesmelt.py
├── extensions.py
├── pyproject.toml
├── requirements.txt
└── test_with_structure.txt
└── assets/

================================================================================



# File: extensions.py
================================================================================

"""
Source code file extension configurations
"""

# Common source code file extensions
SOURCE_EXTENSIONS = {
    # Web
    '.js', '.ts', '.jsx', '.tsx', '.vue', '.svelte',
    '.html', '.htm', '.css', '.scss', '.sass', '.less',
    
    # Python
    '.py', '.pyi', '.pyx',
    
    # Java/Kotlin
    '.java', '.kt', '.groovy',
    
    # C-family
    '.c', '.cpp', '.h', '.hpp', '.cc',
    
    # C#
    '.cs', '.cshtml', '.csx',
    
    # Ruby
    '.rb', '.erb',
    
    # PHP
    '.php', '.php5', '.phtml',
    
    # Go
    '.go',
    
    # Rust
    '.rs',
    
    # Swift
    '.swift',
    
    # Shell
    '.sh', '.bash', '.zsh',
    
    # Config/Data
    '.json', '.yaml', '.yml', '.toml', '.xml',
    '.conf', '.ini', '.env',
    
    # Documentation
    '.md', '.rst', '.txt'
}

# Files to always ignore
IGNORE_PATTERNS = {
    # Build outputs
    'build/*', 'dist/*', 'target/*', 'bin/*',
    '*.pyc', '__pycache__/*', '*.class',
    
    # Dependencies
    'node_modules/*', 'vendor/*', 'venv/*',
    
    # IDE files
    '.idea/*', '.vscode/*', '*.swp',
    
    # Package files
    'package-lock.json', 'yarn.lock',
    'Pipfile.lock', 'poetry.lock',
    
    # Large data files
    '*.csv', '*.json.gz', '*.sql',
    
    # Binary/Media files
    '*.pdf', '*.jpg', '*.png', '*.gif',
    '*.mp3', '*.mp4', '*.mov', '*.bin',
    '*.exe', '*.dll', '*.so', '*.dylib'
}


# File: pyproject.toml
================================================================================

[project]
name = "repl-nix-workspace"
version = "0.1.0"
description = "Add your description here"
requires-python = ">=3.11"
dependencies = [
    "gitignore-parser>=0.1.11",
]


# File: requirements.txt
================================================================================

gitignore_parser==0.1.11

# File: README.md
================================================================================

# CodeSmelt: Source Code Concatenator

![CodeSmelt Logo](assets/CodeSmeltLogo.jpg)

**CodeSmelt** is a command-line tool that “melts down” your Git project’s source code into a single, well-organized file. It not only concatenates source files but also embeds a tree-like directory structure to help you quickly understand your project’s layout. This is especially useful for code analysis, preparing inputs for language models, or sharing project snapshots.

---

## Table of Contents

- [Features](#features)
- [Installation](#installation)
- [Usage](#usage)
  - [Basic Usage](#basic-usage)
  - [Custom Output & Debug Mode](#custom-output--debug-mode)
- [Configuration](#configuration)
  - [Source File Extensions](#source-file-extensions)
  - [Ignore Patterns](#ignore-patterns)
- [Tips for Using with LLMs](#tips-for-using-with-llms)
- [Troubleshooting](#troubleshooting)
- [Contributing](#contributing)
- [License](#license)
- [Author](#author)

---

## Features

- **Concatenation with Context:** Combines all source files (with supported extensions) into one file while preserving directory hierarchy.
- **Smart Filtering:** Uses built-in file extension whitelists and ignore patterns. Also honors your project’s `.gitignore` for extra filtering.
- **Encoding Handling:** Automatically handles file encoding issues (tries UTF-8 first, then falls back to Latin-1).
- **Debug Logging:** Option to enable debug logging so you can see which files are being included or skipped.
- **Easy Customization:** Adjust supported file extensions and ignore patterns via the `extensions.py` file.

---

## Installation

1. **Clone the Repository:**

   ```bash
   git clone https://github.com/yourusername/codesmelt.git
   cd codesmelt
   ```

2. **Install Dependencies:**

   CodeSmelt requires Python 3. Instead of installing dependencies individually, you can install all required packages using the `requirements.txt` file:

   ```bash
   pip install -r requirements.txt
   ```

   *(If you use a virtual environment, activate it before installing.)*

3. **Ensure File Structure:**

   Make sure the following files are in the same directory:
   
   - `codesmelt.py`
   - `extensions.py`
   - `README.md`
   - `requirements.txt`
   - `assets/CodeSmeltLogo.jpg` (logo image)

---

## Usage

### Basic Usage

Run CodeSmelt by providing the path to your Git project. For example:

```bash
python codesmelt.py /path/to/project
```

### Custom Output & Debug Mode

- **Specify a Custom Output File:**

  ```bash
  python codesmelt.py -o output.txt /path/to/project
  ```

- **Enable Debug Logging:**

  ```bash
  python codesmelt.py -d -o output.txt /path/to/project
  ```

#### Command-line Arguments

- `project_path` (required): Path to your Git project directory.
- `-o, --output`: Specify the output file path (default: `concatenated_source.txt`).
- `-d, --debug`: Enable debug logging to get detailed information about file selection.

---

## Configuration

CodeSmelt uses the `extensions.py` file to define:

### Source File Extensions

The tool automatically includes many common source code file extensions. Examples include:

- **Web:** `.js`, `.ts`, `.jsx`, `.tsx`, `.vue`, `.svelte`, `.html`, `.css`, etc.
- **Python:** `.py`, `.pyi`, `.pyx`
- **Java/Kotlin:** `.java`, `.kt`, `.groovy`
- **C-family:** `.c`, `.cpp`, `.h`, `.hpp`
- **Other Languages:** Ruby (`.rb`), PHP (`.php`), Go (`.go`), Rust (`.rs`), Swift (`.swift`), Shell (`.sh`), and more.

*To add or remove extensions, edit the `SOURCE_EXTENSIONS` set in `extensions.py`.*

### Ignore Patterns

Files and directories are automatically ignored based on three levels:

1. **Built-in Patterns:** Defined in the `IGNORE_PATTERNS` set in `extensions.py` (e.g., build outputs, dependency directories, IDE files, binary/media files).
2. **Project’s `.gitignore`:** If a `.gitignore` is present at the root of your project, CodeSmelt honors its rules.
3. **Directory-specific Rules:** Additional `.gitignore` files in subdirectories will also be considered.

*To customize, modify the `IGNORE_PATTERNS` in `extensions.py`.*

Example of adding Unity3D-specific ignores:

```python
IGNORE_PATTERNS = {
    # ... existing patterns ...
    'Assets/AssetStoreTools/*',
    'Library/*',
    'Temp/*',
    'Logs/*',
    '*.unity',  # Unity scene files
    '*.meta',   # Unity meta files
    '*.prefab', # Unity prefab files
    # ... other patterns ...
}
```

---

## Tips for Using with LLMs

1. **Token Management:**
   - For very large projects, consider concatenating only specific directories to avoid token limits.
   - Use debug mode (`-d`) to verify which files are included/excluded.

2. **Effective Prompting:**
   - Reference files using their relative paths as shown in the generated directory structure.
   - Ask questions about specific sections of the output using the file headers.

3. **Best Practices:**
   - Always review the concatenated output before sending it to an LLM.
   - For large projects, consider breaking down the analysis into smaller, manageable components.

---

## Troubleshooting

### Common Issues

1. **No Files Found:**
   - Double-check the project path.
   - Ensure your project contains files with supported extensions.
   - Run with `--debug` to see detailed file filtering information.

2. **Missing Dependencies:**
   - Make sure you have installed all required packages by running:
     
     ```bash
     pip install -r requirements.txt
     ```

3. **Permission Issues:**
   - Make sure you have read permissions for the project directory and write permissions for the output file.

---

## Contributing

Contributions are welcome! If you have ideas for improvements, bug fixes, or additional features, please fork the repository and submit a pull request. For major changes, please open an issue first to discuss what you would like to change.

---

## License

This project is licensed under the [MIT License](LICENSE).

---

## Author

**Shiraz Akmal**

Feel free to reach out if you have any questions or feedback!

---

Happy coding with CodeSmelt!

# File: codesmelt.py
================================================================================

#!/usr/bin/env python3
"""
CodeSmelt: Source Code Concatenator

This tool melts down source code files from a git project into a single file,
including directory structure information.
"""

import argparse
import sys
from pathlib import Path
import os
from typing import Set, List, Optional
import fnmatch
from datetime import datetime
import gitignore_parser
from extensions import SOURCE_EXTENSIONS, IGNORE_PATTERNS

class CodeSmelt:
    def __init__(self, project_path: str, output_file: str):
        self.project_path = Path(project_path).resolve()
        self.output_file = Path(output_file)
        self.gitignore_matcher = self._setup_gitignore()
        self.debug = False
        self.include_structure = True

    def _setup_gitignore(self) -> Optional[callable]:
        """Setup gitignore matcher if .gitignore exists"""
        gitignore_path = self.project_path / '.gitignore'
        if gitignore_path.exists():
            try:
                return gitignore_parser.parse_gitignore(gitignore_path)
            except Exception as e:
                print(f"Warning: Failed to parse .gitignore: {e}")
        return None

    def _should_include_file(self, file_path: Path) -> bool:
        """Check if file should be included based on extension and ignore rules"""
        # Skip common virtual environment and system directories
        excluded_dirs = {
            '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
            '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
            'dist', 'build', 'target'
        }

        try:
            # Convert to relative path for checking
            try:
                rel_path = file_path.relative_to(self.project_path)
            except ValueError:
                if self.debug:
                    print(f"Debug: Skipping file outside project path: {file_path}")
                return False

            # Check for excluded directories in the path
            if any(part in excluded_dirs for part in file_path.parts):
                if self.debug:
                    print(f"Debug: Skipping excluded directory: {file_path}")
                return False

            # Check if file extension is in whitelist
            if file_path.suffix.lower() not in SOURCE_EXTENSIONS:
                if self.debug:
                    print(f"Debug: Skipping non-source file: {file_path}")
                return False

            # Check custom ignore patterns
            for pattern in IGNORE_PATTERNS:
                if fnmatch.fnmatch(str(rel_path), pattern):
                    if self.debug:
                        print(f"Debug: Skipping ignored pattern {pattern}: {file_path}")
                    return False

            # Check .gitignore if available
            if self.gitignore_matcher:
                try:
                    should_include = not self.gitignore_matcher(str(file_path))
                    if self.debug and not should_include:
                        print(f"Debug: Skipping gitignored file: {file_path}")
                    return should_include
                except Exception as e:
                    print(f"Warning: gitignore matching failed for {file_path}: {e}")
                    return True

            if self.debug:
                print(f"Debug: Including file: {file_path}")
            return True

        except Exception as e:
            print(f"Warning: Error checking file {file_path}: {e}")
            return False

    def _get_file_content(self, file_path: Path) -> str:
        """Read file content with proper encoding handling"""
        try:
            # Try UTF-8 first
            with open(file_path, 'r', encoding='utf-8') as f:
                return f.read()
        except UnicodeDecodeError:
            try:
                # Fallback to latin-1
                with open(file_path, 'r', encoding='latin-1') as f:
                    return f.read()
            except Exception as e:
                print(f"Warning: Failed to read {file_path}: {e}")
                return f"ERROR: Could not read file {file_path}\n"

    def _generate_directory_structure(self) -> str:
        """Generate a tree-like directory structure"""
        structure = ["Directory Structure:", ""]

        def add_to_tree(path: Path, prefix: str = ""):
            # Skip excluded directories
            excluded_dirs = {
                '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
                '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
                'dist', 'build', 'target'
            }
            if path.name in excluded_dirs:
                return

            # Add files first
            files = sorted([p for p in path.iterdir() if p.is_file()])
            included_files = [f for f in files if self._should_include_file(f)]

            for idx, file in enumerate(included_files):
                is_last = idx == len(included_files) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {file.name}")

            # Then add directories
            dirs = sorted([p for p in path.iterdir() if p.is_dir()])
            included_dirs = [d for d in dirs if d.name not in excluded_dirs]

            for idx, dir in enumerate(included_dirs):
                is_last = idx == len(included_dirs) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {dir.name}/")
                add_to_tree(dir, prefix + ("    " if is_last else "│   "))

        add_to_tree(self.project_path)
        return "\n".join(structure)

    def concatenate(self, debug: bool = False):
        """Main method to concatenate all source files"""
        self.debug = debug
        if not self.project_path.exists():
            print(f"Error: Project path {self.project_path} does not exist")
            return False

        try:
            with open(self.output_file, 'w', encoding='utf-8') as out:
                # Write header
                header = f"""
# Project Source Code Concatenation
# Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
# Project path: {self.project_path}

"""
                out.write(header)

                # Write directory structure if enabled
                if self.include_structure:
                    out.write(self._generate_directory_structure())
                    out.write("\n\n" + "="*80 + "\n\n")

                # Process all files
                file_count = 0
                for file_path in self.project_path.rglob('*'):
                    if file_path.is_file() and self._should_include_file(file_path):
                        rel_path = file_path.relative_to(self.project_path)

                        # Write file header
                        out.write(f"\n\n# File: {rel_path}\n")
                        out.write("="*80 + "\n\n")

                        # Write file content
                        content = self._get_file_content(file_path)
                        out.write(content)
                        file_count += 1

                print(f"Successfully melted {file_count} files to {self.output_file}")
                return True

        except Exception as e:
            print(f"Error during melting: {e}")
            return False

def main():
    parser = argparse.ArgumentParser(
        description="CodeSmelt: Melt down your git project's source code into a single file",
        usage="%(prog)s project_path [output_file] [-o OUTPUT] [-d] [-n]"
    )

    # Add the project path as required positional argument
    parser.add_argument(
        "project_path",
        help="Path to the git project directory"
    )

    # Add optional positional argument for output file
    parser.add_argument(
        "output_file",
        nargs="?",  # Make it optional
        help="Output file path (alternative to -o)",
        default=None
    )

    # Keep the original -o option for backward compatibility
    parser.add_argument(
        "-o", "--output",
        help="Output file path (default: concatenated_source.txt)",
        default=None
    )

    parser.add_argument(
        "-d", "--debug",
        action="store_true",
        help="Enable debug logging"
    )

    parser.add_argument(
        "-n", "--no-structure",
        action="store_true",
        help="Omit directory structure from output"
    )

    args = parser.parse_args()

    # Determine the output file path, prioritizing command line arguments
    output_file = args.output or args.output_file or "concatenated_source.txt"

    concatenator = CodeSmelt(args.project_path, output_file)
    concatenator.include_structure = not args.no_structure
    success = concatenator.concatenate(debug=args.debug)
    sys.exit(0 if success else 1)

if __name__ == "__main__":
    main()

# File: test_without_structure.txt
================================================================================


# Project Source Code Concatenation
# Generated on: 2025-02-15 23:26:14
# Project path: /home/runner/workspace



# File: extensions.py
================================================================================

"""
Source code file extension configurations
"""

# Common source code file extensions
SOURCE_EXTENSIONS = {
    # Web
    '.js', '.ts', '.jsx', '.tsx', '.vue', '.svelte',
    '.html', '.htm', '.css', '.scss', '.sass', '.less',
    
    # Python
    '.py', '.pyi', '.pyx',
    
    # Java/Kotlin
    '.java', '.kt', '.groovy',
    
    # C-family
    '.c', '.cpp', '.h', '.hpp', '.cc',
    
    # C#
    '.cs', '.cshtml', '.csx',
    
    # Ruby
    '.rb', '.erb',
    
    # PHP
    '.php', '.php5', '.phtml',
    
    # Go
    '.go',
    
    # Rust
    '.rs',
    
    # Swift
    '.swift',
    
    # Shell
    '.sh', '.bash', '.zsh',
    
    # Config/Data
    '.json', '.yaml', '.yml', '.toml', '.xml',
    '.conf', '.ini', '.env',
    
    # Documentation
    '.md', '.rst', '.txt'
}

# Files to always ignore
IGNORE_PATTERNS = {
    # Build outputs
    'build/*', 'dist/*', 'target/*', 'bin/*',
    '*.pyc', '__pycache__/*', '*.class',
    
    # Dependencies
    'node_modules/*', 'vendor/*', 'venv/*',
    
    # IDE files
    '.idea/*', '.vscode/*', '*.swp',
    
    # Package files
    'package-lock.json', 'yarn.lock',
    'Pipfile.lock', 'poetry.lock',
    
    # Large data files
    '*.csv', '*.json.gz', '*.sql',
    
    # Binary/Media files
    '*.pdf', '*.jpg', '*.png', '*.gif',
    '*.mp3', '*.mp4', '*.mov', '*.bin',
    '*.exe', '*.dll', '*.so', '*.dylib'
}


# File: pyproject.toml
================================================================================

[project]
name = "repl-nix-workspace"
version = "0.1.0"
description = "Add your description here"
requires-python = ">=3.11"
dependencies = [
    "gitignore-parser>=0.1.11",
]


# File: requirements.txt
================================================================================

gitignore_parser==0.1.11

# File: README.md
================================================================================

# CodeSmelt: Source Code Concatenator

![CodeSmelt Logo](assets/CodeSmeltLogo.jpg)

**CodeSmelt** is a command-line tool that “melts down” your Git project’s source code into a single, well-organized file. It not only concatenates source files but also embeds a tree-like directory structure to help you quickly understand your project’s layout. This is especially useful for code analysis, preparing inputs for language models, or sharing project snapshots.

---

## Table of Contents

- [Features](#features)
- [Installation](#installation)
- [Usage](#usage)
  - [Basic Usage](#basic-usage)
  - [Custom Output & Debug Mode](#custom-output--debug-mode)
- [Configuration](#configuration)
  - [Source File Extensions](#source-file-extensions)
  - [Ignore Patterns](#ignore-patterns)
- [Tips for Using with LLMs](#tips-for-using-with-llms)
- [Troubleshooting](#troubleshooting)
- [Contributing](#contributing)
- [License](#license)
- [Author](#author)

---

## Features

- **Concatenation with Context:** Combines all source files (with supported extensions) into one file while preserving directory hierarchy.
- **Smart Filtering:** Uses built-in file extension whitelists and ignore patterns. Also honors your project’s `.gitignore` for extra filtering.
- **Encoding Handling:** Automatically handles file encoding issues (tries UTF-8 first, then falls back to Latin-1).
- **Debug Logging:** Option to enable debug logging so you can see which files are being included or skipped.
- **Easy Customization:** Adjust supported file extensions and ignore patterns via the `extensions.py` file.

---

## Installation

1. **Clone the Repository:**

   ```bash
   git clone https://github.com/yourusername/codesmelt.git
   cd codesmelt
   ```

2. **Install Dependencies:**

   CodeSmelt requires Python 3. Instead of installing dependencies individually, you can install all required packages using the `requirements.txt` file:

   ```bash
   pip install -r requirements.txt
   ```

   *(If you use a virtual environment, activate it before installing.)*

3. **Ensure File Structure:**

   Make sure the following files are in the same directory:
   
   - `codesmelt.py`
   - `extensions.py`
   - `README.md`
   - `requirements.txt`
   - `assets/CodeSmeltLogo.jpg` (logo image)

---

## Usage

### Basic Usage

Run CodeSmelt by providing the path to your Git project. For example:

```bash
python codesmelt.py /path/to/project
```

### Custom Output & Debug Mode

- **Specify a Custom Output File:**

  ```bash
  python codesmelt.py -o output.txt /path/to/project
  ```

- **Enable Debug Logging:**

  ```bash
  python codesmelt.py -d -o output.txt /path/to/project
  ```

#### Command-line Arguments

- `project_path` (required): Path to your Git project directory.
- `-o, --output`: Specify the output file path (default: `concatenated_source.txt`).
- `-d, --debug`: Enable debug logging to get detailed information about file selection.

---

## Configuration

CodeSmelt uses the `extensions.py` file to define:

### Source File Extensions

The tool automatically includes many common source code file extensions. Examples include:

- **Web:** `.js`, `.ts`, `.jsx`, `.tsx`, `.vue`, `.svelte`, `.html`, `.css`, etc.
- **Python:** `.py`, `.pyi`, `.pyx`
- **Java/Kotlin:** `.java`, `.kt`, `.groovy`
- **C-family:** `.c`, `.cpp`, `.h`, `.hpp`
- **Other Languages:** Ruby (`.rb`), PHP (`.php`), Go (`.go`), Rust (`.rs`), Swift (`.swift`), Shell (`.sh`), and more.

*To add or remove extensions, edit the `SOURCE_EXTENSIONS` set in `extensions.py`.*

### Ignore Patterns

Files and directories are automatically ignored based on three levels:

1. **Built-in Patterns:** Defined in the `IGNORE_PATTERNS` set in `extensions.py` (e.g., build outputs, dependency directories, IDE files, binary/media files).
2. **Project’s `.gitignore`:** If a `.gitignore` is present at the root of your project, CodeSmelt honors its rules.
3. **Directory-specific Rules:** Additional `.gitignore` files in subdirectories will also be considered.

*To customize, modify the `IGNORE_PATTERNS` in `extensions.py`.*

Example of adding Unity3D-specific ignores:

```python
IGNORE_PATTERNS = {
    # ... existing patterns ...
    'Assets/AssetStoreTools/*',
    'Library/*',
    'Temp/*',
    'Logs/*',
    '*.unity',  # Unity scene files
    '*.meta',   # Unity meta files
    '*.prefab', # Unity prefab files
    # ... other patterns ...
}
```

---

## Tips for Using with LLMs

1. **Token Management:**
   - For very large projects, consider concatenating only specific directories to avoid token limits.
   - Use debug mode (`-d`) to verify which files are included/excluded.

2. **Effective Prompting:**
   - Reference files using their relative paths as shown in the generated directory structure.
   - Ask questions about specific sections of the output using the file headers.

3. **Best Practices:**
   - Always review the concatenated output before sending it to an LLM.
   - For large projects, consider breaking down the analysis into smaller, manageable components.

---

## Troubleshooting

### Common Issues

1. **No Files Found:**
   - Double-check the project path.
   - Ensure your project contains files with supported extensions.
   - Run with `--debug` to see detailed file filtering information.

2. **Missing Dependencies:**
   - Make sure you have installed all required packages by running:
     
     ```bash
     pip install -r requirements.txt
     ```

3. **Permission Issues:**
   - Make sure you have read permissions for the project directory and write permissions for the output file.

---

## Contributing

Contributions are welcome! If you have ideas for improvements, bug fixes, or additional features, please fork the repository and submit a pull request. For major changes, please open an issue first to discuss what you would like to change.

---

## License

This project is licensed under the [MIT License](LICENSE).

---

## Author

**Shiraz Akmal**

Feel free to reach out if you have any questions or feedback!

---

Happy coding with CodeSmelt!

# File: codesmelt.py
================================================================================

#!/usr/bin/env python3
"""
CodeSmelt: Source Code Concatenator

This tool melts down source code files from a git project into a single file,
including directory structure information.
"""

import argparse
import sys
from pathlib import Path
import os
from typing import Set, List, Optional
import fnmatch
from datetime import datetime
import gitignore_parser
from extensions import SOURCE_EXTENSIONS, IGNORE_PATTERNS

class CodeSmelt:
    def __init__(self, project_path: str, output_file: str):
        self.project_path = Path(project_path).resolve()
        self.output_file = Path(output_file)
        self.gitignore_matcher = self._setup_gitignore()
        self.debug = False
        self.include_structure = True

    def _setup_gitignore(self) -> Optional[callable]:
        """Setup gitignore matcher if .gitignore exists"""
        gitignore_path = self.project_path / '.gitignore'
        if gitignore_path.exists():
            try:
                return gitignore_parser.parse_gitignore(gitignore_path)
            except Exception as e:
                print(f"Warning: Failed to parse .gitignore: {e}")
        return None

    def _should_include_file(self, file_path: Path) -> bool:
        """Check if file should be included based on extension and ignore rules"""
        # Skip common virtual environment and system directories
        excluded_dirs = {
            '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
            '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
            'dist', 'build', 'target'
        }

        try:
            # Convert to relative path for checking
            try:
                rel_path = file_path.relative_to(self.project_path)
            except ValueError:
                if self.debug:
                    print(f"Debug: Skipping file outside project path: {file_path}")
                return False

            # Check for excluded directories in the path
            if any(part in excluded_dirs for part in file_path.parts):
                if self.debug:
                    print(f"Debug: Skipping excluded directory: {file_path}")
                return False

            # Check if file extension is in whitelist
            if file_path.suffix.lower() not in SOURCE_EXTENSIONS:
                if self.debug:
                    print(f"Debug: Skipping non-source file: {file_path}")
                return False

            # Check custom ignore patterns
            for pattern in IGNORE_PATTERNS:
                if fnmatch.fnmatch(str(rel_path), pattern):
                    if self.debug:
                        print(f"Debug: Skipping ignored pattern {pattern}: {file_path}")
                    return False

            # Check .gitignore if available
            if self.gitignore_matcher:
                try:
                    should_include = not self.gitignore_matcher(str(file_path))
                    if self.debug and not should_include:
                        print(f"Debug: Skipping gitignored file: {file_path}")
                    return should_include
                except Exception as e:
                    print(f"Warning: gitignore matching failed for {file_path}: {e}")
                    return True

            if self.debug:
                print(f"Debug: Including file: {file_path}")
            return True

        except Exception as e:
            print(f"Warning: Error checking file {file_path}: {e}")
            return False

    def _get_file_content(self, file_path: Path) -> str:
        """Read file content with proper encoding handling"""
        try:
            # Try UTF-8 first
            with open(file_path, 'r', encoding='utf-8') as f:
                return f.read()
        except UnicodeDecodeError:
            try:
                # Fallback to latin-1
                with open(file_path, 'r', encoding='latin-1') as f:
                    return f.read()
            except Exception as e:
                print(f"Warning: Failed to read {file_path}: {e}")
                return f"ERROR: Could not read file {file_path}\n"

    def _generate_directory_structure(self) -> str:
        """Generate a tree-like directory structure"""
        structure = ["Directory Structure:", ""]

        def add_to_tree(path: Path, prefix: str = ""):
            # Skip excluded directories
            excluded_dirs = {
                '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
                '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
                'dist', 'build', 'target'
            }
            if path.name in excluded_dirs:
                return

            # Add files first
            files = sorted([p for p in path.iterdir() if p.is_file()])
            included_files = [f for f in files if self._should_include_file(f)]

            for idx, file in enumerate(included_files):
                is_last = idx == len(included_files) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {file.name}")

            # Then add directories
            dirs = sorted([p for p in path.iterdir() if p.is_dir()])
            included_dirs = [d for d in dirs if d.name not in excluded_dirs]

            for idx, dir in enumerate(included_dirs):
                is_last = idx == len(included_dirs) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {dir.name}/")
                add_to_tree(dir, prefix + ("    " if is_last else "│   "))

        add_to_tree(self.project_path)
        return "\n".join(structure)

    def concatenate(self, debug: bool = False):
        """Main method to concatenate all source files"""
        self.debug = debug
        if not self.project_path.exists():
            print(f"Error: Project path {self.project_path} does not exist")
            return False

        try:
            with open(self.output_file, 'w', encoding='utf-8') as out:
                # Write header
                header = f"""
# Project Source Code Concatenation
# Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
# Project path: {self.project_path}

"""
                out.write(header)

                # Write directory structure if enabled
                if self.include_structure:
                    out.write(self._generate_directory_structure())
                    out.write("\n\n" + "="*80 + "\n\n")

                # Process all files
                file_count = 0
                for file_path in self.project_path.rglob('*'):
                    if file_path.is_file() and self._should_include_file(file_path):
                        rel_path = file_path.relative_to(self.project_path)

                        # Write file header
                        out.write(f"\n\n# File: {rel_path}\n")
                        out.write("="*80 + "\n\n")

                        # Write file content
                        content = self._get_file_content(file_path)
                        out.write(content)
                        file_count += 1

                print(f"Successfully melted {file_count} files to {self.output_file}")
                return True

        except Exception as e:
            print(f"Error during melting: {e}")
            return False

def main():
    parser = argparse.ArgumentParser(
        description="CodeSmelt: Melt down your git project's source code into a single file",
        usage="%(prog)s project_path [output_file] [-o OUTPUT] [-d] [-n]"
    )

    # Add the project path as required positional argument
    parser.add_argument(
        "project_path",
        help="Path to the git project directory"
    )

    # Add optional positional argument for output file
    parser.add_argument(
        "output_file",
        nargs="?",  # Make it optional
        help="Output file path (alternative to -o)",
        default=None
    )

    # Keep the original -o option for backward compatibility
    parser.add_argument(
        "-o", "--output",
        help="Output file path (default: concatenated_source.txt)",
        default=None
    )

    parser.add_argument(
        "-d", "--debug",
        action="store_true",
        help="Enable debug logging"
    )

    parser.add_argument(
        "-n", "--no-structure",
        action="store_true",
        help="Omit directory structure from output"
    )

    args = parser.parse_args()

    # Determine the output file path, prioritizing command line arguments
    output_file = args.output or args.output_file or "concatenated_source.txt"

    concatenator = CodeSmelt(args.project_path, output_file)
    concatenator.include_structure = not args.no_structure
    success = concatenator.concatenate(debug=args.debug)
    sys.exit(0 if success else 1)

if __name__ == "__main__":
    main()

# File: test_with_structure.txt
================================================================================


# Project Source Code Concatenation
# Generated on: 2025-02-15 23:26:14
# Project path: /home/runner/workspace

Directory Structure:

├── README.md
├── codesmelt.py
├── extensions.py
├── pyproject.toml
├── requirements.txt
└── test_with_structure.txt
└── assets/

================================================================================



# File: extensions.py
================================================================================

"""
Source code file extension configurations
"""

# Common source code file extensions
SOURCE_EXTENSIONS = {
    # Web
    '.js', '.ts', '.jsx', '.tsx', '.vue', '.svelte',
    '.html', '.htm', '.css', '.scss', '.sass', '.less',
    
    # Python
    '.py', '.pyi', '.pyx',
    
    # Java/Kotlin
    '.java', '.kt', '.groovy',
    
    # C-family
    '.c', '.cpp', '.h', '.hpp', '.cc',
    
    # C#
    '.cs', '.cshtml', '.csx',
    
    # Ruby
    '.rb', '.erb',
    
    # PHP
    '.php', '.php5', '.phtml',
    
    # Go
    '.go',
    
    # Rust
    '.rs',
    
    # Swift
    '.swift',
    
    # Shell
    '.sh', '.bash', '.zsh',
    
    # Config/Data
    '.json', '.yaml', '.yml', '.toml', '.xml',
    '.conf', '.ini', '.env',
    
    # Documentation
    '.md', '.rst', '.txt'
}

# Files to always ignore
IGNORE_PATTERNS = {
    # Build outputs
    'build/*', 'dist/*', 'target/*', 'bin/*',
    '*.pyc', '__pycache__/*', '*.class',
    
    # Dependencies
    'node_modules/*', 'vendor/*', 'venv/*',
    
    # IDE files
    '.idea/*', '.vscode/*', '*.swp',
    
    # Package files
    'package-lock.json', 'yarn.lock',
    'Pipfile.lock', 'poetry.lock',
    
    # Large data files
    '*.csv', '*.json.gz', '*.sql',
    
    # Binary/Media files
    '*.pdf', '*.jpg', '*.png', '*.gif',
    '*.mp3', '*.mp4', '*.mov', '*.bin',
    '*.exe', '*.dll', '*.so', '*.dylib'
}


# File: pyproject.toml
================================================================================

[project]
name = "repl-nix-workspace"
version = "0.1.0"
description = "Add your description here"
requires-python = ">=3.11"
dependencies = [
    "gitignore-parser>=0.1.11",
]


# File: requirements.txt
================================================================================

gitignore_parser==0.1.11

# File: README.md
================================================================================

# CodeSmelt: Source Code Concatenator

![CodeSmelt Logo](assets/CodeSmeltLogo.jpg)

**CodeSmelt** is a command-line tool that “melts down” your Git project’s source code into a single, well-organized file. It not only concatenates source files but also embeds a tree-like directory structure to help you quickly understand your project’s layout. This is especially useful for code analysis, preparing inputs for language models, or sharing project snapshots.

---

## Table of Contents

- [Features](#features)
- [Installation](#installation)
- [Usage](#usage)
  - [Basic Usage](#basic-usage)
  - [Custom Output & Debug Mode](#custom-output--debug-mode)
- [Configuration](#configuration)
  - [Source File Extensions](#source-file-extensions)
  - [Ignore Patterns](#ignore-patterns)
- [Tips for Using with LLMs](#tips-for-using-with-llms)
- [Troubleshooting](#troubleshooting)
- [Contributing](#contributing)
- [License](#license)
- [Author](#author)

---

## Features

- **Concatenation with Context:** Combines all source files (with supported extensions) into one file while preserving directory hierarchy.
- **Smart Filtering:** Uses built-in file extension whitelists and ignore patterns. Also honors your project’s `.gitignore` for extra filtering.
- **Encoding Handling:** Automatically handles file encoding issues (tries UTF-8 first, then falls back to Latin-1).
- **Debug Logging:** Option to enable debug logging so you can see which files are being included or skipped.
- **Easy Customization:** Adjust supported file extensions and ignore patterns via the `extensions.py` file.

---

## Installation

1. **Clone the Repository:**

   ```bash
   git clone https://github.com/yourusername/codesmelt.git
   cd codesmelt
   ```

2. **Install Dependencies:**

   CodeSmelt requires Python 3. Instead of installing dependencies individually, you can install all required packages using the `requirements.txt` file:

   ```bash
   pip install -r requirements.txt
   ```

   *(If you use a virtual environment, activate it before installing.)*

3. **Ensure File Structure:**

   Make sure the following files are in the same directory:
   
   - `codesmelt.py`
   - `extensions.py`
   - `README.md`
   - `requirements.txt`
   - `assets/CodeSmeltLogo.jpg` (logo image)

---

## Usage

### Basic Usage

Run CodeSmelt by providing the path to your Git project. For example:

```bash
python codesmelt.py /path/to/project
```

### Custom Output & Debug Mode

- **Specify a Custom Output File:**

  ```bash
  python codesmelt.py -o output.txt /path/to/project
  ```

- **Enable Debug Logging:**

  ```bash
  python codesmelt.py -d -o output.txt /path/to/project
  ```

#### Command-line Arguments

- `project_path` (required): Path to your Git project directory.
- `-o, --output`: Specify the output file path (default: `concatenated_source.txt`).
- `-d, --debug`: Enable debug logging to get detailed information about file selection.

---

## Configuration

CodeSmelt uses the `extensions.py` file to define:

### Source File Extensions

The tool automatically includes many common source code file extensions. Examples include:

- **Web:** `.js`, `.ts`, `.jsx`, `.tsx`, `.vue`, `.svelte`, `.html`, `.css`, etc.
- **Python:** `.py`, `.pyi`, `.pyx`
- **Java/Kotlin:** `.java`, `.kt`, `.groovy`
- **C-family:** `.c`, `.cpp`, `.h`, `.hpp`
- **Other Languages:** Ruby (`.rb`), PHP (`.php`), Go (`.go`), Rust (`.rs`), Swift (`.swift`), Shell (`.sh`), and more.

*To add or remove extensions, edit the `SOURCE_EXTENSIONS` set in `extensions.py`.*

### Ignore Patterns

Files and directories are automatically ignored based on three levels:

1. **Built-in Patterns:** Defined in the `IGNORE_PATTERNS` set in `extensions.py` (e.g., build outputs, dependency directories, IDE files, binary/media files).
2. **Project’s `.gitignore`:** If a `.gitignore` is present at the root of your project, CodeSmelt honors its rules.
3. **Directory-specific Rules:** Additional `.gitignore` files in subdirectories will also be considered.

*To customize, modify the `IGNORE_PATTERNS` in `extensions.py`.*

Example of adding Unity3D-specific ignores:

```python
IGNORE_PATTERNS = {
    # ... existing patterns ...
    'Assets/AssetStoreTools/*',
    'Library/*',
    'Temp/*',
    'Logs/*',
    '*.unity',  # Unity scene files
    '*.meta',   # Unity meta files
    '*.prefab', # Unity prefab files
    # ... other patterns ...
}
```

---

## Tips for Using with LLMs

1. **Token Management:**
   - For very large projects, consider concatenating only specific directories to avoid token limits.
   - Use debug mode (`-d`) to verify which files are included/excluded.

2. **Effective Prompting:**
   - Reference files using their relative paths as shown in the generated directory structure.
   - Ask questions about specific sections of the output using the file headers.

3. **Best Practices:**
   - Always review the concatenated output before sending it to an LLM.
   - For large projects, consider breaking down the analysis into smaller, manageable components.

---

## Troubleshooting

### Common Issues

1. **No Files Found:**
   - Double-check the project path.
   - Ensure your project contains files with supported extensions.
   - Run with `--debug` to see detailed file filtering information.

2. **Missing Dependencies:**
   - Make sure you have installed all required packages by running:
     
     ```bash
     pip install -r requirements.txt
     ```

3. **Permission Issues:**
   - Make sure you have read permissions for the project directory and write permissions for the output file.

---

## Contributing

Contributions are welcome! If you have ideas for improvements, bug fixes, or additional features, please fork the repository and submit a pull request. For major changes, please open an issue first to discuss what you would like to change.

---

## License

This project is licensed under the [MIT License](LICENSE).

---

## Author

**Shiraz Akmal**

Feel free to reach out if you have any questions or feedback!

---

Happy coding with CodeSmelt!

# File: codesmelt.py
================================================================================

#!/usr/bin/env python3
"""
CodeSmelt: Source Code Concatenator

This tool melts down source code files from a git project into a single file,
including directory structure information.
"""

import argparse
import sys
from pathlib import Path
import os
from typing import Set, List, Optional
import fnmatch
from datetime import datetime
import gitignore_parser
from extensions import SOURCE_EXTENSIONS, IGNORE_PATTERNS

class CodeSmelt:
    def __init__(self, project_path: str, output_file: str):
        self.project_path = Path(project_path).resolve()
        self.output_file = Path(output_file)
        self.gitignore_matcher = self._setup_gitignore()
        self.debug = False
        self.include_structure = True

    def _setup_gitignore(self) -> Optional[callable]:
        """Setup gitignore matcher if .gitignore exists"""
        gitignore_path = self.project_path / '.gitignore'
        if gitignore_path.exists():
            try:
                return gitignore_parser.parse_gitignore(gitignore_path)
            except Exception as e:
                print(f"Warning: Failed to parse .gitignore: {e}")
        return None

    def _should_include_file(self, file_path: Path) -> bool:
        """Check if file should be included based on extension and ignore rules"""
        # Skip common virtual environment and system directories
        excluded_dirs = {
            '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
            '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
            'dist', 'build', 'target'
        }

        try:
            # Convert to relative path for checking
            try:
                rel_path = file_path.relative_to(self.project_path)
            except ValueError:
                if self.debug:
                    print(f"Debug: Skipping file outside project path: {file_path}")
                return False

            # Check for excluded directories in the path
            if any(part in excluded_dirs for part in file_path.parts):
                if self.debug:
                    print(f"Debug: Skipping excluded directory: {file_path}")
                return False

            # Check if file extension is in whitelist
            if file_path.suffix.lower() not in SOURCE_EXTENSIONS:
                if self.debug:
                    print(f"Debug: Skipping non-source file: {file_path}")
                return False

            # Check custom ignore patterns
            for pattern in IGNORE_PATTERNS:
                if fnmatch.fnmatch(str(rel_path), pattern):
                    if self.debug:
                        print(f"Debug: Skipping ignored pattern {pattern}: {file_path}")
                    return False

            # Check .gitignore if available
            if self.gitignore_matcher:
                try:
                    should_include = not self.gitignore_matcher(str(file_path))
                    if self.debug and not should_include:
                        print(f"Debug: Skipping gitignored file: {file_path}")
                    return should_include
                except Exception as e:
                    print(f"Warning: gitignore matching failed for {file_path}: {e}")
                    return True

            if self.debug:
                print(f"Debug: Including file: {file_path}")
            return True

        except Exception as e:
            print(f"Warning: Error checking file {file_path}: {e}")
            return False

    def _get_file_content(self, file_path: Path) -> str:
        """Read file content with proper encoding handling"""
        try:
            # Try UTF-8 first
            with open(file_path, 'r', encoding='utf-8') as f:
                return f.read()
        except UnicodeDecodeError:
            try:
                # Fallback to latin-1
                with open(file_path, 'r', encoding='latin-1') as f:
                    return f.read()
            except Exception as e:
                print(f"Warning: Failed to read {file_path}: {e}")
                return f"ERROR: Could not read file {file_path}\n"

    def _generate_directory_structure(self) -> str:
        """Generate a tree-like directory structure"""
        structure = ["Directory Structure:", ""]

        def add_to_tree(path: Path, prefix: str = ""):
            # Skip excluded directories
            excluded_dirs = {
                '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
                '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
                'dist', 'build', 'target'
            }
            if path.name in excluded_dirs:
                return

            # Add files first
            files = sorted([p for p in path.iterdir() if p.is_file()])
            included_files = [f for f in files if self._should_include_file(f)]

            for idx, file in enumerate(included_files):
                is_last = idx == len(included_files) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {file.name}")

            # Then add directories
            dirs = sorted([p for p in path.iterdir() if p.is_dir()])
            included_dirs = [d for d in dirs if d.name not in excluded_dirs]

            for idx, dir in enumerate(included_dirs):
                is_last = idx == len(included_dirs) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {dir.name}/")
                add_to_tree(dir, prefix + ("    " if is_last else "│   "))

        add_to_tree(self.project_path)
        return "\n".join(structure)

    def concatenate(self, debug: bool = False):
        """Main method to concatenate all source files"""
        self.debug = debug
        if not self.project_path.exists():
            print(f"Error: Project path {self.project_path} does not exist")
            return False

        try:
            with open(self.output_file, 'w', encoding='utf-8') as out:
                # Write header
                header = f"""
# Project Source Code Concatenation
# Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
# Project path: {self.project_path}

"""
                out.write(header)

                # Write directory structure if enabled
                if self.include_structure:
                    out.write(self._generate_directory_structure())
                    out.write("\n\n" + "="*80 + "\n\n")

                # Process all files
                file_count = 0
                for file_path in self.project_path.rglob('*'):
                    if file_path.is_file() and self._should_include_file(file_path):
                        rel_path = file_path.relative_to(self.project_path)

                        # Write file header
                        out.write(f"\n\n# File: {rel_path}\n")
                        out.write("="*80 + "\n\n")

                        # Write file content
                        content = self._get_file_content(file_path)
                        out.write(content)
                        file_count += 1

                print(f"Successfully melted {file_count} files to {self.output_file}")
                return True

        except Exception as e:
            print(f"Error during melting: {e}")
            return False

def main():
    parser = argparse.ArgumentParser(
        description="CodeSmelt: Melt down your git project's source code into a single file",
        usage="%(prog)s project_path [output_file] [-o OUTPUT] [-d] [-n]"
    )

    # Add the project path as required positional argument
    parser.add_argument(
        "project_path",
        help="Path to the git project directory"
    )

    # Add optional positional argument for output file
    parser.add_argument(
        "output_file",
        nargs="?",  # Make it optional
        help="Output file path (alternative to -o)",
        default=None
    )

    # Keep the original -o option for backward compatibility
    parser.add_argument(
        "-o", "--output",
        help="Output file path (default: concatenated_source.txt)",
        default=None
    )

    parser.add_argument(
        "-d", "--debug",
        action="store_true",
        help="Enable debug logging"
    )

    parser.add_argument(
        "-n", "--no-structure",
        action="store_true",
        help="Omit directory structure from output"
    )

    args = parser.parse_args()

    # Determine the output file path, prioritizing command line arguments
    output_file = args.output or args.output_file or "concatenated_source.txt"

    concatenator = CodeSmelt(args.project_path, output_file)
    concatenator.include_structure = not args.no_structure
    success = concatenator.concatenate(debug=args.debug)
    sys.exit(0 if success else 1)

if __name__ == "__main__":
    main()

# File: test_with_structure.txt
================================================================================


# Project Source Code Concatenation
# Generated on: 2025-02-15 23:26:14
# Project path: /home/runner/workspace

Directory Structure:

├── README.md
├── codesmelt.py
├── extensions.py
├── pyproject.toml
├── requirements.txt
└── test_with_structure.txt
└── assets/

================================================================================



# File: extensions.py
================================================================================

"""
Source code file extension configurations
"""

# Common source code file extensions
SOURCE_EXTENSIONS = {
    # Web
    '.js', '.ts', '.jsx', '.tsx', '.vue', '.svelte',
    '.html', '.htm', '.css', '.scss', '.sass', '.less',
    
    # Python
    '.py', '.pyi', '.pyx',
    
    # Java/Kotlin
    '.java', '.kt', '.groovy',
    
    # C-family
    '.c', '.cpp', '.h', '.hpp', '.cc',
    
    # C#
    '.cs', '.cshtml', '.csx',
    
    # Ruby
    '.rb', '.erb',
    
    # PHP
    '.php', '.php5', '.phtml',
    
    # Go
    '.go',
    
    # Rust
    '.rs',
    
    # Swift
    '.swift',
    
    # Shell
    '.sh', '.bash', '.zsh',
    
    # Config/Data
    '.json', '.yaml', '.yml', '.toml', '.xml',
    '.conf', '.ini', '.env',
    
    # Documentation
    '.md', '.rst', '.txt'
}

# Files to always ignore
IGNORE_PATTERNS = {
    # Build outputs
    'build/*', 'dist/*', 'target/*', 'bin/*',
    '*.pyc', '__pycache__/*', '*.class',
    
    # Dependencies
    'node_modules/*', 'vendor/*', 'venv/*',
    
    # IDE files
    '.idea/*', '.vscode/*', '*.swp',
    
    # Package files
    'package-lock.json', 'yarn.lock',
    'Pipfile.lock', 'poetry.lock',
    
    # Large data files
    '*.csv', '*.json.gz', '*.sql',
    
    # Binary/Media files
    '*.pdf', '*.jpg', '*.png', '*.gif',
    '*.mp3', '*.mp4', '*.mov', '*.bin',
    '*.exe', '*.dll', '*.so', '*.dylib'
}


# File: pyproject.toml
================================================================================

[project]
name = "repl-nix-workspace"
version = "0.1.0"
description = "Add your description here"
requires-python = ">=3.11"
dependencies = [
    "gitignore-parser>=0.1.11",
]


# File: requirements.txt
================================================================================

gitignore_parser==0.1.11

# File: README.md
================================================================================

# CodeSmelt: Source Code Concatenator

![CodeSmelt Logo](assets/CodeSmeltLogo.jpg)

**CodeSmelt** is a command-line tool that “melts down” your Git project’s source code into a single, well-organized file. It not only concatenates source files but also embeds a tree-like directory structure to help you quickly understand your project’s layout. This is especially useful for code analysis, preparing inputs for language models, or sharing project snapshots.

---

## Table of Contents

- [Features](#features)
- [Installation](#installation)
- [Usage](#usage)
  - [Basic Usage](#basic-usage)
  - [Custom Output & Debug Mode](#custom-output--debug-mode)
- [Configuration](#configuration)
  - [Source File Extensions](#source-file-extensions)
  - [Ignore Patterns](#ignore-patterns)
- [Tips for Using with LLMs](#tips-for-using-with-llms)
- [Troubleshooting](#troubleshooting)
- [Contributing](#contributing)
- [License](#license)
- [Author](#author)

---

## Features

- **Concatenation with Context:** Combines all source files (with supported extensions) into one file while preserving directory hierarchy.
- **Smart Filtering:** Uses built-in file extension whitelists and ignore patterns. Also honors your project’s `.gitignore` for extra filtering.
- **Encoding Handling:** Automatically handles file encoding issues (tries UTF-8 first, then falls back to Latin-1).
- **Debug Logging:** Option to enable debug logging so you can see which files are being included or skipped.
- **Easy Customization:** Adjust supported file extensions and ignore patterns via the `extensions.py` file.

---

## Installation

1. **Clone the Repository:**

   ```bash
   git clone https://github.com/yourusername/codesmelt.git
   cd codesmelt
   ```

2. **Install Dependencies:**

   CodeSmelt requires Python 3. Instead of installing dependencies individually, you can install all required packages using the `requirements.txt` file:

   ```bash
   pip install -r requirements.txt
   ```

   *(If you use a virtual environment, activate it before installing.)*

3. **Ensure File Structure:**

   Make sure the following files are in the same directory:
   
   - `codesmelt.py`
   - `extensions.py`
   - `README.md`
   - `requirements.txt`
   - `assets/CodeSmeltLogo.jpg` (logo image)

---

## Usage

### Basic Usage

Run CodeSmelt by providing the path to your Git project. For example:

```bash
python codesmelt.py /path/to/project
```

### Custom Output & Debug Mode

- **Specify a Custom Output File:**

  ```bash
  python codesmelt.py -o output.txt /path/to/project
  ```

- **Enable Debug Logging:**

  ```bash
  python codesmelt.py -d -o output.txt /path/to/project
  ```

#### Command-line Arguments

- `project_path` (required): Path to your Git project directory.
- `-o, --output`: Specify the output file path (default: `concatenated_source.txt`).
- `-d, --debug`: Enable debug logging to get detailed information about file selection.

---

## Configuration

CodeSmelt uses the `extensions.py` file to define:

### Source File Extensions

The tool automatically includes many common source code file extensions. Examples include:

- **Web:** `.js`, `.ts`, `.jsx`, `.tsx`, `.vue`, `.svelte`, `.html`, `.css`, etc.
- **Python:** `.py`, `.pyi`, `.pyx`
- **Java/Kotlin:** `.java`, `.kt`, `.groovy`
- **C-family:** `.c`, `.cpp`, `.h`, `.hpp`
- **Other Languages:** Ruby (`.rb`), PHP (`.php`), Go (`.go`), Rust (`.rs`), Swift (`.swift`), Shell (`.sh`), and more.

*To add or remove extensions, edit the `SOURCE_EXTENSIONS` set in `extensions.py`.*

### Ignore Patterns

Files and directories are automatically ignored based on three levels:

1. **Built-in Patterns:** Defined in the `IGNORE_PATTERNS` set in `extensions.py` (e.g., build outputs, dependency directories, IDE files, binary/media files).
2. **Project’s `.gitignore`:** If a `.gitignore` is present at the root of your project, CodeSmelt honors its rules.
3. **Directory-specific Rules:** Additional `.gitignore` files in subdirectories will also be considered.

*To customize, modify the `IGNORE_PATTERNS` in `extensions.py`.*

Example of adding Unity3D-specific ignores:

```python
IGNORE_PATTERNS = {
    # ... existing patterns ...
    'Assets/AssetStoreTools/*',
    'Library/*',
    'Temp/*',
    'Logs/*',
    '*.unity',  # Unity scene files
    '*.meta',   # Unity meta files
    '*.prefab', # Unity prefab files
    # ... other patterns ...
}
```

---

## Tips for Using with LLMs

1. **Token Management:**
   - For very large projects, consider concatenating only specific directories to avoid token limits.
   - Use debug mode (`-d`) to verify which files are included/excluded.

2. **Effective Prompting:**
   - Reference files using their relative paths as shown in the generated directory structure.
   - Ask questions about specific sections of the output using the file headers.

3. **Best Practices:**
   - Always review the concatenated output before sending it to an LLM.
   - For large projects, consider breaking down the analysis into smaller, manageable components.

---

## Troubleshooting

### Common Issues

1. **No Files Found:**
   - Double-check the project path.
   - Ensure your project contains files with supported extensions.
   - Run with `--debug` to see detailed file filtering information.

2. **Missing Dependencies:**
   - Make sure you have installed all required packages by running:
     
     ```bash
     pip install -r requirements.txt
     ```

3. **Permission Issues:**
   - Make sure you have read permissions for the project directory and write permissions for the output file.

---

## Contributing

Contributions are welcome! If you have ideas for improvements, bug fixes, or additional features, please fork the repository and submit a pull request. For major changes, please open an issue first to discuss what you would like to change.

---

## License

This project is licensed under the [MIT License](LICENSE).

---

## Author

**Shiraz Akmal**

Feel free to reach out if you have any questions or feedback!

---

Happy coding with CodeSmelt!

# File: codesmelt.py
================================================================================

#!/usr/bin/env python3
"""
CodeSmelt: Source Code Concatenator

This tool melts down source code files from a git project into a single file,
including directory structure information.
"""

import argparse
import sys
from pathlib import Path
import os
from typing import Set, List, Optional
import fnmatch
from datetime import datetime
import gitignore_parser
from extensions import SOURCE_EXTENSIONS, IGNORE_PATTERNS

class CodeSmelt:
    def __init__(self, project_path: str, output_file: str):
        self.project_path = Path(project_path).resolve()
        self.output_file = Path(output_file)
        self.gitignore_matcher = self._setup_gitignore()
        self.debug = False
        self.include_structure = True

    def _setup_gitignore(self) -> Optional[callable]:
        """Setup gitignore matcher if .gitignore exists"""
        gitignore_path = self.project_path / '.gitignore'
        if gitignore_path.exists():
            try:
                return gitignore_parser.parse_gitignore(gitignore_path)
            except Exception as e:
                print(f"Warning: Failed to parse .gitignore: {e}")
        return None

    def _should_include_file(self, file_path: Path) -> bool:
        """Check if file should be included based on extension and ignore rules"""
        # Skip common virtual environment and system directories
        excluded_dirs = {
            '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
            '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
            'dist', 'build', 'target'
        }

        try:
            # Convert to relative path for checking
            try:
                rel_path = file_path.relative_to(self.project_path)
            except ValueError:
                if self.debug:
                    print(f"Debug: Skipping file outside project path: {file_path}")
                return False

            # Check for excluded directories in the path
            if any(part in excluded_dirs for part in file_path.parts):
                if self.debug:
                    print(f"Debug: Skipping excluded directory: {file_path}")
                return False

            # Check if file extension is in whitelist
            if file_path.suffix.lower() not in SOURCE_EXTENSIONS:
                if self.debug:
                    print(f"Debug: Skipping non-source file: {file_path}")
                return False

            # Check custom ignore patterns
            for pattern in IGNORE_PATTERNS:
                if fnmatch.fnmatch(str(rel_path), pattern):
                    if self.debug:
                        print(f"Debug: Skipping ignored pattern {pattern}: {file_path}")
                    return False

            # Check .gitignore if available
            if self.gitignore_matcher:
                try:
                    should_include = not self.gitignore_matcher(str(file_path))
                    if self.debug and not should_include:
                        print(f"Debug: Skipping gitignored file: {file_path}")
                    return should_include
                except Exception as e:
                    print(f"Warning: gitignore matching failed for {file_path}: {e}")
                    return True

            if self.debug:
                print(f"Debug: Including file: {file_path}")
            return True

        except Exception as e:
            print(f"Warning: Error checking file {file_path}: {e}")
            return False

    def _get_file_content(self, file_path: Path) -> str:
        """Read file content with proper encoding handling"""
        try:
            # Try UTF-8 first
            with open(file_path, 'r', encoding='utf-8') as f:
                return f.read()
        except UnicodeDecodeError:
            try:
                # Fallback to latin-1
                with open(file_path, 'r', encoding='latin-1') as f:
                    return f.read()
            except Exception as e:
                print(f"Warning: Failed to read {file_path}: {e}")
                return f"ERROR: Could not read file {file_path}\n"

    def _generate_directory_structure(self) -> str:
        """Generate a tree-like directory structure"""
        structure = ["Directory Structure:", ""]

        def add_to_tree(path: Path, prefix: str = ""):
            # Skip excluded directories
            excluded_dirs = {
                '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
                '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
                'dist', 'build', 'target'
            }
            if path.name in excluded_dirs:
                return

            # Add files first
            files = sorted([p for p in path.iterdir() if p.is_file()])
            included_files = [f for f in files if self._should_include_file(f)]

            for idx, file in enumerate(included_files):
                is_last = idx == len(included_files) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {file.name}")

            # Then add directories
            dirs = sorted([p for p in path.iterdir() if p.is_dir()])
            included_dirs = [d for d in dirs if d.name not in excluded_dirs]

            for idx, dir in enumerate(included_dirs):
                is_last = idx == len(included_dirs) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {dir.name}/")
                add_to_tree(dir, prefix + ("    " if is_last else "│   "))

        add_to_tree(self.project_path)
        return "\n".join(structure)

    def concatenate(self, debug: bool = False):
        """Main method to concatenate all source files"""
        self.debug = debug
        if not self.project_path.exists():
            print(f"Error: Project path {self.project_path} does not exist")
            return False

        try:
            with open(self.output_file, 'w', encoding='utf-8') as out:
                # Write header
                header = f"""
# Project Source Code Concatenation
# Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
# Project path: {self.project_path}

"""
                out.write(header)

                # Write directory structure if enabled
                if self.include_structure:
                    out.write(self._generate_directory_structure())
                    out.write("\n\n" + "="*80 + "\n\n")

                # Process all files
                file_count = 0
                for file_path in self.project_path.rglob('*'):
                    if file_path.is_file() and self._should_include_file(file_path):
                        rel_path = file_path.relative_to(self.project_path)

                        # Write file header
                        out.write(f"\n\n# File: {rel_path}\n")
                        out.write("="*80 + "\n\n")

                        # Write file content
                        content = self._get_file_content(file_path)
                        out.write(content)
                        file_count += 1

                print(f"Successfully melted {file_count} files to {self.output_file}")
                return True

        except Exception as e:
            print(f"Error during melting: {e}")
            return False

def main():
    parser = argparse.ArgumentParser(
        description="CodeSmelt: Melt down your git project's source code into a single file",
        usage="%(prog)s project_path [output_file] [-o OUTPUT] [-d] [-n]"
    )

    # Add the project path as required positional argument
    parser.add_argument(
        "project_path",
        help="Path to the git project directory"
    )

    # Add optional positional argument for output file
    parser.add_argument(
        "output_file",
        nargs="?",  # Make it optional
        help="Output file path (alternative to -o)",
        default=None
    )

    # Keep the original -o option for backward compatibility
    parser.add_argument(
        "-o", "--output",
        help="Output file path (default: concatenated_source.txt)",
        default=None
    )

    parser.add_argument(
        "-d", "--debug",
        action="store_true",
        help="Enable debug logging"
    )

    parser.add_argument(
        "-n", "--no-structure",
        action="store_true",
        help="Omit directory structure from output"
    )

    args = parser.parse_args()

    # Determine the output file path, prioritizing command line arguments
    output_file = args.output or args.output_file or "concatenated_source.txt"

    concatenator = CodeSmelt(args.project_path, output_file)
    concatenator.include_structure = not args.no_structure
    success = concatenator.concatenate(debug=args.debug)
    sys.exit(0 if success else 1)

if __name__ == "__main__":
    main()