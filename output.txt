
# Project Source Code Concatenation
# Generated on: 2025-02-16 02:41:35
# Project path: /home/runner/workspace

Directory Structure:

├── README.md
├── ai_integration.py
├── codesmelt.py
├── extensions.py
├── output.summary.md
├── output.txt
├── pyproject.toml
└── requirements.txt
└── assets/

================================================================================



# File: pyproject.toml
================================================================================

[project]
name = "repl-nix-workspace"
version = "0.1.0"
description = "Add your description here"
requires-python = ">=3.11"
dependencies = [
    "gitignore-parser>=0.1.11",
]


# File: requirements.txt
================================================================================

gitignore_parser==0.1.11
openai
openai
openai
openai

# File: output.txt
================================================================================



# File: output.summary.md
================================================================================

# CodeSmelt README

## Table of Contents

- [Project Structure](#project-structure)
- [Key Features](#key-features)
- [Core Classes](#core-classes)
- [Notable Algorithms and Patterns](#notable-algorithms-and-patterns)
- [Dependencies and Requirements](#dependencies-and-requirements)

---

## Project Structure

The project structure is organized as follows:

```plaintext
├── README.md
├── ai_integration.py
├── codesmelt.py
├── extensions.py
├── output.summary.md
├── output.txt
├── pyproject.toml
├── requirements.txt
└── assets/
    └── CodeSmeltLogo.jpg
```

### Description of Key Files

- **README.md**: Contains detailed instructions on how to use the tool, its features, and configuration options.
- **ai_integration.py**: Handles integration with AI services for generating documentation summaries.
- **codesmelt.py**: The main executable script responsible for concatenating source code files.
- **extensions.py**: Defines configurations for file extensions and ignore patterns.
- **output.txt**: The default output file where the concatenated source code is written.
- **output.summary.md**: The output file for AI-generated documentation summaries.
- **pyproject.toml**: Contains project metadata and dependencies.
- **requirements.txt**: Lists the required Python packages for the project.
- **assets/**: A directory containing project assets like the logo.

---

## Key Features

- **Concatenation with Context**: Combines multiple source files into a single file while preserving the directory structure. This provides a clear layout of the project in the output file.
- **Smart Filtering**: Utilizes file extension whitelists and ignore patterns to intelligently select files. It also respects `.gitignore` rules for additional filtering.
- **Encoding Handling**: Manages file encoding, defaulting to UTF-8, with a fallback to Latin-1 to ensure all files can be read.
- **Debug Logging**: Offers detailed logging to help users understand which files are included or excluded from the concatenation process.
- **Customizable Output**: Allows users to tweak the output by omitting the directory structure or disabling file extension filtering.
- **AI Documentation Summary**: Optionally generates a documentation summary using AI, provided the necessary API keys are set.

---

## Core Classes

### `CodeSmelt` (from `codesmelt.py`)

The `CodeSmelt` class is the core component of the tool and is responsible for the concatenation process. Its key responsibilities include:

- **Project Path and Output Setup**: Manages the project directory path and the output file setup.
- **File Filtering**: Determines which files should be included based on extensions, ignore patterns, and `.gitignore` rules.
- **File Reading**: Reads file contents with proper encoding handling, attempting UTF-8 first and falling back to Latin-1 if needed.
- **Directory Structure Generation**: Recursively traverses directories to generate a tree-like structure within the output file.
- **AI Summary Generation**: Optionally generates an AI-based summary of the concatenated source code if the `-s` flag is used.

### `OpenAI` (from `ai_integration.py`)

The `OpenAI` class is used to interface with AI services for generating documentation summaries. It provides methods to:

- **Initialize AI Client**: Sets up the client using environment variables for API keys.
- **Generate Summary**: Sends the concatenated source code to the AI service to generate a comprehensive documentation summary.

---

## Notable Algorithms and Patterns

- **File Filtering Algorithm**: Employs a multi-level filtering approach using file extension checks, predefined ignore patterns, and `.gitignore` parsing. This ensures that only relevant files are included in the output.
- **Directory Structure Generation**: Utilizes a recursive algorithm to traverse the project directory and build a tree-like structure within the output file, which helps in visualizing the project layout.
- **Encoding Strategy**: Implements a strategy pattern for reading files, trying UTF-8 encoding first and falling back to Latin-1 if necessary, ensuring robust file handling.

---

## Dependencies and Requirements

### Python Version

- **Python 3.11 or higher** is required to run CodeSmelt.

### Dependencies

The following Python packages are required and can be installed using the `requirements.txt` file:

- **gitignore-parser**: Version 0.1.11 or higher for parsing `.gitignore` files.
- **openai**: For integration with OpenAI's AI services to generate documentation summaries.

To install these dependencies, run:

```bash
pip install -r requirements.txt
```

### Optional Dependencies

- **xAI**: For using xAI's API instead of OpenAI's, which requires setting the `XAI_API_KEY` environment variable.

### Environment Variables

For AI integration, the following environment variables need to be set:

- `OPENAI_API_KEY`: Required for using OpenAI's API.
- `XAI_API_KEY`: Required for using xAI's API.

# File: extensions.py
================================================================================

"""
Source code file extension configurations

Author: Shiraz Akmal & AI

"""

# Common source code file extensions
SOURCE_EXTENSIONS = {
    # Web
    '.js', '.ts', '.jsx', '.tsx', '.vue', '.svelte',
    '.html', '.htm', '.css', '.scss', '.sass', '.less',
    
    # Python
    '.py', '.pyi', '.pyx',
    
    # Java/Kotlin
    '.java', '.kt', '.groovy',
    
    # C-family
    '.c', '.cpp', '.h', '.hpp', '.cc',
    
    # C#
    '.cs', '.cshtml', '.csx',
    
    # Ruby
    '.rb', '.erb',
    
    # PHP
    '.php', '.php5', '.phtml',
    
    # Go
    '.go',
    
    # Rust
    '.rs',
    
    # Swift
    '.swift',
    
    # Shell
    '.sh', '.bash', '.zsh',
    
    # Config/Data
    '.json', '.yaml', '.yml', '.toml', '.xml',
    '.conf', '.ini', '.env',
    
    # Documentation
    '.md', '.rst', '.txt'
}

# Files to always ignore
IGNORE_PATTERNS = {
    # Build outputs
    'build/*', 'dist/*', 'target/*', 'bin/*',
    '*.pyc', '__pycache__/*', '*.class',
    
    # Dependencies
    'node_modules/*', 'vendor/*', 'venv/*',
    
    # IDE files
    '.idea/*', '.vscode/*', '*.swp',
    
    # Package files
    'package-lock.json', 'yarn.lock',
    'Pipfile.lock', 'poetry.lock',
    
    # Large data files
    '*.csv', '*.json.gz', '*.sql',
    
    # Binary/Media files
    '*.pdf', '*.jpg', '*.png', '*.gif',
    '*.mp3', '*.mp4', '*.mov', '*.bin',
    '*.exe', '*.dll', '*.so', '*.dylib'
}


# File: codesmelt.py
================================================================================

#!/usr/bin/env python3
"""
CodeSmelt: Source Code Concatenator

This tool melts down source code files from a git project into a single file,
including directory structure information.

Author: Shiraz Akmal & AI

"""

import argparse
import sys
from pathlib import Path
import os
from typing import Set, List, Optional
import fnmatch
from datetime import datetime
import gitignore_parser
from extensions import SOURCE_EXTENSIONS, IGNORE_PATTERNS
from ai_integration import try_all_providers

class CodeSmelt:
    def __init__(self, project_path: str, output_file: str):
        self.project_path = Path(project_path).resolve()
        self.output_file = Path(output_file)
        self.gitignore_matcher = self._setup_gitignore()
        self.debug = False
        self.include_structure = True
        self.include_extensions = True
        self.generate_summary = False
        self.custom_model = None  # New attribute for custom model

    def _setup_gitignore(self) -> Optional[object]:
        """Setup gitignore matcher if .gitignore exists"""
        gitignore_path = self.project_path / '.gitignore'
        if gitignore_path.exists():
            try:
                return gitignore_parser.parse_gitignore(gitignore_path)
            except Exception as e:
                print(f"Warning: Failed to parse .gitignore: {e}")
        return None

    def _should_include_file(self, file_path: Path) -> bool:
        """Check if file should be included based on extension and ignore rules"""
        excluded_dirs = {
            '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
            '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
            'dist', 'build', 'target'
        }

        try:
            try:
                rel_path = file_path.relative_to(self.project_path)
            except ValueError:
                if self.debug:
                    print(f"Debug: Skipping file outside project path: {file_path}")
                return False

            if any(part in excluded_dirs for part in file_path.parts):
                if self.debug:
                    print(f"Debug: Skipping excluded directory: {file_path}")
                return False

            if self.include_extensions and file_path.suffix.lower() not in SOURCE_EXTENSIONS:
                if self.debug:
                    print(f"Debug: Skipping non-source file: {file_path}")
                return False

            for pattern in IGNORE_PATTERNS:
                if fnmatch.fnmatch(str(rel_path), pattern):
                    if self.debug:
                        print(f"Debug: Skipping ignored pattern {pattern}: {file_path}")
                    return False

            if self.gitignore_matcher:
                try:
                    should_include = not self.gitignore_matcher(str(file_path))
                    if self.debug and not should_include:
                        print(f"Debug: Skipping gitignored file: {file_path}")
                    return should_include
                except Exception as e:
                    print(f"Warning: gitignore matching failed for {file_path}: {e}")
                    return True

            if self.debug:
                print(f"Debug: Including file: {file_path}")
            return True

        except Exception as e:
            print(f"Warning: Error checking file {file_path}: {e}")
            return False

    def _get_file_content(self, file_path: Path) -> str:
        """Read file content with proper encoding handling"""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                return f.read()
        except UnicodeDecodeError:
            try:
                with open(file_path, 'r', encoding='latin-1') as f:
                    return f.read()
            except Exception as e:
                print(f"Warning: Failed to read {file_path}: {e}")
                return f"ERROR: Could not read file {file_path}\n"

    def _generate_directory_structure(self) -> str:
        """Generate a tree-like directory structure"""
        structure = ["Directory Structure:", ""]

        def add_to_tree(path: Path, prefix: str = ""):
            excluded_dirs = {
                '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
                '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
                'dist', 'build', 'target'
            }
            if path.name in excluded_dirs:
                return

            files = sorted([p for p in path.iterdir() if p.is_file()])
            included_files = [f for f in files if self._should_include_file(f)]

            for idx, file in enumerate(included_files):
                is_last = idx == len(included_files) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {file.name}")

            dirs = sorted([p for p in path.iterdir() if p.is_dir()])
            included_dirs = [d for d in dirs if d.name not in excluded_dirs]

            for idx, dir in enumerate(included_dirs):
                is_last = idx == len(included_dirs) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {dir.name}/")
                add_to_tree(dir, prefix + ("    " if is_last else "│   "))

        add_to_tree(self.project_path)
        return "\n".join(structure)

    def concatenate(self, debug: bool = False):
        """Main method to concatenate all source files"""
        self.debug = debug
        if not self.project_path.exists():
            print(f"Error: Project path {self.project_path} does not exist")
            return False

        try:
            with open(self.output_file, 'w', encoding='utf-8') as out:
                header = f"""
# Project Source Code Concatenation
# Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
# Project path: {self.project_path}

"""
                out.write(header)

                if self.include_structure:
                    out.write(self._generate_directory_structure())
                    out.write("\n\n" + "="*80 + "\n\n")

                file_count = 0
                for file_path in self.project_path.rglob('*'):
                    if file_path.is_file() and self._should_include_file(file_path):
                        rel_path = file_path.relative_to(self.project_path)

                        out.write(f"\n\n# File: {rel_path}\n")
                        out.write("="*80 + "\n\n")

                        content = self._get_file_content(file_path)
                        out.write(content)
                        file_count += 1

                print(f"Successfully melted {file_count} files to {self.output_file}")

                if self.generate_summary and file_count > 0:
                    print("Generating AI documentation summary...")
                    summary_path = self.output_file.with_suffix('.summary.md')

                    with open(self.output_file, 'r', encoding='utf-8') as f:
                        content = f.read()

                    summary = try_all_providers(content, self.custom_model)
                    if summary:
                        with open(summary_path, 'w', encoding='utf-8') as f:
                            f.write(summary)
                        print(f"Generated AI summary: {summary_path}")
                    else:
                        print("Warning: Could not generate AI summary. "
                              "Make sure either OPENAI_API_KEY or XAI_API_KEY "
                              "environment variable is set.")

                return True

        except Exception as e:
            print(f"Error during melting: {e}")
            return False

def main():
    parser = argparse.ArgumentParser(
        description="CodeSmelt: Melt down your git project's source code into a single file",
        usage="%(prog)s project_path [output_file] [-o OUTPUT] [-d] [-n] [-e] [-s] [-m MODEL]"
    )

    parser.add_argument(
        "project_path",
        help="Path to the git project directory"
    )

    parser.add_argument(
        "output_file",
        nargs="?",
        help="Output file path (alternative to -o)",
        default=None
    )

    parser.add_argument(
        "-o", "--output",
        help="Output file path (default: concatenated_source.txt)",
        default=None
    )

    parser.add_argument(
        "-d", "--debug",
        action="store_true",
        help="Enable debug logging"
    )

    parser.add_argument(
        "-n", "--no-structure",
        action="store_true",
        help="Omit directory structure from output"
    )

    parser.add_argument(
        "-e", "--no-extensions",
        action="store_true",
        help="Disable file extension filtering"
    )

    parser.add_argument(
        "-s", "--summary",
        action="store_true",
        help="Generate AI documentation summary (requires OpenAI or xAI API key)"
    )

    parser.add_argument(
        "-m", "--model",
        help="Specify custom AI model (e.g., 'gpt-4', 'gpt-3.5-turbo' for OpenAI or 'grok-2-1212', 'grok-2-vision-1212' for xAI)",
        default=None
    )

    args = parser.parse_args()

    output_file = args.output or args.output_file or "concatenated_source.txt"

    concatenator = CodeSmelt(args.project_path, output_file)
    concatenator.include_structure = not args.no_structure
    concatenator.include_extensions = not args.no_extensions
    concatenator.generate_summary = args.summary
    concatenator.custom_model = args.model  # Pass custom model to CodeSmelt
    success = concatenator.concatenate(debug=args.debug)
    sys.exit(0 if success else 1)

if __name__ == "__main__":
    main()

# File: README.md
================================================================================

git clone https://github.com/yourusername/codesmelt.git
   cd codesmelt
   ```

2. **Install Dependencies:**

   CodeSmelt requires Python 3. Install all required packages using the `requirements.txt` file:

   ```bash
   pip install -r requirements.txt
   ```

   *(If you use a virtual environment, activate it before installing.)*

3. **Ensure File Structure:**

   Make sure the following files are in the same directory:

   - `codesmelt.py`
   - `extensions.py`
   - `README.md`
   - `requirements.txt`
   - `assets/CodeSmeltLogo.jpg` (logo image)

---

## Usage

### Basic Usage

Run CodeSmelt by providing the path to your Git project. For example:

```bash
python codesmelt.py /path/to/project
```

### Custom Output & Debug Mode

- **Specify a Custom Output File:**

  ```bash
  python codesmelt.py -o output.txt /path/to/project
  ```

- **Enable Debug Logging:**

  ```bash
  python codesmelt.py -d -o output.txt /path/to/project
  ```

- **Omit the Directory Structure from the Output:**

  ```bash
  python codesmelt.py -n /path/to/project
  ```

- **Disable File Extension Filtering (Include All Files):**

  ```bash
  python codesmelt.py -e /path/to/project
  ```

### AI Summary Generation

- **Generate Basic Documentation Summary:**

  Uses the default AI model to generate documentation:
  ```bash
  python codesmelt.py -s /path/to/project
  ```

- **Use Custom AI Model:**

  Choose specific models for summary generation:
  ```bash
  # Using OpenAI models
  python codesmelt.py -s -m gpt-4 /path/to/project
  python codesmelt.py -s -m gpt-3.5-turbo /path/to/project

  # Using xAI models
  python codesmelt.py -s -m grok-2-1212 /path/to/project
  python codesmelt.py -s -m grok-2-vision-1212 /path/to/project
  ```

  Note: Each model has different capabilities and token limits:
  - OpenAI GPT-4: 8K tokens
  - OpenAI GPT-3.5: 4K tokens
  - xAI Grok-2: 130K tokens
  - xAI Grok-2-Vision: 8K tokens

#### Command-line Arguments

- `project_path` (required): Path to your Git project directory.
- `-o, --output`: Specify the output file path (default: `concatenated_source.txt`).
- `-d, --debug`: Enable debug logging to get detailed information about file selection.
- `-n, --no-structure`: Omit the directory structure from the output file.
- `-e, --no-extensions`: Disable file extension filtering (include all files regardless of extension).
- `-s, --summary`: Generate AI documentation summary (requires OpenAI or xAI API key).
- `-m, --model`: Specify custom AI model for summary generation (e.g., 'gpt-4', 'gpt-3.5-turbo' for OpenAI or 'grok-2-1212', 'grok-2-vision-1212' for xAI).

---

## Configuration

CodeSmelt uses the `extensions.py` file to define:

### Source File Extensions

The tool automatically includes many common source code file extensions. Examples include:

- **Web:** `.js`, `.ts`, `.jsx`, `.tsx`, `.vue`, `.svelte`, `.html`, `.css`, etc.
- **Python:** `.py`, `.pyi`, `.pyx`
- **Java/Kotlin:** `.java`, `.kt`, `.groovy`
- **C-family:** `.c`, `.cpp`, `.h`, `.hpp`
- **Other Languages:** Ruby (`.rb`), PHP (`.php`), Go (`.go`), Rust (`.rs`), Swift (`.swift`), Shell (`.sh`), and more.

*To add or remove extensions, edit the `SOURCE_EXTENSIONS` set in `extensions.py`.*

### Ignore Patterns

Files and directories are automatically ignored based on three levels:

1. **Built-in Patterns:** Defined in the `IGNORE_PATTERNS` set in `extensions.py` (e.g., build outputs, dependency directories, IDE files, binary/media files).
2. **Project's `.gitignore`:** If a `.gitignore` is present at the root of your project, CodeSmelt honors its rules.
3. **Directory-specific Rules:** Additional `.gitignore` files in subdirectories will also be considered.

*To customize, modify the `IGNORE_PATTERNS` in `extensions.py`.*

---

## Tips for Using with LLMs

1. **Token Management:**
   - For very large projects, consider concatenating only specific directories to avoid token limits.
   - Use debug mode (`-d`) to verify which files are included/excluded.
   - Choose appropriate AI models based on your project size (xAI models support larger contexts).

2. **Effective Prompting:**
   - Reference files using their relative paths as shown in the generated directory structure.
   - Ask questions about specific sections of the output using the file headers.

3. **Best Practices:**
   - Always review the concatenated output before sending it to an LLM.
   - For large projects, consider breaking down the analysis into smaller, manageable components.

---

## Troubleshooting

### Common Issues

1. **No Files Found:**
   - Double-check the project path.
   - Ensure your project contains files with supported extensions (unless using `-e` to disable filtering).
   - Run with `--debug` to see detailed file filtering information.

2. **Missing Dependencies:**
   - Make sure you have installed all required packages by running:

     ```bash
     pip install -r requirements.txt

# File: ai_integration.py
================================================================================

"""
AI integration module for CodeSmelt
Supports both OpenAI and xAI APIs for generating code documentation

Author: Shiraz Akmal & AI

"""

import os
from typing import Optional
from openai import OpenAI

def get_ai_client(provider: str = "openai") -> Optional[OpenAI]:
    """Initialize AI client based on available API keys"""
    try:
        if provider == "xai":
            api_key = os.getenv("XAI_API_KEY")
            if api_key:
                return OpenAI(
                    api_key=api_key,
                    base_url="https://api.x.ai/v1"
                )
        else:  # openai
            api_key = os.getenv("OPENAI_API_KEY")
            if api_key:
                return OpenAI(api_key=api_key)
        return None
    except Exception as e:
        print(f"Warning: Failed to initialize {provider} client: {e}")
        return None

def generate_summary(content: str, provider: str = "openai", custom_model: Optional[str] = None) -> Optional[str]:
    """Generate documentation summary using AI"""
    client = get_ai_client(provider)
    if not client:
        print(f"Warning: Could not initialize {provider} client. Check API key.")
        return None

    try:
        # Limit content size based on model
        max_tokens = 4000  # Default for most models
        if custom_model:
            if custom_model.startswith("grok"):
                max_tokens = 130000  # xAI models have larger context
            elif custom_model in ["gpt-4", "gpt-4o"]:
                max_tokens = 7000  # Leave room for response
            print(f"Debug: Using token limit of {max_tokens} for model {custom_model}")

        content_preview = content[:max_tokens * 4]  # Approximate token count (4 chars per token)
        print(f"Debug: Content preview length: {len(content_preview)} characters")

        prompt = """
        Please analyze the following source code and generate a comprehensive README-style documentation.
        Focus on:
        1. Project structure and organization
        2. Key functionality and features
        3. Important classes and their purposes
        4. Notable algorithms or patterns used
        5. Dependencies and requirements

        Respond in markdown format.

        Source code:

        {content}
        """.format(content=content_preview)

        # Use custom model if provided, otherwise use defaults
        if custom_model:
            model = custom_model
        elif provider == "xai":
            model = "grok-2-1212"
        else:
            model = "gpt-4o"

        print(f"Using AI model: {model}")  # Debug info for user

        response = client.chat.completions.create(
            model=model,
            messages=[
                {"role": "system", "content": "You are an expert code analyst specializing in generating clear, comprehensive documentation."},
                {"role": "user", "content": prompt}
            ],
            temperature=0.7,
            max_tokens=2000,
            response_format={"type": "text"}
        )

        return response.choices[0].message.content

    except Exception as e:
        print(f"Warning: Failed to generate summary using {provider} with model {model}: {e}")
        # Try the alternative provider if the first one fails and no custom model was specified
        if provider == "openai" and not custom_model:
            print("Trying xAI as fallback...")
            return generate_summary(content, provider="xai")
        return None

def try_all_providers(content: str, custom_model: Optional[str] = None) -> Optional[str]:
    """Try all available AI providers and return the first successful result"""
    # If custom model is specified, determine the provider based on the model name
    if custom_model:
        if custom_model.startswith("grok"):
            if not os.getenv("XAI_API_KEY"):
                print("Warning: XAI_API_KEY environment variable is not set. "
                      "Required for using Grok models.")
                return None
            return generate_summary(content, provider="xai", custom_model=custom_model)
        else:
            if not os.getenv("OPENAI_API_KEY"):
                print("Warning: OPENAI_API_KEY environment variable is not set. "
                      "Required for using OpenAI models.")
                return None
            return generate_summary(content, provider="openai", custom_model=custom_model)

    # Try OpenAI first, then fall back to xAI if no custom model specified
    for provider in ["openai", "xai"]:
        if provider == "openai" and not os.getenv("OPENAI_API_KEY"):
            print("Warning: OPENAI_API_KEY not found, trying xAI...")
            continue
        if provider == "xai" and not os.getenv("XAI_API_KEY"):
            print("Warning: XAI_API_KEY not found, no more providers to try.")
            return None
        print(f"Attempting to generate summary using {provider}...")
        summary = generate_summary(content, provider)
        if summary:
            return summary
    return None