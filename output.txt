
# Project Source Code Concatenation
# Generated on: 2025-02-16 02:31:37
# Project path: /home/runner/workspace

Directory Structure:

├── README.md
├── ai_integration.py
├── codesmelt.py
├── extensions.py
├── output.summary.md
├── output.txt
├── pyproject.toml
└── requirements.txt
└── assets/

================================================================================



# File: pyproject.toml
================================================================================

[project]
name = "repl-nix-workspace"
version = "0.1.0"
description = "Add your description here"
requires-python = ">=3.11"
dependencies = [
    "gitignore-parser>=0.1.11",
]


# File: requirements.txt
================================================================================

gitignore_parser==0.1.11
openai
openai
openai
openai

# File: README.md
================================================================================

# CodeSmelt: Source Code Concatenator

![CodeSmelt Logo](assets/CodeSmeltLogo.jpg)

**CodeSmelt** is a command-line tool that “melts down” your Git project’s source code into a single, well-organized file. It not only concatenates source files but also embeds a tree-like directory structure (unless omitted) to help you quickly understand your project’s layout. This is especially useful for code analysis, preparing inputs for language models, or sharing project snapshots.

---

## Table of Contents

- [Features](#features)
- [Installation](#installation)
- [Usage](#usage)
  - [Basic Usage](#basic-usage)
  - [Custom Output & Debug Mode](#custom-output--debug-mode)
- [Configuration](#configuration)
  - [Source File Extensions](#source-file-extensions)
  - [Ignore Patterns](#ignore-patterns)
- [Tips for Using with LLMs](#tips-for-using-with-llms)
- [Troubleshooting](#troubleshooting)
- [Contributing](#contributing)
- [License](#license)
- [Author](#author)

---

## Features

- **Concatenation with Context:** Combines all source files (with supported extensions by default) into one file while preserving directory hierarchy.
- **Smart Filtering:** Uses built-in file extension whitelists and ignore patterns. Also honors your project’s `.gitignore` for extra filtering.
- **Encoding Handling:** Automatically handles file encoding issues (tries UTF-8 first, then falls back to Latin-1).
- **Debug Logging:** Option to enable debug logging so you can see which files are being included or skipped.
- **Customizable Output:** Optionally omit the directory structure and disable file extension filtering via command-line flags.
- **Easy Customization:** Adjust supported file extensions and ignore patterns via the `extensions.py` file.

---

## Installation

1. **Clone the Repository:**

   ```bash
   git clone https://github.com/yourusername/codesmelt.git
   cd codesmelt
   ```

2. **Install Dependencies:**

   CodeSmelt requires Python 3. Install all required packages using the `requirements.txt` file:

   ```bash
   pip install -r requirements.txt
   ```

   *(If you use a virtual environment, activate it before installing.)*

3. **Ensure File Structure:**

   Make sure the following files are in the same directory:
   
   - `codesmelt.py`
   - `extensions.py`
   - `README.md`
   - `requirements.txt`
   - `assets/CodeSmeltLogo.jpg` (logo image)

---

## Usage

### Basic Usage

Run CodeSmelt by providing the path to your Git project. For example:

```bash
python codesmelt.py /path/to/project
```

### Custom Output, Debug Mode, and New Options

- **Specify a Custom Output File:**

  ```bash
  python codesmelt.py -o output.txt /path/to/project
  ```

- **Enable Debug Logging:**

  ```bash
  python codesmelt.py -d -o output.txt /path/to/project
  ```

- **Omit the Directory Structure from the Output:**

  ```bash
  python codesmelt.py -n /path/to/project
  ```

- **Disable File Extension Filtering (Include All Files):**

  ```bash
  python codesmelt.py -e /path/to/project
  ```

#### Command-line Arguments

- `project_path` (required): Path to your Git project directory.
- `-o, --output`: Specify the output file path (default: `concatenated_source.txt`).
- `-d, --debug`: Enable debug logging to get detailed information about file selection.
- `-n, --no-structure`: Omit the directory structure from the output file.
- `-e, --no-extensions`: Disable file extension filtering (include all files regardless of extension).

---

## Configuration

CodeSmelt uses the `extensions.py` file to define:

### Source File Extensions

The tool automatically includes many common source code file extensions. Examples include:

- **Web:** `.js`, `.ts`, `.jsx`, `.tsx`, `.vue`, `.svelte`, `.html`, `.css`, etc.
- **Python:** `.py`, `.pyi`, `.pyx`
- **Java/Kotlin:** `.java`, `.kt`, `.groovy`
- **C-family:** `.c`, `.cpp`, `.h`, `.hpp`
- **Other Languages:** Ruby (`.rb`), PHP (`.php`), Go (`.go`), Rust (`.rs`), Swift (`.swift`), Shell (`.sh`), and more.

*To add or remove extensions, edit the `SOURCE_EXTENSIONS` set in `extensions.py`.*

### Ignore Patterns

Files and directories are automatically ignored based on three levels:

1. **Built-in Patterns:** Defined in the `IGNORE_PATTERNS` set in `extensions.py` (e.g., build outputs, dependency directories, IDE files, binary/media files).
2. **Project’s `.gitignore`:** If a `.gitignore` is present at the root of your project, CodeSmelt honors its rules.
3. **Directory-specific Rules:** Additional `.gitignore` files in subdirectories will also be considered.

*To customize, modify the `IGNORE_PATTERNS` in `extensions.py`.*

Example of adding Unity3D-specific ignores:

```python
IGNORE_PATTERNS = {
    # ... existing patterns ...
    'Assets/AssetStoreTools/*',
    'Library/*',
    'Temp/*',
    'Logs/*',
    '*.unity',  # Unity scene files
    '*.meta',   # Unity meta files
    '*.prefab', # Unity prefab files
    # ... other patterns ...
}
```

---

## Tips for Using with LLMs

1. **Token Management:**
   - For very large projects, consider concatenating only specific directories to avoid token limits.
   - Use debug mode (`-d`) to verify which files are included/excluded.

2. **Effective Prompting:**
   - Reference files using their relative paths as shown in the generated directory structure.
   - Ask questions about specific sections of the output using the file headers.

3. **Best Practices:**
   - Always review the concatenated output before sending it to an LLM.
   - For large projects, consider breaking down the analysis into smaller, manageable components.

---

## Troubleshooting

### Common Issues

1. **No Files Found:**
   - Double-check the project path.
   - Ensure your project contains files with supported extensions (unless using `-e` to disable filtering).
   - Run with `--debug` to see detailed file filtering information.

2. **Missing Dependencies:**
   - Make sure you have installed all required packages by running:
     
     ```bash
     pip install -r requirements.txt
     ```

3. **Permission Issues:**
   - Make sure you have read permissions for the project directory and write permissions for the output file.

---

## Contributing

Contributions are welcome! If you have ideas for improvements, bug fixes, or additional features, please fork the repository and submit a pull request. For major changes, please open an issue first to discuss what you would like to change.

---

## License

This project is licensed under the [MIT License](LICENSE).

---

## Author

**Shiraz Akmal**

Feel free to reach out (https://x.com/ShirazAkmal) if you have any questions or feedback! 

---

Happy coding with CodeSmelt!


# File: output.txt
================================================================================



# File: output.summary.md
================================================================================

```markdown
# CodeSmelt: Source Code Concatenator

![CodeSmelt Logo](assets/CodeSmeltLogo.jpg)

**CodeSmelt** is a command-line tool designed to simplify the analysis and sharing of Git projects by concatenating source code files into a single file. This tool preserves the directory structure within the output, providing a comprehensive view of the project layout. It is particularly useful for code analysis, input preparation for language models, and sharing project snapshots.

---

## Table of Contents

- [Project Structure](#project-structure)
- [Key Features](#key-features)
- [Core Classes](#core-classes)
- [Notable Algorithms and Patterns](#notable-algorithms-and-patterns)
- [Installation](#installation)
- [Usage](#usage)
- [Configuration](#configuration)
- [Tips for Using with LLMs](#tips-for-using-with-llms)
- [Troubleshooting](#troubleshooting)
- [Contributing](#contributing)
- [License](#license)
- [Author](#author)

---

## Project Structure

```plaintext
├── README.md
├── ai_integration.py
├── codesmelt.py
├── extensions.py
├── output.txt
├── pyproject.toml
├── requirements.txt
└── assets/
    └── CodeSmeltLogo.jpg
```

### Description of Key Files

- **codesmelt.py**: Main executable script for concatenating source code files.
- **extensions.py**: Contains configuration for file extensions and ignore patterns.
- **requirements.txt**: Lists required dependencies.
- **pyproject.toml**: Project metadata and dependencies declaration.
- **assets/**: Directory containing project assets like the logo.

---

## Key Features

- **Concatenation with Context**: Combines multiple source files into a single file while preserving directory structure.
- **Smart Filtering**: Utilizes file extension whitelists and ignore patterns, respecting `.gitignore` rules.
- **Encoding Handling**: Manages file encoding, defaulting to UTF-8, with a fallback to Latin-1.
- **Debug Logging**: Provides detailed logging to understand file inclusion/exclusion.
- **Customizable Output**: Options to tweak directory structure inclusion and file extension filtering.
- **AI Summary**: Can generate documentation summaries using AI, provided the necessary API keys are set.

---

## Core Classes

### `CodeSmelt`

A class responsible for handling the concatenation process. Key responsibilities include:
- Managing project path and output file setup.
- Filtering files based on extensions and ignore patterns.
- Reading file contents with encoding management.
- Generating directory-like structure within the concatenated output.
- Optionally generating an AI-based summary of the concatenated source code.

---

## Notable Algorithms and Patterns

- **File Filtering**: Uses a combination of file extension checks, ignore patterns, and `.gitignore` parsing for intelligent file selection.
- **Directory Structure Generation**: Recursively traverses directories to build a tree-like structure within the output.
- **Encoding Strategy**: Attempts to read files with UTF-8 encoding and falls back to Latin-1 if necessary.

---

## Installation

1. **Clone the Repository**:
   ```bash
   git clone https://github.com/yourusername/codesmelt.git
   cd codesmelt
   ```

2. **Install Dependencies**:
   ```bash
   pip install -r requirements.txt
   ```

3. **Ensure Required Files**:
   Ensure all key files listed in the project structure are present.

---

## Usage

### Basic Usage

To concatenate project source files, run:
```bash
python codesmelt.py /path/to/project
```

### Advanced Options

- **Custom Output File**:
  ```bash
  python codesmelt.py -o output.txt /path/to/project
  ```

- **Enable Debug Logging**:
  ```bash
  python codesmelt.py -d /path/to/project
  ```

- **Exclude Directory Structure**:
  ```bash
  python codesmelt.py -n /path/to/project
  ```

- **Include All Files (Disable Filtering)**:
  ```bash
  python codesmelt.py -e /path/to/project
  ```

- **Generate AI Documentation Summary**:
  ```bash
  python codesmelt.py -s /path/to/project
  ```

### Command-line Arguments

- `project_path` (required): Directory path of the Git project.
- `-o, --output`: Output file path.
- `-d, --debug`: Enable detailed debug logging.
- `-n, --no-structure`: Exclude directory structure from output.
- `-e, --no-extensions`: Include all files, bypassing extension filtering.
- `-s, --summary`: Generate an AI summary if API keys are provided.

---

## Configuration

### Source File Extensions

Defined in `extensions.py`, this set determines which files are included based on their extensions. Customize by editing `SOURCE_EXTENSIONS`.

### Ignore Patterns

`IGNORE_PATTERNS` in `extensions.py` specifies files/directories to exclude. The tool also respects `.gitignore` files for additional filtering.

---

## Tips for Using with LLMs

- **Token Management**: Limit concatenation to essential directories for large projects.
- **Effective Prompting**: Use directory structure references for clarity.
- **Review Output**: Ensure the concatenated file meets your needs before LLM submission.

---

## Troubleshooting

- **Files Not Found**: Validate project path and file extensions. Use `--debug` for insights.
- **Dependencies Missing**: Run `pip install -r requirements.txt`.
- **Permission Issues**: Verify read/write permissions for involved directories and files.

---

## Contributing

Contributions are welcome! Fork the repository and submit pull requests for improvements, bug fixes, or new features. Discuss major changes via issues first.

---

## License

Licensed under the [MIT License](LICENSE).

---

## Author

**Shiraz Akmal**

Contact via [Twitter](https://x.com/ShirazAkmal) for questions or feedback.

Happy coding with CodeSmelt!
```

# File: extensions.py
================================================================================

"""
Source code file extension configurations

Author: Shiraz Akmal & AI

"""

# Common source code file extensions
SOURCE_EXTENSIONS = {
    # Web
    '.js', '.ts', '.jsx', '.tsx', '.vue', '.svelte',
    '.html', '.htm', '.css', '.scss', '.sass', '.less',
    
    # Python
    '.py', '.pyi', '.pyx',
    
    # Java/Kotlin
    '.java', '.kt', '.groovy',
    
    # C-family
    '.c', '.cpp', '.h', '.hpp', '.cc',
    
    # C#
    '.cs', '.cshtml', '.csx',
    
    # Ruby
    '.rb', '.erb',
    
    # PHP
    '.php', '.php5', '.phtml',
    
    # Go
    '.go',
    
    # Rust
    '.rs',
    
    # Swift
    '.swift',
    
    # Shell
    '.sh', '.bash', '.zsh',
    
    # Config/Data
    '.json', '.yaml', '.yml', '.toml', '.xml',
    '.conf', '.ini', '.env',
    
    # Documentation
    '.md', '.rst', '.txt'
}

# Files to always ignore
IGNORE_PATTERNS = {
    # Build outputs
    'build/*', 'dist/*', 'target/*', 'bin/*',
    '*.pyc', '__pycache__/*', '*.class',
    
    # Dependencies
    'node_modules/*', 'vendor/*', 'venv/*',
    
    # IDE files
    '.idea/*', '.vscode/*', '*.swp',
    
    # Package files
    'package-lock.json', 'yarn.lock',
    'Pipfile.lock', 'poetry.lock',
    
    # Large data files
    '*.csv', '*.json.gz', '*.sql',
    
    # Binary/Media files
    '*.pdf', '*.jpg', '*.png', '*.gif',
    '*.mp3', '*.mp4', '*.mov', '*.bin',
    '*.exe', '*.dll', '*.so', '*.dylib'
}


# File: ai_integration.py
================================================================================

"""
AI integration module for CodeSmelt
Supports both OpenAI and xAI APIs for generating code documentation

Author: Shiraz Akmal & AI

"""

import os
from typing import Optional
from openai import OpenAI

def get_ai_client(provider: str = "openai") -> Optional[OpenAI]:
    """Initialize AI client based on available API keys"""
    try:
        if provider == "xai":
            api_key = os.getenv("XAI_API_KEY")
            if api_key:
                return OpenAI(
                    api_key=api_key,
                    base_url="https://api.x.ai/v1"
                )
        else:  # openai
            api_key = os.getenv("OPENAI_API_KEY")
            if api_key:
                return OpenAI(api_key=api_key)
        return None
    except Exception as e:
        print(f"Warning: Failed to initialize {provider} client: {e}")
        return None

def generate_summary(content: str, provider: str = "openai", custom_model: Optional[str] = None) -> Optional[str]:
    """Generate documentation summary using AI"""
    client = get_ai_client(provider)
    if not client:
        return None

    try:
        # the newest OpenAI model is "gpt-4o" which was released May 13, 2024.
        # do not change this unless explicitly requested by the user
        prompt = """
        Please analyze the following source code and generate a comprehensive README-style documentation.
        Focus on:
        1. Project structure and organization
        2. Key functionality and features
        3. Important classes and their purposes
        4. Notable algorithms or patterns used
        5. Dependencies and requirements

        Respond in markdown format.

        Source code:

        {content}
        """.format(content=content)

        # Use custom model if provided, otherwise use defaults
        if custom_model:
            model = custom_model
        elif provider == "xai":
            model = "grok-2-1212"
        else:
            model = "gpt-4o"

        print(f"Using AI model: {model}")  # Debug info for user

        response = client.chat.completions.create(
            model=model,
            messages=[
                {"role": "system", "content": "You are an expert code analyst specializing in generating clear, comprehensive documentation."},
                {"role": "user", "content": prompt}
            ],
            temperature=0.7,
            max_tokens=2000,
            response_format={"type": "text"}
        )

        return response.choices[0].message.content

    except Exception as e:
        print(f"Warning: Failed to generate summary using {provider} with model {model}: {e}")
        # Try the alternative provider if the first one fails and no custom model was specified
        if provider == "openai" and not custom_model:
            print("Trying xAI as fallback...")
            return generate_summary(content, provider="xai")
        return None

def try_all_providers(content: str, custom_model: Optional[str] = None) -> Optional[str]:
    """Try all available AI providers and return the first successful result"""
    # If custom model is specified, determine the provider based on the model name
    if custom_model:
        if custom_model.startswith("grok"):
            return generate_summary(content, provider="xai", custom_model=custom_model)
        else:
            return generate_summary(content, provider="openai", custom_model=custom_model)

    # Try OpenAI first, then fall back to xAI if no custom model specified
    for provider in ["openai", "xai"]:
        summary = generate_summary(content, provider)
        if summary:
            return summary
    return None

# File: codesmelt.py
================================================================================

#!/usr/bin/env python3
"""
CodeSmelt: Source Code Concatenator

This tool melts down source code files from a git project into a single file,
including directory structure information.

Author: Shiraz Akmal & AI

"""

import argparse
import sys
from pathlib import Path
import os
from typing import Set, List, Optional
import fnmatch
from datetime import datetime
import gitignore_parser
from extensions import SOURCE_EXTENSIONS, IGNORE_PATTERNS
from ai_integration import try_all_providers

class CodeSmelt:
    def __init__(self, project_path: str, output_file: str):
        self.project_path = Path(project_path).resolve()
        self.output_file = Path(output_file)
        self.gitignore_matcher = self._setup_gitignore()
        self.debug = False
        self.include_structure = True
        self.include_extensions = True
        self.generate_summary = False
        self.custom_model = None  # New attribute for custom model

    def _setup_gitignore(self) -> Optional[object]:
        """Setup gitignore matcher if .gitignore exists"""
        gitignore_path = self.project_path / '.gitignore'
        if gitignore_path.exists():
            try:
                return gitignore_parser.parse_gitignore(gitignore_path)
            except Exception as e:
                print(f"Warning: Failed to parse .gitignore: {e}")
        return None

    def _should_include_file(self, file_path: Path) -> bool:
        """Check if file should be included based on extension and ignore rules"""
        excluded_dirs = {
            '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
            '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
            'dist', 'build', 'target'
        }

        try:
            try:
                rel_path = file_path.relative_to(self.project_path)
            except ValueError:
                if self.debug:
                    print(f"Debug: Skipping file outside project path: {file_path}")
                return False

            if any(part in excluded_dirs for part in file_path.parts):
                if self.debug:
                    print(f"Debug: Skipping excluded directory: {file_path}")
                return False

            if self.include_extensions and file_path.suffix.lower() not in SOURCE_EXTENSIONS:
                if self.debug:
                    print(f"Debug: Skipping non-source file: {file_path}")
                return False

            for pattern in IGNORE_PATTERNS:
                if fnmatch.fnmatch(str(rel_path), pattern):
                    if self.debug:
                        print(f"Debug: Skipping ignored pattern {pattern}: {file_path}")
                    return False

            if self.gitignore_matcher:
                try:
                    should_include = not self.gitignore_matcher(str(file_path))
                    if self.debug and not should_include:
                        print(f"Debug: Skipping gitignored file: {file_path}")
                    return should_include
                except Exception as e:
                    print(f"Warning: gitignore matching failed for {file_path}: {e}")
                    return True

            if self.debug:
                print(f"Debug: Including file: {file_path}")
            return True

        except Exception as e:
            print(f"Warning: Error checking file {file_path}: {e}")
            return False

    def _get_file_content(self, file_path: Path) -> str:
        """Read file content with proper encoding handling"""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                return f.read()
        except UnicodeDecodeError:
            try:
                with open(file_path, 'r', encoding='latin-1') as f:
                    return f.read()
            except Exception as e:
                print(f"Warning: Failed to read {file_path}: {e}")
                return f"ERROR: Could not read file {file_path}\n"

    def _generate_directory_structure(self) -> str:
        """Generate a tree-like directory structure"""
        structure = ["Directory Structure:", ""]

        def add_to_tree(path: Path, prefix: str = ""):
            excluded_dirs = {
                '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
                '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
                'dist', 'build', 'target'
            }
            if path.name in excluded_dirs:
                return

            files = sorted([p for p in path.iterdir() if p.is_file()])
            included_files = [f for f in files if self._should_include_file(f)]

            for idx, file in enumerate(included_files):
                is_last = idx == len(included_files) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {file.name}")

            dirs = sorted([p for p in path.iterdir() if p.is_dir()])
            included_dirs = [d for d in dirs if d.name not in excluded_dirs]

            for idx, dir in enumerate(included_dirs):
                is_last = idx == len(included_dirs) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {dir.name}/")
                add_to_tree(dir, prefix + ("    " if is_last else "│   "))

        add_to_tree(self.project_path)
        return "\n".join(structure)

    def concatenate(self, debug: bool = False):
        """Main method to concatenate all source files"""
        self.debug = debug
        if not self.project_path.exists():
            print(f"Error: Project path {self.project_path} does not exist")
            return False

        try:
            with open(self.output_file, 'w', encoding='utf-8') as out:
                header = f"""
# Project Source Code Concatenation
# Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
# Project path: {self.project_path}

"""
                out.write(header)

                if self.include_structure:
                    out.write(self._generate_directory_structure())
                    out.write("\n\n" + "="*80 + "\n\n")

                file_count = 0
                for file_path in self.project_path.rglob('*'):
                    if file_path.is_file() and self._should_include_file(file_path):
                        rel_path = file_path.relative_to(self.project_path)

                        out.write(f"\n\n# File: {rel_path}\n")
                        out.write("="*80 + "\n\n")

                        content = self._get_file_content(file_path)
                        out.write(content)
                        file_count += 1

                print(f"Successfully melted {file_count} files to {self.output_file}")

                if self.generate_summary and file_count > 0:
                    print("Generating AI documentation summary...")
                    summary_path = self.output_file.with_suffix('.summary.md')

                    with open(self.output_file, 'r', encoding='utf-8') as f:
                        content = f.read()

                    summary = try_all_providers(content, self.custom_model)
                    if summary:
                        with open(summary_path, 'w', encoding='utf-8') as f:
                            f.write(summary)
                        print(f"Generated AI summary: {summary_path}")
                    else:
                        print("Warning: Could not generate AI summary. "
                              "Make sure either OPENAI_API_KEY or XAI_API_KEY "
                              "environment variable is set.")

                return True

        except Exception as e:
            print(f"Error during melting: {e}")
            return False

def main():
    parser = argparse.ArgumentParser(
        description="CodeSmelt: Melt down your git project's source code into a single file",
        usage="%(prog)s project_path [output_file] [-o OUTPUT] [-d] [-n] [-e] [-s] [-m MODEL]"
    )

    parser.add_argument(
        "project_path",
        help="Path to the git project directory"
    )

    parser.add_argument(
        "output_file",
        nargs="?",
        help="Output file path (alternative to -o)",
        default=None
    )

    parser.add_argument(
        "-o", "--output",
        help="Output file path (default: concatenated_source.txt)",
        default=None
    )

    parser.add_argument(
        "-d", "--debug",
        action="store_true",
        help="Enable debug logging"
    )

    parser.add_argument(
        "-n", "--no-structure",
        action="store_true",
        help="Omit directory structure from output"
    )

    parser.add_argument(
        "-e", "--no-extensions",
        action="store_true",
        help="Disable file extension filtering"
    )

    parser.add_argument(
        "-s", "--summary",
        action="store_true",
        help="Generate AI documentation summary (requires OpenAI or xAI API key)"
    )

    parser.add_argument(
        "-m", "--model",
        help="Specify custom AI model (e.g., 'gpt-4', 'gpt-3.5-turbo' for OpenAI or 'grok-2-1212', 'grok-2-vision-1212' for xAI)",
        default=None
    )

    args = parser.parse_args()

    output_file = args.output or args.output_file or "concatenated_source.txt"

    concatenator = CodeSmelt(args.project_path, output_file)
    concatenator.include_structure = not args.no_structure
    concatenator.include_extensions = not args.no_extensions
    concatenator.generate_summary = args.summary
    concatenator.custom_model = args.model  # Pass custom model to CodeSmelt
    success = concatenator.concatenate(debug=args.debug)
    sys.exit(0 if success else 1)

if __name__ == "__main__":
    main()