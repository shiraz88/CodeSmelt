
# Project Source Code Concatenation
# Generated on: 2025-02-15 22:55:16
# Project path: /home/runner/workspace

Directory Structure:

├── README.md
├── codesmelt.py
├── concatenated_source.txt
├── extensions.py
├── output.txt
├── pyproject.toml
└── test_output.txt

================================================================================



# File: extensions.py
================================================================================

"""
Source code file extension configurations
"""

# Common source code file extensions
SOURCE_EXTENSIONS = {
    # Web
    '.js', '.ts', '.jsx', '.tsx', '.vue', '.svelte',
    '.html', '.htm', '.css', '.scss', '.sass', '.less',
    
    # Python
    '.py', '.pyi', '.pyx',
    
    # Java/Kotlin
    '.java', '.kt', '.groovy',
    
    # C-family
    '.c', '.cpp', '.h', '.hpp', '.cc',
    
    # C#
    '.cs', '.cshtml', '.csx',
    
    # Ruby
    '.rb', '.erb',
    
    # PHP
    '.php', '.php5', '.phtml',
    
    # Go
    '.go',
    
    # Rust
    '.rs',
    
    # Swift
    '.swift',
    
    # Shell
    '.sh', '.bash', '.zsh',
    
    # Config/Data
    '.json', '.yaml', '.yml', '.toml', '.xml',
    '.conf', '.ini', '.env',
    
    # Documentation
    '.md', '.rst', '.txt'
}

# Files to always ignore
IGNORE_PATTERNS = {
    # Build outputs
    'build/*', 'dist/*', 'target/*', 'bin/*',
    '*.pyc', '__pycache__/*', '*.class',
    
    # Dependencies
    'node_modules/*', 'vendor/*', 'venv/*',
    
    # IDE files
    '.idea/*', '.vscode/*', '*.swp',
    
    # Package files
    'package-lock.json', 'yarn.lock',
    'Pipfile.lock', 'poetry.lock',
    
    # Large data files
    '*.csv', '*.json.gz', '*.sql',
    
    # Binary/Media files
    '*.pdf', '*.jpg', '*.png', '*.gif',
    '*.mp3', '*.mp4', '*.mov', '*.bin',
    '*.exe', '*.dll', '*.so', '*.dylib'
}


# File: pyproject.toml
================================================================================

[project]
name = "repl-nix-workspace"
version = "0.1.0"
description = "Add your description here"
requires-python = ">=3.11"
dependencies = [
    "gitignore-parser>=0.1.11",
]


# File: concatenated_source.txt
================================================================================


# Project Source Code Concatenation
# Generated on: 2025-02-15 22:55:02
# Project path: /home/runner/workspace

Directory Structure:

├── README.md
├── codesmelt.py
├── concatenated_source.txt
├── extensions.py
├── output.txt
└── pyproject.toml

================================================================================



# File: extensions.py
================================================================================

"""
Source code file extension configurations
"""

# Common source code file extensions
SOURCE_EXTENSIONS = {
    # Web
    '.js', '.ts', '.jsx', '.tsx', '.vue', '.svelte',
    '.html', '.htm', '.css', '.scss', '.sass', '.less',
    
    # Python
    '.py', '.pyi', '.pyx',
    
    # Java/Kotlin
    '.java', '.kt', '.groovy',
    
    # C-family
    '.c', '.cpp', '.h', '.hpp', '.cc',
    
    # C#
    '.cs', '.cshtml', '.csx',
    
    # Ruby
    '.rb', '.erb',
    
    # PHP
    '.php', '.php5', '.phtml',
    
    # Go
    '.go',
    
    # Rust
    '.rs',
    
    # Swift
    '.swift',
    
    # Shell
    '.sh', '.bash', '.zsh',
    
    # Config/Data
    '.json', '.yaml', '.yml', '.toml', '.xml',
    '.conf', '.ini', '.env',
    
    # Documentation
    '.md', '.rst', '.txt'
}

# Files to always ignore
IGNORE_PATTERNS = {
    # Build outputs
    'build/*', 'dist/*', 'target/*', 'bin/*',
    '*.pyc', '__pycache__/*', '*.class',
    
    # Dependencies
    'node_modules/*', 'vendor/*', 'venv/*',
    
    # IDE files
    '.idea/*', '.vscode/*', '*.swp',
    
    # Package files
    'package-lock.json', 'yarn.lock',
    'Pipfile.lock', 'poetry.lock',
    
    # Large data files
    '*.csv', '*.json.gz', '*.sql',
    
    # Binary/Media files
    '*.pdf', '*.jpg', '*.png', '*.gif',
    '*.mp3', '*.mp4', '*.mov', '*.bin',
    '*.exe', '*.dll', '*.so', '*.dylib'
}


# File: pyproject.toml
================================================================================

[project]
name = "repl-nix-workspace"
version = "0.1.0"
description = "Add your description here"
requires-python = ">=3.11"
dependencies = [
    "gitignore-parser>=0.1.11",
]


# File: concatenated_source.txt
================================================================================



# File: output.txt
================================================================================


# Project Source Code Concatenation
# Generated on: 2025-02-15 22:44:33
# Project path: /home/runner/workspace

Directory Structure:

├── README.md
├── codesmelt.py
├── concatenated_source.txt
├── extensions.py
├── output.txt
└── pyproject.toml

================================================================================



# File: extensions.py
================================================================================

"""
Source code file extension configurations
"""

# Common source code file extensions
SOURCE_EXTENSIONS = {
    # Web
    '.js', '.ts', '.jsx', '.tsx', '.vue', '.svelte',
    '.html', '.htm', '.css', '.scss', '.sass', '.less',
    
    # Python
    '.py', '.pyi', '.pyx',
    
    # Java/Kotlin
    '.java', '.kt', '.groovy',
    
    # C-family
    '.c', '.cpp', '.h', '.hpp', '.cc',
    
    # C#
    '.cs', '.cshtml', '.csx',
    
    # Ruby
    '.rb', '.erb',
    
    # PHP
    '.php', '.php5', '.phtml',
    
    # Go
    '.go',
    
    # Rust
    '.rs',
    
    # Swift
    '.swift',
    
    # Shell
    '.sh', '.bash', '.zsh',
    
    # Config/Data
    '.json', '.yaml', '.yml', '.toml', '.xml',
    '.conf', '.ini', '.env',
    
    # Documentation
    '.md', '.rst', '.txt'
}

# Files to always ignore
IGNORE_PATTERNS = {
    # Build outputs
    'build/*', 'dist/*', 'target/*', 'bin/*',
    '*.pyc', '__pycache__/*', '*.class',
    
    # Dependencies
    'node_modules/*', 'vendor/*', 'venv/*',
    
    # IDE files
    '.idea/*', '.vscode/*', '*.swp',
    
    # Package files
    'package-lock.json', 'yarn.lock',
    'Pipfile.lock', 'poetry.lock',
    
    # Large data files
    '*.csv', '*.json.gz', '*.sql',
    
    # Binary/Media files
    '*.pdf', '*.jpg', '*.png', '*.gif',
    '*.mp3', '*.mp4', '*.mov', '*.bin',
    '*.exe', '*.dll', '*.so', '*.dylib'
}


# File: pyproject.toml
================================================================================

[project]
name = "repl-nix-workspace"
version = "0.1.0"
description = "Add your description here"
requires-python = ">=3.11"
dependencies = [
    "gitignore-parser>=0.1.11",
]


# File: concatenated_source.txt
================================================================================


# Project Source Code Concatenation
# Generated on: 2025-02-15 21:22:24
# Project path: /home/runner/workspace

Directory Structure:

├── README.md
├── concatenated_source.txt
├── extensions.py
├── git_concatenator.py
└── pyproject.toml

================================================================================



# File: extensions.py
================================================================================

"""
Source code file extension configurations
"""

# Common source code file extensions
SOURCE_EXTENSIONS = {
    # Web
    '.js', '.ts', '.jsx', '.tsx', '.vue', '.svelte',
    '.html', '.htm', '.css', '.scss', '.sass', '.less',
    
    # Python
    '.py', '.pyi', '.pyx',
    
    # Java/Kotlin
    '.java', '.kt', '.groovy',
    
    # C-family
    '.c', '.cpp', '.h', '.hpp', '.cc',
    
    # C#
    '.cs', '.cshtml', '.csx',
    
    # Ruby
    '.rb', '.erb',
    
    # PHP
    '.php', '.php5', '.phtml',
    
    # Go
    '.go',
    
    # Rust
    '.rs',
    
    # Swift
    '.swift',
    
    # Shell
    '.sh', '.bash', '.zsh',
    
    # Config/Data
    '.json', '.yaml', '.yml', '.toml', '.xml',
    '.conf', '.ini', '.env',
    
    # Documentation
    '.md', '.rst', '.txt'
}

# Files to always ignore
IGNORE_PATTERNS = {
    # Build outputs
    'build/*', 'dist/*', 'target/*', 'bin/*',
    '*.pyc', '__pycache__/*', '*.class',
    
    # Dependencies
    'node_modules/*', 'vendor/*', 'venv/*',
    
    # IDE files
    '.idea/*', '.vscode/*', '*.swp',
    
    # Package files
    'package-lock.json', 'yarn.lock',
    'Pipfile.lock', 'poetry.lock',
    
    # Large data files
    '*.csv', '*.json.gz', '*.sql',
    
    # Binary/Media files
    '*.pdf', '*.jpg', '*.png', '*.gif',
    '*.mp3', '*.mp4', '*.mov', '*.bin',
    '*.exe', '*.dll', '*.so', '*.dylib'
}


# File: pyproject.toml
================================================================================

[project]
name = "repl-nix-workspace"
version = "0.1.0"
description = "Add your description here"
requires-python = ">=3.11"
dependencies = [
    "gitignore-parser>=0.1.11",
]


# File: concatenated_source.txt
================================================================================



# File: git_concatenator.py
================================================================================

#!/usr/bin/env python3
"""
Git Project Source Code Concatenator

This tool concatenates source code files from a git project into a single file,
including directory structure information.
"""

import argparse
import sys
from pathlib import Path
import os
from typing import Set, List, Optional
import fnmatch
from datetime import datetime
import gitignore_parser
from extensions import SOURCE_EXTENSIONS, IGNORE_PATTERNS

class GitConcatenator:
    def __init__(self, project_path: str, output_file: str):
        self.project_path = Path(project_path).resolve()
        self.output_file = Path(output_file)
        self.gitignore_matcher = self._setup_gitignore()
        self.debug = False

    def _setup_gitignore(self) -> Optional[callable]:
        """Setup gitignore matcher if .gitignore exists"""
        gitignore_path = self.project_path / '.gitignore'
        if gitignore_path.exists():
            try:
                return gitignore_parser.parse_gitignore(gitignore_path)
            except Exception as e:
                print(f"Warning: Failed to parse .gitignore: {e}")
        return None

    def _should_include_file(self, file_path: Path) -> bool:
        """Check if file should be included based on extension and ignore rules"""
        # Skip common virtual environment and system directories
        excluded_dirs = {
            '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
            '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
            'dist', 'build', 'target'
        }

        try:
            # Convert to relative path for checking
            try:
                rel_path = file_path.relative_to(self.project_path)
            except ValueError:
                if self.debug:
                    print(f"Debug: Skipping file outside project path: {file_path}")
                return False

            # Check for excluded directories in the path
            if any(part in excluded_dirs for part in file_path.parts):
                if self.debug:
                    print(f"Debug: Skipping excluded directory: {file_path}")
                return False

            # Check if file extension is in whitelist
            if file_path.suffix.lower() not in SOURCE_EXTENSIONS:
                if self.debug:
                    print(f"Debug: Skipping non-source file: {file_path}")
                return False

            # Check custom ignore patterns
            for pattern in IGNORE_PATTERNS:
                if fnmatch.fnmatch(str(rel_path), pattern):
                    if self.debug:
                        print(f"Debug: Skipping ignored pattern {pattern}: {file_path}")
                    return False

            # Check .gitignore if available
            if self.gitignore_matcher:
                try:
                    should_include = not self.gitignore_matcher(str(file_path))
                    if self.debug and not should_include:
                        print(f"Debug: Skipping gitignored file: {file_path}")
                    return should_include
                except Exception as e:
                    print(f"Warning: gitignore matching failed for {file_path}: {e}")
                    return True

            if self.debug:
                print(f"Debug: Including file: {file_path}")
            return True

        except Exception as e:
            print(f"Warning: Error checking file {file_path}: {e}")
            return False

    def _get_file_content(self, file_path: Path) -> str:
        """Read file content with proper encoding handling"""
        try:
            # Try UTF-8 first
            with open(file_path, 'r', encoding='utf-8') as f:
                return f.read()
        except UnicodeDecodeError:
            try:
                # Fallback to latin-1
                with open(file_path, 'r', encoding='latin-1') as f:
                    return f.read()
            except Exception as e:
                print(f"Warning: Failed to read {file_path}: {e}")
                return f"ERROR: Could not read file {file_path}\n"

    def _generate_directory_structure(self) -> str:
        """Generate a tree-like directory structure"""
        structure = ["Directory Structure:", ""]

        def add_to_tree(path: Path, prefix: str = ""):
            # Skip excluded directories
            excluded_dirs = {
                '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
                '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
                'dist', 'build', 'target'
            }
            if path.name in excluded_dirs:
                return

            # Add files first
            files = sorted([p for p in path.iterdir() if p.is_file()])
            included_files = [f for f in files if self._should_include_file(f)]

            for idx, file in enumerate(included_files):
                is_last = idx == len(included_files) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {file.name}")

            # Then add directories
            dirs = sorted([p for p in path.iterdir() if p.is_dir()])
            included_dirs = [d for d in dirs if d.name not in excluded_dirs]

            for idx, dir in enumerate(included_dirs):
                is_last = idx == len(included_dirs) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {dir.name}/")
                add_to_tree(dir, prefix + ("    " if is_last else "│   "))

        add_to_tree(self.project_path)
        return "\n".join(structure)

    def concatenate(self, debug: bool = False):
        """Main method to concatenate all source files"""
        self.debug = debug
        if not self.project_path.exists():
            print(f"Error: Project path {self.project_path} does not exist")
            return False

        try:
            with open(self.output_file, 'w', encoding='utf-8') as out:
                # Write header
                header = f"""
# Project Source Code Concatenation
# Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
# Project path: {self.project_path}

"""
                out.write(header)

                # Write directory structure
                out.write(self._generate_directory_structure())
                out.write("\n\n" + "="*80 + "\n\n")

                # Process all files
                file_count = 0
                for file_path in self.project_path.rglob('*'):
                    if file_path.is_file() and self._should_include_file(file_path):
                        rel_path = file_path.relative_to(self.project_path)

                        # Write file header
                        out.write(f"\n\n# File: {rel_path}\n")
                        out.write("="*80 + "\n\n")

                        # Write file content
                        content = self._get_file_content(file_path)
                        out.write(content)
                        file_count += 1

                print(f"Successfully concatenated {file_count} files to {self.output_file}")
                return True

        except Exception as e:
            print(f"Error during concatenation: {e}")
            return False

def main():
    parser = argparse.ArgumentParser(
        description="Concatenate git project source code into a single file"
    )
    parser.add_argument(
        "project_path",
        help="Path to the git project directory"
    )
    parser.add_argument(
        "-o", "--output",
        default="concatenated_source.txt",
        help="Output file path (default: concatenated_source.txt)"
    )
    parser.add_argument(
        "-d", "--debug",
        action="store_true",
        help="Enable debug logging"
    )

    args = parser.parse_args()

    concatenator = GitConcatenator(args.project_path, args.output)
    success = concatenator.concatenate(debug=args.debug)
    sys.exit(0 if success else 1)

if __name__ == "__main__":
    main()

# File: README.md
================================================================================

git clone https://github.com/yourusername/git-concatenator.git
   cd git-concatenator
   ```

2. Ensure you have Python 3.11 or later installed:
   ```bash
   python --version
   ```

3. Install the required dependency:
   ```bash
   pip install gitignore-parser
   ```

## Usage

Basic usage:
```bash
python git_concatenator.py /path/to/project -o output.txt
```

With debug logging:
```bash
python git_concatenator.py /path/to/project -o output.txt --debug
```

### Command-line Arguments

- `project_path`: Path to the Git project directory (required)
- `-o, --output`: Output file path (default: concatenated_source.txt)
- `-d, --debug`: Enable debug logging

## Output Format

The generated file includes:
1. A timestamp and project path header
2. A visual directory structure of the project
3. The contents of each source file, clearly separated with headers

Example output:
```
# Project Source Code Concatenation
# Generated on: 2025-02-15 20:53:29
# Project path: /path/to/project

Directory Structure:
├── src/
│   ├── main.py
│   └── utils.py
└── README.md

================================================================================

# File: src/main.py
================================================================================
[File contents here]

# File: src/utils.py
================================================================================
[File contents here]

# File: output.txt
================================================================================


# Project Source Code Concatenation
# Generated on: 2025-02-15 22:44:33
# Project path: /home/runner/workspace

Directory Structure:

├── README.md
├── codesmelt.py
├── concatenated_source.txt
├── extensions.py
├── output.txt
└── pyproject.toml

================================================================================



# File: extensions.py
================================================================================

"""
Source code file extension configurations
"""

# Common source code file extensions
SOURCE_EXTENSIONS = {
    # Web
    '.js', '.ts', '.jsx', '.tsx', '.vue', '.svelte',
    '.html', '.htm', '.css', '.scss', '.sass', '.less',
    
    # Python
    '.py', '.pyi', '.pyx',
    
    # Java/Kotlin
    '.java', '.kt', '.groovy',
    
    # C-family
    '.c', '.cpp', '.h', '.hpp', '.cc',
    
    # C#
    '.cs', '.cshtml', '.csx',
    
    # Ruby
    '.rb', '.erb',
    
    # PHP
    '.php', '.php5', '.phtml',
    
    # Go
    '.go',
    
    # Rust
    '.rs',
    
    # Swift
    '.swift',
    
    # Shell
    '.sh', '.bash', '.zsh',
    
    # Config/Data
    '.json', '.yaml', '.yml', '.toml', '.xml',
    '.conf', '.ini', '.env',
    
    # Documentation
    '.md', '.rst', '.txt'
}

# Files to always ignore
IGNORE_PATTERNS = {
    # Build outputs
    'build/*', 'dist/*', 'target/*', 'bin/*',
    '*.pyc', '__pycache__/*', '*.class',
    
    # Dependencies
    'node_modules/*', 'vendor/*', 'venv/*',
    
    # IDE files
    '.idea/*', '.vscode/*', '*.swp',
    
    # Package files
    'package-lock.json', 'yarn.lock',
    'Pipfile.lock', 'poetry.lock',
    
    # Large data files
    '*.csv', '*.json.gz', '*.sql',
    
    # Binary/Media files
    '*.pdf', '*.jpg', '*.png', '*.gif',
    '*.mp3', '*.mp4', '*.mov', '*.bin',
    '*.exe', '*.dll', '*.so', '*.dylib'
}


# File: pyproject.toml
================================================================================

[project]
name = "repl-nix-workspace"
version = "0.1.0"
description = "Add your description here"
requires-python = ">=3.11"
dependencies = [
    "gitignore-parser>=0.1.11",
]


# File: concatenated_source.txt
================================================================================


# Project Source Code Concatenation
# Generated on: 2025-02-15 21:22:24
# Project path: /home/runner/workspace

Directory Structure:

├── README.md
├── concatenated_source.txt
├── extensions.py
├── git_concatenator.py
└── pyproject.toml

================================================================================



# File: extensions.py
================================================================================

"""
Source code file extension configurations
"""

# Common source code file extensions
SOURCE_EXTENSIONS = {
    # Web
    '.js', '.ts', '.jsx', '.tsx', '.vue', '.svelte',
    '.html', '.htm', '.css', '.scss', '.sass', '.less',
    
    # Python
    '.py', '.pyi', '.pyx',
    
    # Java/Kotlin
    '.java', '.kt', '.groovy',
    
    # C-family
    '.c', '.cpp', '.h', '.hpp', '.cc',
    
    # C#
    '.cs', '.cshtml', '.csx',
    
    # Ruby
    '.rb', '.erb',
    
    # PHP
    '.php', '.php5', '.phtml',
    
    # Go
    '.go',
    
    # Rust
    '.rs',
    
    # Swift
    '.swift',
    
    # Shell
    '.sh', '.bash', '.zsh',
    
    # Config/Data
    '.json', '.yaml', '.yml', '.toml', '.xml',
    '.conf', '.ini', '.env',
    
    # Documentation
    '.md', '.rst', '.txt'
}

# Files to always ignore
IGNORE_PATTERNS = {
    # Build outputs
    'build/*', 'dist/*', 'target/*', 'bin/*',
    '*.pyc', '__pycache__/*', '*.class',
    
    # Dependencies
    'node_modules/*', 'vendor/*', 'venv/*',
    
    # IDE files
    '.idea/*', '.vscode/*', '*.swp',
    
    # Package files
    'package-lock.json', 'yarn.lock',
    'Pipfile.lock', 'poetry.lock',
    
    # Large data files
    '*.csv', '*.json.gz', '*.sql',
    
    # Binary/Media files
    '*.pdf', '*.jpg', '*.png', '*.gif',
    '*.mp3', '*.mp4', '*.mov', '*.bin',
    '*.exe', '*.dll', '*.so', '*.dylib'
}


# File: pyproject.toml
================================================================================

[project]
name = "repl-nix-workspace"
version = "0.1.0"
description = "Add your description here"
requires-python = ">=3.11"
dependencies = [
    "gitignore-parser>=0.1.11",
]


# File: concatenated_source.txt
================================================================================



# File: git_concatenator.py
================================================================================

#!/usr/bin/env python3
"""
Git Project Source Code Concatenator

This tool concatenates source code files from a git project into a single file,
including directory structure information.
"""

import argparse
import sys
from pathlib import Path
import os
from typing import Set, List, Optional
import fnmatch
from datetime import datetime
import gitignore_parser
from extensions import SOURCE_EXTENSIONS, IGNORE_PATTERNS

class GitConcatenator:
    def __init__(self, project_path: str, output_file: str):
        self.project_path = Path(project_path).resolve()
        self.output_file = Path(output_file)
        self.gitignore_matcher = self._setup_gitignore()
        self.debug = False

    def _setup_gitignore(self) -> Optional[callable]:
        """Setup gitignore matcher if .gitignore exists"""
        gitignore_path = self.project_path / '.gitignore'
        if gitignore_path.exists():
            try:
                return gitignore_parser.parse_gitignore(gitignore_path)
            except Exception as e:
                print(f"Warning: Failed to parse .gitignore: {e}")
        return None

    def _should_include_file(self, file_path: Path) -> bool:
        """Check if file should be included based on extension and ignore rules"""
        # Skip common virtual environment and system directories
        excluded_dirs = {
            '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
            '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
            'dist', 'build', 'target'
        }

        try:
            # Convert to relative path for checking
            try:
                rel_path = file_path.relative_to(self.project_path)
            except ValueError:
                if self.debug:
                    print(f"Debug: Skipping file outside project path: {file_path}")
                return False

            # Check for excluded directories in the path
            if any(part in excluded_dirs for part in file_path.parts):
                if self.debug:
                    print(f"Debug: Skipping excluded directory: {file_path}")
                return False

            # Check if file extension is in whitelist
            if file_path.suffix.lower() not in SOURCE_EXTENSIONS:
                if self.debug:
                    print(f"Debug: Skipping non-source file: {file_path}")
                return False

            # Check custom ignore patterns
            for pattern in IGNORE_PATTERNS:
                if fnmatch.fnmatch(str(rel_path), pattern):
                    if self.debug:
                        print(f"Debug: Skipping ignored pattern {pattern}: {file_path}")
                    return False

            # Check .gitignore if available
            if self.gitignore_matcher:
                try:
                    should_include = not self.gitignore_matcher(str(file_path))
                    if self.debug and not should_include:
                        print(f"Debug: Skipping gitignored file: {file_path}")
                    return should_include
                except Exception as e:
                    print(f"Warning: gitignore matching failed for {file_path}: {e}")
                    return True

            if self.debug:
                print(f"Debug: Including file: {file_path}")
            return True

        except Exception as e:
            print(f"Warning: Error checking file {file_path}: {e}")
            return False

    def _get_file_content(self, file_path: Path) -> str:
        """Read file content with proper encoding handling"""
        try:
            # Try UTF-8 first
            with open(file_path, 'r', encoding='utf-8') as f:
                return f.read()
        except UnicodeDecodeError:
            try:
                # Fallback to latin-1
                with open(file_path, 'r', encoding='latin-1') as f:
                    return f.read()
            except Exception as e:
                print(f"Warning: Failed to read {file_path}: {e}")
                return f"ERROR: Could not read file {file_path}\n"

    def _generate_directory_structure(self) -> str:
        """Generate a tree-like directory structure"""
        structure = ["Directory Structure:", ""]

        def add_to_tree(path: Path, prefix: str = ""):
            # Skip excluded directories
            excluded_dirs = {
                '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
                '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
                'dist', 'build', 'target'
            }
            if path.name in excluded_dirs:
                return

            # Add files first
            files = sorted([p for p in path.iterdir() if p.is_file()])
            included_files = [f for f in files if self._should_include_file(f)]

            for idx, file in enumerate(included_files):
                is_last = idx == len(included_files) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {file.name}")

            # Then add directories
            dirs = sorted([p for p in path.iterdir() if p.is_dir()])
            included_dirs = [d for d in dirs if d.name not in excluded_dirs]

            for idx, dir in enumerate(included_dirs):
                is_last = idx == len(included_dirs) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {dir.name}/")
                add_to_tree(dir, prefix + ("    " if is_last else "│   "))

        add_to_tree(self.project_path)
        return "\n".join(structure)

    def concatenate(self, debug: bool = False):
        """Main method to concatenate all source files"""
        self.debug = debug
        if not self.project_path.exists():
            print(f"Error: Project path {self.project_path} does not exist")
            return False

        try:
            with open(self.output_file, 'w', encoding='utf-8') as out:
                # Write header
                header = f"""
# Project Source Code Concatenation
# Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
# Project path: {self.project_path}

"""
                out.write(header)

                # Write directory structure
                out.write(self._generate_directory_structure())
                out.write("\n\n" + "="*80 + "\n\n")

                # Process all files
                file_count = 0
                for file_path in self.project_path.rglob('*'):
                    if file_path.is_file() and self._should_include_file(file_path):
                        rel_path = file_path.relative_to(self.project_path)

                        # Write file header
                        out.write(f"\n\n# File: {rel_path}\n")
                        out.write("="*80 + "\n\n")

                        # Write file content
                        content = self._get_file_content(file_path)
                        out.write(content)
                        file_count += 1

                print(f"Successfully concatenated {file_count} files to {self.output_file}")
                return True

        except Exception as e:
            print(f"Error during concatenation: {e}")
            return False

def main():
    parser = argparse.ArgumentParser(
        description="Concatenate git project source code into a single file"
    )
    parser.add_argument(
        "project_path",
        help="Path to the git project directory"
    )
    parser.add_argument(
        "-o", "--output",
        default="concatenated_source.txt",
        help="Output file path (default: concatenated_source.txt)"
    )
    parser.add_argument(
        "-d", "--debug",
        action="store_true",
        help="Enable debug logging"
    )

    args = parser.parse_args()

    concatenator = GitConcatenator(args.project_path, args.output)
    success = concatenator.concatenate(debug=args.debug)
    sys.exit(0 if success else 1)

if __name__ == "__main__":
    main()

# File: README.md
================================================================================

git clone https://github.com/yourusername/git-concatenator.git
   cd git-concatenator
   ```

2. Ensure you have Python 3.11 or later installed:
   ```bash
   python --version
   ```

3. Install the required dependency:
   ```bash
   pip install gitignore-parser
   ```

## Usage

Basic usage:
```bash
python git_concatenator.py /path/to/project -o output.txt
```

With debug logging:
```bash
python git_concatenator.py /path/to/project -o output.txt --debug
```

### Command-line Arguments

- `project_path`: Path to the Git project directory (required)
- `-o, --output`: Output file path (default: concatenated_source.txt)
- `-d, --debug`: Enable debug logging

## Output Format

The generated file includes:
1. A timestamp and project path header
2. A visual directory structure of the project
3. The contents of each source file, clearly separated with headers

Example output:
```
# Project Source Code Concatenation
# Generated on: 2025-02-15 20:53:29
# Project path: /path/to/project

Directory Structure:
├── src/
│   ├── main.py
│   └── utils.py
└── README.md

================================================================================

# File: src/main.py
================================================================================
[File contents here]

# File: src/utils.py
================================================================================
[File contents here]

# File: codesmelt.py
================================================================================

#!/usr/bin/env python3
"""
CodeSmelt: Source Code Concatenator

This tool melts down source code files from a git project into a single file,
including directory structure information.
"""

import argparse
import sys
from pathlib import Path
import os
from typing import Set, List, Optional
import fnmatch
from datetime import datetime
import gitignore_parser
from extensions import SOURCE_EXTENSIONS, IGNORE_PATTERNS

class CodeSmelt:
    def __init__(self, project_path: str, output_file: str):
        self.project_path = Path(project_path).resolve()
        self.output_file = Path(output_file)
        self.gitignore_matcher = self._setup_gitignore()
        self.debug = False

    def _setup_gitignore(self) -> Optional[callable]:
        """Setup gitignore matcher if .gitignore exists"""
        gitignore_path = self.project_path / '.gitignore'
        if gitignore_path.exists():
            try:
                return gitignore_parser.parse_gitignore(gitignore_path)
            except Exception as e:
                print(f"Warning: Failed to parse .gitignore: {e}")
        return None

    def _should_include_file(self, file_path: Path) -> bool:
        """Check if file should be included based on extension and ignore rules"""
        # Skip common virtual environment and system directories
        excluded_dirs = {
            '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
            '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
            'dist', 'build', 'target'
        }

        try:
            # Convert to relative path for checking
            try:
                rel_path = file_path.relative_to(self.project_path)
            except ValueError:
                if self.debug:
                    print(f"Debug: Skipping file outside project path: {file_path}")
                return False

            # Check for excluded directories in the path
            if any(part in excluded_dirs for part in file_path.parts):
                if self.debug:
                    print(f"Debug: Skipping excluded directory: {file_path}")
                return False

            # Check if file extension is in whitelist
            if file_path.suffix.lower() not in SOURCE_EXTENSIONS:
                if self.debug:
                    print(f"Debug: Skipping non-source file: {file_path}")
                return False

            # Check custom ignore patterns
            for pattern in IGNORE_PATTERNS:
                if fnmatch.fnmatch(str(rel_path), pattern):
                    if self.debug:
                        print(f"Debug: Skipping ignored pattern {pattern}: {file_path}")
                    return False

            # Check .gitignore if available
            if self.gitignore_matcher:
                try:
                    should_include = not self.gitignore_matcher(str(file_path))
                    if self.debug and not should_include:
                        print(f"Debug: Skipping gitignored file: {file_path}")
                    return should_include
                except Exception as e:
                    print(f"Warning: gitignore matching failed for {file_path}: {e}")
                    return True

            if self.debug:
                print(f"Debug: Including file: {file_path}")
            return True

        except Exception as e:
            print(f"Warning: Error checking file {file_path}: {e}")
            return False

    def _get_file_content(self, file_path: Path) -> str:
        """Read file content with proper encoding handling"""
        try:
            # Try UTF-8 first
            with open(file_path, 'r', encoding='utf-8') as f:
                return f.read()
        except UnicodeDecodeError:
            try:
                # Fallback to latin-1
                with open(file_path, 'r', encoding='latin-1') as f:
                    return f.read()
            except Exception as e:
                print(f"Warning: Failed to read {file_path}: {e}")
                return f"ERROR: Could not read file {file_path}\n"

    def _generate_directory_structure(self) -> str:
        """Generate a tree-like directory structure"""
        structure = ["Directory Structure:", ""]

        def add_to_tree(path: Path, prefix: str = ""):
            # Skip excluded directories
            excluded_dirs = {
                '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
                '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
                'dist', 'build', 'target'
            }
            if path.name in excluded_dirs:
                return

            # Add files first
            files = sorted([p for p in path.iterdir() if p.is_file()])
            included_files = [f for f in files if self._should_include_file(f)]

            for idx, file in enumerate(included_files):
                is_last = idx == len(included_files) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {file.name}")

            # Then add directories
            dirs = sorted([p for p in path.iterdir() if p.is_dir()])
            included_dirs = [d for d in dirs if d.name not in excluded_dirs]

            for idx, dir in enumerate(included_dirs):
                is_last = idx == len(included_dirs) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {dir.name}/")
                add_to_tree(dir, prefix + ("    " if is_last else "│   "))

        add_to_tree(self.project_path)
        return "\n".join(structure)

    def concatenate(self, debug: bool = False):
        """Main method to concatenate all source files"""
        self.debug = debug
        if not self.project_path.exists():
            print(f"Error: Project path {self.project_path} does not exist")
            return False

        try:
            with open(self.output_file, 'w', encoding='utf-8') as out:
                # Write header
                header = f"""
# Project Source Code Concatenation
# Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
# Project path: {self.project_path}

"""
                out.write(header)

                # Write directory structure
                out.write(self._generate_directory_structure())
                out.write("\n\n" + "="*80 + "\n\n")

                # Process all files
                file_count = 0
                for file_path in self.project_path.rglob('*'):
                    if file_path.is_file() and self._should_include_file(file_path):
                        rel_path = file_path.relative_to(self.project_path)

                        # Write file header
                        out.write(f"\n\n# File: {rel_path}\n")
                        out.write("="*80 + "\n\n")

                        # Write file content
                        content = self._get_file_content(file_path)
                        out.write(content)
                        file_count += 1

                print(f"Successfully melted {file_count} files to {self.output_file}")
                return True

        except Exception as e:
            print(f"Error during melting: {e}")
            return False

def main():
    parser = argparse.ArgumentParser(
        description="CodeSmelt: Melt down your git project's source code into a single file"
    )
    parser.add_argument(
        "project_path",
        help="Path to the git project directory"
    )
    parser.add_argument(
        "-o", "--output",
        default="concatenated_source.txt",
        help="Output file path (default: concatenated_source.txt)"
    )
    parser.add_argument(
        "-d", "--debug",
        action="store_true",
        help="Enable debug logging"
    )

    args = parser.parse_args()

    concatenator = CodeSmelt(args.project_path, args.output)
    success = concatenator.concatenate(debug=args.debug)
    sys.exit(0 if success else 1)

if __name__ == "__main__":
    main()

# File: README.md
================================================================================

python --version
   ```

2. Install the required dependency:
   ```bash
   pip install gitignore-parser
   ```

## Usage

Basic usage:
```bash
python codesmelt.py /path/to/project -o output.txt
```

With debug logging:
```bash
python codesmelt.py /path/to/project -o output.txt --debug
```

### Command-line Arguments

- `project_path`: Path to the Git project directory (required)
- `-o, --output`: Output file path (default: concatenated_source.txt)
- `-d, --debug`: Enable debug logging

## Configuration

### Source File Extensions
The tool includes common source code file extensions by default (defined in `extensions.py`):
- Web: `.js`, `.ts`, `.jsx`, `.tsx`, `.vue`, `.svelte`, `.html`, `.css`, etc.
- Python: `.py`, `.pyi`, `.pyx`
- Java/Kotlin: `.java`, `.kt`, `.groovy`
- C-family: `.c`, `.cpp`, `.h`, `.hpp`
- And many more...

#### Customizing File Extensions
You can modify which file extensions are included by editing the `SOURCE_EXTENSIONS` set in `extensions.py`. For example, to include Unity3D script files while excluding other Unity files:

```python
SOURCE_EXTENSIONS = {
    # ... existing extensions ...

    # Unity3D specific
    '.cs',  # C# scripts
    '.shader', # Custom shaders
    '.asmdef', # Assembly definitions

    # ... other extensions ...
}
```

### Ignore Patterns
The tool automatically ignores files based on three levels:

1. Built-in patterns (`IGNORE_PATTERNS` in `extensions.py`):
   - Build outputs (`build/*`, `dist/*`, `*.pyc`, etc.)
   - Dependencies (`node_modules/*`, `vendor/*`, `venv/*`)
   - IDE files (`.idea/*`, `.vscode/*`)
   - Package lock files (`package-lock.json`, `poetry.lock`, etc.)
   - Binary and media files (`*.pdf`, `*.jpg`, `*.exe`, etc.)

2. Project's `.gitignore` rules (if present)
3. Directory-specific `.gitignore` rules

#### Customizing Ignore Patterns
To modify which files are ignored, you can:

1. Edit `IGNORE_PATTERNS` in `extensions.py`:
```python
IGNORE_PATTERNS = {
    # ... existing patterns ...

    # Unity3D specific ignores
    'Assets/AssetStoreTools/*',
    'Library/*',
    'Temp/*',
    'Logs/*',
    '*.unity',  # Unity scene files
    '*.meta',   # Unity meta files
    '*.prefab', # Unity prefab files

    # ... other patterns ...
}
```

2. Use your project's `.gitignore` file for project-specific exclusions

**Note**: Ignore patterns follow the same syntax as `.gitignore` files. The tool processes these rules in order:
1. Built-in `IGNORE_PATTERNS`
2. Project's root `.gitignore`
3. Directory-specific `.gitignore` files


## Tips for Using with LLMs

1. **Token Management**:
   - For large projects, consider concatenating only specific directories
   - Use the debug mode to see which files are included/excluded
   - Remove unnecessary documentation files if you're close to token limits

2. **Effective Prompting**:
   - Reference files using their relative paths as shown in the directory structure
   - Use the directory structure to ask about specific components
   - Refer to file relationships based on the visual structure

3. **Best Practices**:
   - Review the concatenated output before sending to ensure relevance
   - For large projects, break down analysis into smaller, focused components
   - Use the debug mode to verify file selection when customizing

## Output Format

The generated file includes:
1. A timestamp and project path header
2. A visual directory structure of the project
3. The contents of each source file, clearly separated with headers

Example output:
```
# Project Source Code Concatenation
# Generated on: 2025-02-15 20:53:29
# Project path: /path/to/project

Directory Structure:
├── src/
│   ├── main.py
│   └── utils.py
└── README.md

================================================================================

# File: src/main.py
================================================================================
[File contents here]

# File: src/utils.py
================================================================================
[File contents here]
```

## Troubleshooting

### Common Issues

1. **No Files Found**:
   - Verify the project path is correct
   - Check if files have supported extensions
   - Run with --debug to see which files are being filtered

2. **Missing Dependencies**:
   ```bash
   pip install --upgrade gitignore-parser

# File: codesmelt.py
================================================================================

#!/usr/bin/env python3
"""
CodeSmelt: Source Code Concatenator

This tool melts down source code files from a git project into a single file,
including directory structure information.
"""

import argparse
import sys
from pathlib import Path
import os
from typing import Set, List, Optional
import fnmatch
from datetime import datetime
import gitignore_parser
from extensions import SOURCE_EXTENSIONS, IGNORE_PATTERNS

class CodeSmelt:
    def __init__(self, project_path: str, output_file: str):
        self.project_path = Path(project_path).resolve()
        self.output_file = Path(output_file)
        self.gitignore_matcher = self._setup_gitignore()
        self.debug = False

    def _setup_gitignore(self) -> Optional[callable]:
        """Setup gitignore matcher if .gitignore exists"""
        gitignore_path = self.project_path / '.gitignore'
        if gitignore_path.exists():
            try:
                return gitignore_parser.parse_gitignore(gitignore_path)
            except Exception as e:
                print(f"Warning: Failed to parse .gitignore: {e}")
        return None

    def _should_include_file(self, file_path: Path) -> bool:
        """Check if file should be included based on extension and ignore rules"""
        # Skip common virtual environment and system directories
        excluded_dirs = {
            '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
            '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
            'dist', 'build', 'target'
        }

        try:
            # Convert to relative path for checking
            try:
                rel_path = file_path.relative_to(self.project_path)
            except ValueError:
                if self.debug:
                    print(f"Debug: Skipping file outside project path: {file_path}")
                return False

            # Check for excluded directories in the path
            if any(part in excluded_dirs for part in file_path.parts):
                if self.debug:
                    print(f"Debug: Skipping excluded directory: {file_path}")
                return False

            # Check if file extension is in whitelist
            if file_path.suffix.lower() not in SOURCE_EXTENSIONS:
                if self.debug:
                    print(f"Debug: Skipping non-source file: {file_path}")
                return False

            # Check custom ignore patterns
            for pattern in IGNORE_PATTERNS:
                if fnmatch.fnmatch(str(rel_path), pattern):
                    if self.debug:
                        print(f"Debug: Skipping ignored pattern {pattern}: {file_path}")
                    return False

            # Check .gitignore if available
            if self.gitignore_matcher:
                try:
                    should_include = not self.gitignore_matcher(str(file_path))
                    if self.debug and not should_include:
                        print(f"Debug: Skipping gitignored file: {file_path}")
                    return should_include
                except Exception as e:
                    print(f"Warning: gitignore matching failed for {file_path}: {e}")
                    return True

            if self.debug:
                print(f"Debug: Including file: {file_path}")
            return True

        except Exception as e:
            print(f"Warning: Error checking file {file_path}: {e}")
            return False

    def _get_file_content(self, file_path: Path) -> str:
        """Read file content with proper encoding handling"""
        try:
            # Try UTF-8 first
            with open(file_path, 'r', encoding='utf-8') as f:
                return f.read()
        except UnicodeDecodeError:
            try:
                # Fallback to latin-1
                with open(file_path, 'r', encoding='latin-1') as f:
                    return f.read()
            except Exception as e:
                print(f"Warning: Failed to read {file_path}: {e}")
                return f"ERROR: Could not read file {file_path}\n"

    def _generate_directory_structure(self) -> str:
        """Generate a tree-like directory structure"""
        structure = ["Directory Structure:", ""]

        def add_to_tree(path: Path, prefix: str = ""):
            # Skip excluded directories
            excluded_dirs = {
                '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
                '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
                'dist', 'build', 'target'
            }
            if path.name in excluded_dirs:
                return

            # Add files first
            files = sorted([p for p in path.iterdir() if p.is_file()])
            included_files = [f for f in files if self._should_include_file(f)]

            for idx, file in enumerate(included_files):
                is_last = idx == len(included_files) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {file.name}")

            # Then add directories
            dirs = sorted([p for p in path.iterdir() if p.is_dir()])
            included_dirs = [d for d in dirs if d.name not in excluded_dirs]

            for idx, dir in enumerate(included_dirs):
                is_last = idx == len(included_dirs) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {dir.name}/")
                add_to_tree(dir, prefix + ("    " if is_last else "│   "))

        add_to_tree(self.project_path)
        return "\n".join(structure)

    def concatenate(self, debug: bool = False):
        """Main method to concatenate all source files"""
        self.debug = debug
        if not self.project_path.exists():
            print(f"Error: Project path {self.project_path} does not exist")
            return False

        try:
            with open(self.output_file, 'w', encoding='utf-8') as out:
                # Write header
                header = f"""
# Project Source Code Concatenation
# Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
# Project path: {self.project_path}

"""
                out.write(header)

                # Write directory structure
                out.write(self._generate_directory_structure())
                out.write("\n\n" + "="*80 + "\n\n")

                # Process all files
                file_count = 0
                for file_path in self.project_path.rglob('*'):
                    if file_path.is_file() and self._should_include_file(file_path):
                        rel_path = file_path.relative_to(self.project_path)

                        # Write file header
                        out.write(f"\n\n# File: {rel_path}\n")
                        out.write("="*80 + "\n\n")

                        # Write file content
                        content = self._get_file_content(file_path)
                        out.write(content)
                        file_count += 1

                print(f"Successfully melted {file_count} files to {self.output_file}")
                return True

        except Exception as e:
            print(f"Error during melting: {e}")
            return False

def main():
    parser = argparse.ArgumentParser(
        description="CodeSmelt: Melt down your git project's source code into a single file",
        usage="%(prog)s [-o OUTPUT] [-d] project_path"
    )
    parser.add_argument(
        "-o", "--output",
        default="concatenated_source.txt",
        help="Output file path (default: concatenated_source.txt)"
    )
    parser.add_argument(
        "-d", "--debug",
        action="store_true",
        help="Enable debug logging"
    )
    parser.add_argument(
        "project_path",
        help="Path to the git project directory",
        nargs="?"  # Make it optional in the parser (though we'll check it's provided)
    )

    args = parser.parse_args()

    if not args.project_path:
        parser.error("project_path is required")

    concatenator = CodeSmelt(args.project_path, args.output)
    success = concatenator.concatenate(debug=args.debug)
    sys.exit(0 if success else 1)

if __name__ == "__main__":
    main()

# File: README.md
================================================================================

python codesmelt.py /path/to/project
```

Specify custom output file:
```bash
python codesmelt.py -o output.txt /path/to/project
```

With debug logging:
```bash
python codesmelt.py -d -o output.txt /path/to/project
```

### Command-line Arguments
- `project_path`: Path to the Git project directory (required)
- `-o, --output`: Output file path (default: concatenated_source.txt)
- `-d, --debug`: Enable debug logging

## Configuration

### Source File Extensions
The tool includes common source code file extensions by default (defined in `extensions.py`):
- Web: `.js`, `.ts`, `.jsx`, `.tsx`, `.vue`, `.svelte`, `.html`, `.css`, etc.
- Python: `.py`, `.pyi`, `.pyx`
- Java/Kotlin: `.java`, `.kt`, `.groovy`
- C-family: `.c`, `.cpp`, `.h`, `.hpp`
- And many more...

#### Customizing File Extensions
You can modify which file extensions are included by editing the `SOURCE_EXTENSIONS` set in `extensions.py`. For example, to include Unity3D script files while excluding other Unity files:

```python
SOURCE_EXTENSIONS = {
    # ... existing extensions ...

    # Unity3D specific
    '.cs',  # C# scripts
    '.shader', # Custom shaders
    '.asmdef', # Assembly definitions

    # ... other extensions ...
}
```

### Ignore Patterns
The tool automatically ignores files based on three levels:

1. Built-in patterns (`IGNORE_PATTERNS` in `extensions.py`):
   - Build outputs (`build/*`, `dist/*`, `*.pyc`, etc.)
   - Dependencies (`node_modules/*`, `vendor/*`, `venv/*`)
   - IDE files (`.idea/*`, `.vscode/*`)
   - Package lock files (`package-lock.json`, `poetry.lock`, etc.)
   - Binary and media files (`*.pdf`, `*.jpg`, `*.exe`, etc.)

2. Project's `.gitignore` rules (if present)
3. Directory-specific `.gitignore` rules

#### Customizing Ignore Patterns
To modify which files are ignored, you can:

1. Edit `IGNORE_PATTERNS` in `extensions.py`:
```python
IGNORE_PATTERNS = {
    # ... existing patterns ...

    # Unity3D specific ignores
    'Assets/AssetStoreTools/*',
    'Library/*',
    'Temp/*',
    'Logs/*',
    '*.unity',  # Unity scene files
    '*.meta',   # Unity meta files
    '*.prefab', # Unity prefab files

    # ... other patterns ...
}
```

2. Use your project's `.gitignore` file for project-specific exclusions

**Note**: Ignore patterns follow the same syntax as `.gitignore` files. The tool processes these rules in order:
1. Built-in `IGNORE_PATTERNS`
2. Project's root `.gitignore`
3. Directory-specific `.gitignore` files


## Tips for Using with LLMs

1. **Token Management**:
   - For large projects, consider concatenating only specific directories
   - Use the debug mode to see which files are included/excluded
   - Remove unnecessary documentation files if you're close to token limits

2. **Effective Prompting**:
   - Reference files using their relative paths as shown in the directory structure
   - Use the directory structure to ask about specific components
   - Refer to file relationships based on the visual structure

3. **Best Practices**:
   - Review the concatenated output before sending to ensure relevance
   - For large projects, break down analysis into smaller, focused components
   - Use the debug mode to verify file selection when customizing

## Output Format

The generated file includes:
1. A timestamp and project path header
2. A visual directory structure of the project
3. The contents of each source file, clearly separated with headers

Example output:
```
# Project Source Code Concatenation
# Generated on: 2025-02-15 20:53:29
# Project path: /path/to/project

Directory Structure:
├── src/
│   ├── main.py
│   └── utils.py
└── README.md

================================================================================

# File: src/main.py
================================================================================
[File contents here]

# File: src/utils.py
================================================================================
[File contents here]
```

## Troubleshooting

### Common Issues

1. **No Files Found**:
   - Verify the project path is correct
   - Check if files have supported extensions
   - Run with --debug to see which files are being filtered

2. **Missing Dependencies**:
   ```bash
   pip install --upgrade gitignore-parser

# File: output.txt
================================================================================


# Project Source Code Concatenation
# Generated on: 2025-02-15 22:55:16
# Project path: /home/runner/workspace

Directory Structure:

├── README.md
├── codesmelt.py
├── concatenated_source.txt
├── extensions.py
├── output.txt
├── pyproject.toml
└── test_output.txt

================================================================================



# File: extensions.py
================================================================================

"""
Source code file extension configurations
"""

# Common source code file extensions
SOURCE_EXTENSIONS = {
    # Web
    '.js', '.ts', '.jsx', '.tsx', '.vue', '.svelte',
    '.html', '.htm', '.css', '.scss', '.sass', '.less',
    
    # Python
    '.py', '.pyi', '.pyx',
    
    # Java/Kotlin
    '.java', '.kt', '.groovy',
    
    # C-family
    '.c', '.cpp', '.h', '.hpp', '.cc',
    
    # C#
    '.cs', '.cshtml', '.csx',
    
    # Ruby
    '.rb', '.erb',
    
    # PHP
    '.php', '.php5', '.phtml',
    
    # Go
    '.go',
    
    # Rust
    '.rs',
    
    # Swift
    '.swift',
    
    # Shell
    '.sh', '.bash', '.zsh',
    
    # Config/Data
    '.json', '.yaml', '.yml', '.toml', '.xml',
    '.conf', '.ini', '.env',
    
    # Documentation
    '.md', '.rst', '.txt'
}

# Files to always ignore
IGNORE_PATTERNS = {
    # Build outputs
    'build/*', 'dist/*', 'target/*', 'bin/*',
    '*.pyc', '__pycache__/*', '*.class',
    
    # Dependencies
    'node_modules/*', 'vendor/*', 'venv/*',
    
    # IDE files
    '.idea/*', '.vscode/*', '*.swp',
    
    # Package files
    'package-lock.json', 'yarn.lock',
    'Pipfile.lock', 'poetry.lock',
    
    # Large data files
    '*.csv', '*.json.gz', '*.sql',
    
    # Binary/Media files
    '*.pdf', '*.jpg', '*.png', '*.gif',
    '*.mp3', '*.mp4', '*.mov', '*.bin',
    '*.exe', '*.dll', '*.so', '*.dylib'
}


# File: pyproject.toml
================================================================================

[project]
name = "repl-nix-workspace"
version = "0.1.0"
description = "Add your description here"
requires-python = ">=3.11"
dependencies = [
    "gitignore-parser>=0.1.11",
]


# File: concatenated_source.txt
================================================================================


# Project Source Code Concatenation
# Generated on: 2025-02-15 22:55:02
# Project path: /home/runner/workspace

Directory Structure:

├── README.md
├── codesmelt.py
├── concatenated_source.txt
├── extensions.py
├── output.txt
└── pyproject.toml

================================================================================



# File: extensions.py
================================================================================

"""
Source code file extension configurations
"""

# Common source code file extensions
SOURCE_EXTENSIONS = {
    # Web
    '.js', '.ts', '.jsx', '.tsx', '.vue', '.svelte',
    '.html', '.htm', '.css', '.scss', '.sass', '.less',
    
    # Python
    '.py', '.pyi', '.pyx',
    
    # Java/Kotlin
    '.java', '.kt', '.groovy',
    
    # C-family
    '.c', '.cpp', '.h', '.hpp', '.cc',
    
    # C#
    '.cs', '.cshtml', '.csx',
    
    # Ruby
    '.rb', '.erb',
    
    # PHP
    '.php', '.php5', '.phtml',
    
    # Go
    '.go',
    
    # Rust
    '.rs',
    
    # Swift
    '.swift',
    
    # Shell
    '.sh', '.bash', '.zsh',
    
    # Config/Data
    '.json', '.yaml', '.yml', '.toml', '.xml',
    '.conf', '.ini', '.env',
    
    # Documentation
    '.md', '.rst', '.txt'
}

# Files to always ignore
IGNORE_PATTERNS = {
    # Build outputs
    'build/*', 'dist/*', 'target/*', 'bin/*',
    '*.pyc', '__pycache__/*', '*.class',
    
    # Dependencies
    'node_modules/*', 'vendor/*', 'venv/*',
    
    # IDE files
    '.idea/*', '.vscode/*', '*.swp',
    
    # Package files
    'package-lock.json', 'yarn.lock',
    'Pipfile.lock', 'poetry.lock',
    
    # Large data files
    '*.csv', '*.json.gz', '*.sql',
    
    # Binary/Media files
    '*.pdf', '*.jpg', '*.png', '*.gif',
    '*.mp3', '*.mp4', '*.mov', '*.bin',
    '*.exe', '*.dll', '*.so', '*.dylib'
}


# File: pyproject.toml
================================================================================

[project]
name = "repl-nix-workspace"
version = "0.1.0"
description = "Add your description here"
requires-python = ">=3.11"
dependencies = [
    "gitignore-parser>=0.1.11",
]


# File: concatenated_source.txt
================================================================================



# File: output.txt
================================================================================


# Project Source Code Concatenation
# Generated on: 2025-02-15 22:44:33
# Project path: /home/runner/workspace

Directory Structure:

├── README.md
├── codesmelt.py
├── concatenated_source.txt
├── extensions.py
├── output.txt
└── pyproject.toml

================================================================================



# File: extensions.py
================================================================================

"""
Source code file extension configurations
"""

# Common source code file extensions
SOURCE_EXTENSIONS = {
    # Web
    '.js', '.ts', '.jsx', '.tsx', '.vue', '.svelte',
    '.html', '.htm', '.css', '.scss', '.sass', '.less',
    
    # Python
    '.py', '.pyi', '.pyx',
    
    # Java/Kotlin
    '.java', '.kt', '.groovy',
    
    # C-family
    '.c', '.cpp', '.h', '.hpp', '.cc',
    
    # C#
    '.cs', '.cshtml', '.csx',
    
    # Ruby
    '.rb', '.erb',
    
    # PHP
    '.php', '.php5', '.phtml',
    
    # Go
    '.go',
    
    # Rust
    '.rs',
    
    # Swift
    '.swift',
    
    # Shell
    '.sh', '.bash', '.zsh',
    
    # Config/Data
    '.json', '.yaml', '.yml', '.toml', '.xml',
    '.conf', '.ini', '.env',
    
    # Documentation
    '.md', '.rst', '.txt'
}

# Files to always ignore
IGNORE_PATTERNS = {
    # Build outputs
    'build/*', 'dist/*', 'target/*', 'bin/*',
    '*.pyc', '__pycache__/*', '*.class',
    
    # Dependencies
    'node_modules/*', 'vendor/*', 'venv/*',
    
    # IDE files
    '.idea/*', '.vscode/*', '*.swp',
    
    # Package files
    'package-lock.json', 'yarn.lock',
    'Pipfile.lock', 'poetry.lock',
    
    # Large data files
    '*.csv', '*.json.gz', '*.sql',
    
    # Binary/Media files
    '*.pdf', '*.jpg', '*.png', '*.gif',
    '*.mp3', '*.mp4', '*.mov', '*.bin',
    '*.exe', '*.dll', '*.so', '*.dylib'
}


# File: pyproject.toml
================================================================================

[project]
name = "repl-nix-workspace"
version = "0.1.0"
description = "Add your description here"
requires-python = ">=3.11"
dependencies = [
    "gitignore-parser>=0.1.11",
]


# File: concatenated_source.txt
================================================================================


# Project Source Code Concatenation
# Generated on: 2025-02-15 21:22:24
# Project path: /home/runner/workspace

Directory Structure:

├── README.md
├── concatenated_source.txt
├── extensions.py
├── git_concatenator.py
└── pyproject.toml

================================================================================



# File: extensions.py
================================================================================

"""
Source code file extension configurations
"""

# Common source code file extensions
SOURCE_EXTENSIONS = {
    # Web
    '.js', '.ts', '.jsx', '.tsx', '.vue', '.svelte',
    '.html', '.htm', '.css', '.scss', '.sass', '.less',
    
    # Python
    '.py', '.pyi', '.pyx',
    
    # Java/Kotlin
    '.java', '.kt', '.groovy',
    
    # C-family
    '.c', '.cpp', '.h', '.hpp', '.cc',
    
    # C#
    '.cs', '.cshtml', '.csx',
    
    # Ruby
    '.rb', '.erb',
    
    # PHP
    '.php', '.php5', '.phtml',
    
    # Go
    '.go',
    
    # Rust
    '.rs',
    
    # Swift
    '.swift',
    
    # Shell
    '.sh', '.bash', '.zsh',
    
    # Config/Data
    '.json', '.yaml', '.yml', '.toml', '.xml',
    '.conf', '.ini', '.env',
    
    # Documentation
    '.md', '.rst', '.txt'
}

# Files to always ignore
IGNORE_PATTERNS = {
    # Build outputs
    'build/*', 'dist/*', 'target/*', 'bin/*',
    '*.pyc', '__pycache__/*', '*.class',
    
    # Dependencies
    'node_modules/*', 'vendor/*', 'venv/*',
    
    # IDE files
    '.idea/*', '.vscode/*', '*.swp',
    
    # Package files
    'package-lock.json', 'yarn.lock',
    'Pipfile.lock', 'poetry.lock',
    
    # Large data files
    '*.csv', '*.json.gz', '*.sql',
    
    # Binary/Media files
    '*.pdf', '*.jpg', '*.png', '*.gif',
    '*.mp3', '*.mp4', '*.mov', '*.bin',
    '*.exe', '*.dll', '*.so', '*.dylib'
}


# File: pyproject.toml
================================================================================

[project]
name = "repl-nix-workspace"
version = "0.1.0"
description = "Add your description here"
requires-python = ">=3.11"
dependencies = [
    "gitignore-parser>=0.1.11",
]


# File: concatenated_source.txt
================================================================================



# File: git_concatenator.py
================================================================================

#!/usr/bin/env python3
"""
Git Project Source Code Concatenator

This tool concatenates source code files from a git project into a single file,
including directory structure information.
"""

import argparse
import sys
from pathlib import Path
import os
from typing import Set, List, Optional
import fnmatch
from datetime import datetime
import gitignore_parser
from extensions import SOURCE_EXTENSIONS, IGNORE_PATTERNS

class GitConcatenator:
    def __init__(self, project_path: str, output_file: str):
        self.project_path = Path(project_path).resolve()
        self.output_file = Path(output_file)
        self.gitignore_matcher = self._setup_gitignore()
        self.debug = False

    def _setup_gitignore(self) -> Optional[callable]:
        """Setup gitignore matcher if .gitignore exists"""
        gitignore_path = self.project_path / '.gitignore'
        if gitignore_path.exists():
            try:
                return gitignore_parser.parse_gitignore(gitignore_path)
            except Exception as e:
                print(f"Warning: Failed to parse .gitignore: {e}")
        return None

    def _should_include_file(self, file_path: Path) -> bool:
        """Check if file should be included based on extension and ignore rules"""
        # Skip common virtual environment and system directories
        excluded_dirs = {
            '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
            '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
            'dist', 'build', 'target'
        }

        try:
            # Convert to relative path for checking
            try:
                rel_path = file_path.relative_to(self.project_path)
            except ValueError:
                if self.debug:
                    print(f"Debug: Skipping file outside project path: {file_path}")
                return False

            # Check for excluded directories in the path
            if any(part in excluded_dirs for part in file_path.parts):
                if self.debug:
                    print(f"Debug: Skipping excluded directory: {file_path}")
                return False

            # Check if file extension is in whitelist
            if file_path.suffix.lower() not in SOURCE_EXTENSIONS:
                if self.debug:
                    print(f"Debug: Skipping non-source file: {file_path}")
                return False

            # Check custom ignore patterns
            for pattern in IGNORE_PATTERNS:
                if fnmatch.fnmatch(str(rel_path), pattern):
                    if self.debug:
                        print(f"Debug: Skipping ignored pattern {pattern}: {file_path}")
                    return False

            # Check .gitignore if available
            if self.gitignore_matcher:
                try:
                    should_include = not self.gitignore_matcher(str(file_path))
                    if self.debug and not should_include:
                        print(f"Debug: Skipping gitignored file: {file_path}")
                    return should_include
                except Exception as e:
                    print(f"Warning: gitignore matching failed for {file_path}: {e}")
                    return True

            if self.debug:
                print(f"Debug: Including file: {file_path}")
            return True

        except Exception as e:
            print(f"Warning: Error checking file {file_path}: {e}")
            return False

    def _get_file_content(self, file_path: Path) -> str:
        """Read file content with proper encoding handling"""
        try:
            # Try UTF-8 first
            with open(file_path, 'r', encoding='utf-8') as f:
                return f.read()
        except UnicodeDecodeError:
            try:
                # Fallback to latin-1
                with open(file_path, 'r', encoding='latin-1') as f:
                    return f.read()
            except Exception as e:
                print(f"Warning: Failed to read {file_path}: {e}")
                return f"ERROR: Could not read file {file_path}\n"

    def _generate_directory_structure(self) -> str:
        """Generate a tree-like directory structure"""
        structure = ["Directory Structure:", ""]

        def add_to_tree(path: Path, prefix: str = ""):
            # Skip excluded directories
            excluded_dirs = {
                '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
                '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
                'dist', 'build', 'target'
            }
            if path.name in excluded_dirs:
                return

            # Add files first
            files = sorted([p for p in path.iterdir() if p.is_file()])
            included_files = [f for f in files if self._should_include_file(f)]

            for idx, file in enumerate(included_files):
                is_last = idx == len(included_files) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {file.name}")

            # Then add directories
            dirs = sorted([p for p in path.iterdir() if p.is_dir()])
            included_dirs = [d for d in dirs if d.name not in excluded_dirs]

            for idx, dir in enumerate(included_dirs):
                is_last = idx == len(included_dirs) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {dir.name}/")
                add_to_tree(dir, prefix + ("    " if is_last else "│   "))

        add_to_tree(self.project_path)
        return "\n".join(structure)

    def concatenate(self, debug: bool = False):
        """Main method to concatenate all source files"""
        self.debug = debug
        if not self.project_path.exists():
            print(f"Error: Project path {self.project_path} does not exist")
            return False

        try:
            with open(self.output_file, 'w', encoding='utf-8') as out:
                # Write header
                header = f"""
# Project Source Code Concatenation
# Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
# Project path: {self.project_path}

"""
                out.write(header)

                # Write directory structure
                out.write(self._generate_directory_structure())
                out.write("\n\n" + "="*80 + "\n\n")

                # Process all files
                file_count = 0
                for file_path in self.project_path.rglob('*'):
                    if file_path.is_file() and self._should_include_file(file_path):
                        rel_path = file_path.relative_to(self.project_path)

                        # Write file header
                        out.write(f"\n\n# File: {rel_path}\n")
                        out.write("="*80 + "\n\n")

                        # Write file content
                        content = self._get_file_content(file_path)
                        out.write(content)
                        file_count += 1

                print(f"Successfully concatenated {file_count} files to {self.output_file}")
                return True

        except Exception as e:
            print(f"Error during concatenation: {e}")
            return False

def main():
    parser = argparse.ArgumentParser(
        description="Concatenate git project source code into a single file"
    )
    parser.add_argument(
        "project_path",
        help="Path to the git project directory"
    )
    parser.add_argument(
        "-o", "--output",
        default="concatenated_source.txt",
        help="Output file path (default: concatenated_source.txt)"
    )
    parser.add_argument(
        "-d", "--debug",
        action="store_true",
        help="Enable debug logging"
    )

    args = parser.parse_args()

    concatenator = GitConcatenator(args.project_path, args.output)
    success = concatenator.concatenate(debug=args.debug)
    sys.exit(0 if success else 1)

if __name__ == "__main__":
    main()

# File: README.md
================================================================================

git clone https://github.com/yourusername/git-concatenator.git
   cd git-concatenator
   ```

2. Ensure you have Python 3.11 or later installed:
   ```bash
   python --version
   ```

3. Install the required dependency:
   ```bash
   pip install gitignore-parser
   ```

## Usage

Basic usage:
```bash
python git_concatenator.py /path/to/project -o output.txt
```

With debug logging:
```bash
python git_concatenator.py /path/to/project -o output.txt --debug
```

### Command-line Arguments

- `project_path`: Path to the Git project directory (required)
- `-o, --output`: Output file path (default: concatenated_source.txt)
- `-d, --debug`: Enable debug logging

## Output Format

The generated file includes:
1. A timestamp and project path header
2. A visual directory structure of the project
3. The contents of each source file, clearly separated with headers

Example output:
```
# Project Source Code Concatenation
# Generated on: 2025-02-15 20:53:29
# Project path: /path/to/project

Directory Structure:
├── src/
│   ├── main.py
│   └── utils.py
└── README.md

================================================================================

# File: src/main.py
================================================================================
[File contents here]

# File: src/utils.py
================================================================================
[File contents here]

# File: output.txt
================================================================================


# Project Source Code Concatenation
# Generated on: 2025-02-15 22:44:33
# Project path: /home/runner/workspace

Directory Structure:

├── README.md
├── codesmelt.py
├── concatenated_source.txt
├── extensions.py
├── output.txt
└── pyproject.toml

================================================================================



# File: extensions.py
================================================================================

"""
Source code file extension configurations
"""

# Common source code file extensions
SOURCE_EXTENSIONS = {
    # Web
    '.js', '.ts', '.jsx', '.tsx', '.vue', '.svelte',
    '.html', '.htm', '.css', '.scss', '.sass', '.less',
    
    # Python
    '.py', '.pyi', '.pyx',
    
    # Java/Kotlin
    '.java', '.kt', '.groovy',
    
    # C-family
    '.c', '.cpp', '.h', '.hpp', '.cc',
    
    # C#
    '.cs', '.cshtml', '.csx',
    
    # Ruby
    '.rb', '.erb',
    
    # PHP
    '.php', '.php5', '.phtml',
    
    # Go
    '.go',
    
    # Rust
    '.rs',
    
    # Swift
    '.swift',
    
    # Shell
    '.sh', '.bash', '.zsh',
    
    # Config/Data
    '.json', '.yaml', '.yml', '.toml', '.xml',
    '.conf', '.ini', '.env',
    
    # Documentation
    '.md', '.rst', '.txt'
}

# Files to always ignore
IGNORE_PATTERNS = {
    # Build outputs
    'build/*', 'dist/*', 'target/*', 'bin/*',
    '*.pyc', '__pycache__/*', '*.class',
    
    # Dependencies
    'node_modules/*', 'vendor/*', 'venv/*',
    
    # IDE files
    '.idea/*', '.vscode/*', '*.swp',
    
    # Package files
    'package-lock.json', 'yarn.lock',
    'Pipfile.lock', 'poetry.lock',
    
    # Large data files
    '*.csv', '*.json.gz', '*.sql',
    
    # Binary/Media files
    '*.pdf', '*.jpg', '*.png', '*.gif',
    '*.mp3', '*.mp4', '*.mov', '*.bin',
    '*.exe', '*.dll', '*.so', '*.dylib'
}


# File: pyproject.toml
================================================================================

[project]
name = "repl-nix-workspace"
version = "0.1.0"
description = "Add your description here"
requires-python = ">=3.11"
dependencies = [
    "gitignore-parser>=0.1.11",
]


# File: concatenated_source.txt
================================================================================


# Project Source Code Concatenation
# Generated on: 2025-02-15 21:22:24
# Project path: /home/runner/workspace

Directory Structure:

├── README.md
├── concatenated_source.txt
├── extensions.py
├── git_concatenator.py
└── pyproject.toml

================================================================================



# File: extensions.py
================================================================================

"""
Source code file extension configurations
"""

# Common source code file extensions
SOURCE_EXTENSIONS = {
    # Web
    '.js', '.ts', '.jsx', '.tsx', '.vue', '.svelte',
    '.html', '.htm', '.css', '.scss', '.sass', '.less',
    
    # Python
    '.py', '.pyi', '.pyx',
    
    # Java/Kotlin
    '.java', '.kt', '.groovy',
    
    # C-family
    '.c', '.cpp', '.h', '.hpp', '.cc',
    
    # C#
    '.cs', '.cshtml', '.csx',
    
    # Ruby
    '.rb', '.erb',
    
    # PHP
    '.php', '.php5', '.phtml',
    
    # Go
    '.go',
    
    # Rust
    '.rs',
    
    # Swift
    '.swift',
    
    # Shell
    '.sh', '.bash', '.zsh',
    
    # Config/Data
    '.json', '.yaml', '.yml', '.toml', '.xml',
    '.conf', '.ini', '.env',
    
    # Documentation
    '.md', '.rst', '.txt'
}

# Files to always ignore
IGNORE_PATTERNS = {
    # Build outputs
    'build/*', 'dist/*', 'target/*', 'bin/*',
    '*.pyc', '__pycache__/*', '*.class',
    
    # Dependencies
    'node_modules/*', 'vendor/*', 'venv/*',
    
    # IDE files
    '.idea/*', '.vscode/*', '*.swp',
    
    # Package files
    'package-lock.json', 'yarn.lock',
    'Pipfile.lock', 'poetry.lock',
    
    # Large data files
    '*.csv', '*.json.gz', '*.sql',
    
    # Binary/Media files
    '*.pdf', '*.jpg', '*.png', '*.gif',
    '*.mp3', '*.mp4', '*.mov', '*.bin',
    '*.exe', '*.dll', '*.so', '*.dylib'
}


# File: pyproject.toml
================================================================================

[project]
name = "repl-nix-workspace"
version = "0.1.0"
description = "Add your description here"
requires-python = ">=3.11"
dependencies = [
    "gitignore-parser>=0.1.11",
]


# File: concatenated_source.txt
================================================================================



# File: git_concatenator.py
================================================================================

#!/usr/bin/env python3
"""
Git Project Source Code Concatenator

This tool concatenates source code files from a git project into a single file,
including directory structure information.
"""

import argparse
import sys
from pathlib import Path
import os
from typing import Set, List, Optional
import fnmatch
from datetime import datetime
import gitignore_parser
from extensions import SOURCE_EXTENSIONS, IGNORE_PATTERNS

class GitConcatenator:
    def __init__(self, project_path: str, output_file: str):
        self.project_path = Path(project_path).resolve()
        self.output_file = Path(output_file)
        self.gitignore_matcher = self._setup_gitignore()
        self.debug = False

    def _setup_gitignore(self) -> Optional[callable]:
        """Setup gitignore matcher if .gitignore exists"""
        gitignore_path = self.project_path / '.gitignore'
        if gitignore_path.exists():
            try:
                return gitignore_parser.parse_gitignore(gitignore_path)
            except Exception as e:
                print(f"Warning: Failed to parse .gitignore: {e}")
        return None

    def _should_include_file(self, file_path: Path) -> bool:
        """Check if file should be included based on extension and ignore rules"""
        # Skip common virtual environment and system directories
        excluded_dirs = {
            '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
            '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
            'dist', 'build', 'target'
        }

        try:
            # Convert to relative path for checking
            try:
                rel_path = file_path.relative_to(self.project_path)
            except ValueError:
                if self.debug:
                    print(f"Debug: Skipping file outside project path: {file_path}")
                return False

            # Check for excluded directories in the path
            if any(part in excluded_dirs for part in file_path.parts):
                if self.debug:
                    print(f"Debug: Skipping excluded directory: {file_path}")
                return False

            # Check if file extension is in whitelist
            if file_path.suffix.lower() not in SOURCE_EXTENSIONS:
                if self.debug:
                    print(f"Debug: Skipping non-source file: {file_path}")
                return False

            # Check custom ignore patterns
            for pattern in IGNORE_PATTERNS:
                if fnmatch.fnmatch(str(rel_path), pattern):
                    if self.debug:
                        print(f"Debug: Skipping ignored pattern {pattern}: {file_path}")
                    return False

            # Check .gitignore if available
            if self.gitignore_matcher:
                try:
                    should_include = not self.gitignore_matcher(str(file_path))
                    if self.debug and not should_include:
                        print(f"Debug: Skipping gitignored file: {file_path}")
                    return should_include
                except Exception as e:
                    print(f"Warning: gitignore matching failed for {file_path}: {e}")
                    return True

            if self.debug:
                print(f"Debug: Including file: {file_path}")
            return True

        except Exception as e:
            print(f"Warning: Error checking file {file_path}: {e}")
            return False

    def _get_file_content(self, file_path: Path) -> str:
        """Read file content with proper encoding handling"""
        try:
            # Try UTF-8 first
            with open(file_path, 'r', encoding='utf-8') as f:
                return f.read()
        except UnicodeDecodeError:
            try:
                # Fallback to latin-1
                with open(file_path, 'r', encoding='latin-1') as f:
                    return f.read()
            except Exception as e:
                print(f"Warning: Failed to read {file_path}: {e}")
                return f"ERROR: Could not read file {file_path}\n"

    def _generate_directory_structure(self) -> str:
        """Generate a tree-like directory structure"""
        structure = ["Directory Structure:", ""]

        def add_to_tree(path: Path, prefix: str = ""):
            # Skip excluded directories
            excluded_dirs = {
                '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
                '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
                'dist', 'build', 'target'
            }
            if path.name in excluded_dirs:
                return

            # Add files first
            files = sorted([p for p in path.iterdir() if p.is_file()])
            included_files = [f for f in files if self._should_include_file(f)]

            for idx, file in enumerate(included_files):
                is_last = idx == len(included_files) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {file.name}")

            # Then add directories
            dirs = sorted([p for p in path.iterdir() if p.is_dir()])
            included_dirs = [d for d in dirs if d.name not in excluded_dirs]

            for idx, dir in enumerate(included_dirs):
                is_last = idx == len(included_dirs) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {dir.name}/")
                add_to_tree(dir, prefix + ("    " if is_last else "│   "))

        add_to_tree(self.project_path)
        return "\n".join(structure)

    def concatenate(self, debug: bool = False):
        """Main method to concatenate all source files"""
        self.debug = debug
        if not self.project_path.exists():
            print(f"Error: Project path {self.project_path} does not exist")
            return False

        try:
            with open(self.output_file, 'w', encoding='utf-8') as out:
                # Write header
                header = f"""
# Project Source Code Concatenation
# Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
# Project path: {self.project_path}

"""
                out.write(header)

                # Write directory structure
                out.write(self._generate_directory_structure())
                out.write("\n\n" + "="*80 + "\n\n")

                # Process all files
                file_count = 0
                for file_path in self.project_path.rglob('*'):
                    if file_path.is_file() and self._should_include_file(file_path):
                        rel_path = file_path.relative_to(self.project_path)

                        # Write file header
                        out.write(f"\n\n# File: {rel_path}\n")
                        out.write("="*80 + "\n\n")

                        # Write file content
                        content = self._get_file_content(file_path)
                        out.write(content)
                        file_count += 1

                print(f"Successfully concatenated {file_count} files to {self.output_file}")
                return True

        except Exception as e:
            print(f"Error during concatenation: {e}")
            return False

def main():
    parser = argparse.ArgumentParser(
        description="Concatenate git project source code into a single file"
    )
    parser.add_argument(
        "project_path",
        help="Path to the git project directory"
    )
    parser.add_argument(
        "-o", "--output",
        default="concatenated_source.txt",
        help="Output file path (default: concatenated_source.txt)"
    )
    parser.add_argument(
        "-d", "--debug",
        action="store_true",
        help="Enable debug logging"
    )

    args = parser.parse_args()

    concatenator = GitConcatenator(args.project_path, args.output)
    success = concatenator.concatenate(debug=args.debug)
    sys.exit(0 if success else 1)

if __name__ == "__main__":
    main()

# File: README.md
================================================================================

git clone https://github.com/yourusername/git-concatenator.git
   cd git-concatenator
   ```

2. Ensure you have Python 3.11 or later installed:
   ```bash
   python --version
   ```

3. Install the required dependency:
   ```bash
   pip install gitignore-parser
   ```

## Usage

Basic usage:
```bash
python git_concatenator.py /path/to/project -o output.txt
```

With debug logging:
```bash
python git_concatenator.py /path/to/project -o output.txt --debug
```

### Command-line Arguments

- `project_path`: Path to the Git project directory (required)
- `-o, --output`: Output file path (default: concatenated_source.txt)
- `-d, --debug`: Enable debug logging

## Output Format

The generated file includes:
1. A timestamp and project path header
2. A visual directory structure of the project
3. The contents of each source file, clearly separated with headers

Example output:
```
# Project Source Code Concatenation
# Generated on: 2025-02-15 20:53:29
# Project path: /path/to/project

Directory Structure:
├── src/
│   ├── main.py
│   └── utils.py
└── README.md

================================================================================

# File: src/main.py
================================================================================
[File contents here]

# File: src/utils.py
================================================================================
[File contents here]

# File: codesmelt.py
================================================================================

#!/usr/bin/env python3
"""
CodeSmelt: Source Code Concatenator

This tool melts down source code files from a git project into a single file,
including directory structure information.
"""

import argparse
import sys
from pathlib import Path
import os
from typing import Set, List, Optional
import fnmatch
from datetime import datetime
import gitignore_parser
from extensions import SOURCE_EXTENSIONS, IGNORE_PATTERNS

class CodeSmelt:
    def __init__(self, project_path: str, output_file: str):
        self.project_path = Path(project_path).resolve()
        self.output_file = Path(output_file)
        self.gitignore_matcher = self._setup_gitignore()
        self.debug = False

    def _setup_gitignore(self) -> Optional[callable]:
        """Setup gitignore matcher if .gitignore exists"""
        gitignore_path = self.project_path / '.gitignore'
        if gitignore_path.exists():
            try:
                return gitignore_parser.parse_gitignore(gitignore_path)
            except Exception as e:
                print(f"Warning: Failed to parse .gitignore: {e}")
        return None

    def _should_include_file(self, file_path: Path) -> bool:
        """Check if file should be included based on extension and ignore rules"""
        # Skip common virtual environment and system directories
        excluded_dirs = {
            '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
            '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
            'dist', 'build', 'target'
        }

        try:
            # Convert to relative path for checking
            try:
                rel_path = file_path.relative_to(self.project_path)
            except ValueError:
                if self.debug:
                    print(f"Debug: Skipping file outside project path: {file_path}")
                return False

            # Check for excluded directories in the path
            if any(part in excluded_dirs for part in file_path.parts):
                if self.debug:
                    print(f"Debug: Skipping excluded directory: {file_path}")
                return False

            # Check if file extension is in whitelist
            if file_path.suffix.lower() not in SOURCE_EXTENSIONS:
                if self.debug:
                    print(f"Debug: Skipping non-source file: {file_path}")
                return False

            # Check custom ignore patterns
            for pattern in IGNORE_PATTERNS:
                if fnmatch.fnmatch(str(rel_path), pattern):
                    if self.debug:
                        print(f"Debug: Skipping ignored pattern {pattern}: {file_path}")
                    return False

            # Check .gitignore if available
            if self.gitignore_matcher:
                try:
                    should_include = not self.gitignore_matcher(str(file_path))
                    if self.debug and not should_include:
                        print(f"Debug: Skipping gitignored file: {file_path}")
                    return should_include
                except Exception as e:
                    print(f"Warning: gitignore matching failed for {file_path}: {e}")
                    return True

            if self.debug:
                print(f"Debug: Including file: {file_path}")
            return True

        except Exception as e:
            print(f"Warning: Error checking file {file_path}: {e}")
            return False

    def _get_file_content(self, file_path: Path) -> str:
        """Read file content with proper encoding handling"""
        try:
            # Try UTF-8 first
            with open(file_path, 'r', encoding='utf-8') as f:
                return f.read()
        except UnicodeDecodeError:
            try:
                # Fallback to latin-1
                with open(file_path, 'r', encoding='latin-1') as f:
                    return f.read()
            except Exception as e:
                print(f"Warning: Failed to read {file_path}: {e}")
                return f"ERROR: Could not read file {file_path}\n"

    def _generate_directory_structure(self) -> str:
        """Generate a tree-like directory structure"""
        structure = ["Directory Structure:", ""]

        def add_to_tree(path: Path, prefix: str = ""):
            # Skip excluded directories
            excluded_dirs = {
                '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
                '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
                'dist', 'build', 'target'
            }
            if path.name in excluded_dirs:
                return

            # Add files first
            files = sorted([p for p in path.iterdir() if p.is_file()])
            included_files = [f for f in files if self._should_include_file(f)]

            for idx, file in enumerate(included_files):
                is_last = idx == len(included_files) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {file.name}")

            # Then add directories
            dirs = sorted([p for p in path.iterdir() if p.is_dir()])
            included_dirs = [d for d in dirs if d.name not in excluded_dirs]

            for idx, dir in enumerate(included_dirs):
                is_last = idx == len(included_dirs) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {dir.name}/")
                add_to_tree(dir, prefix + ("    " if is_last else "│   "))

        add_to_tree(self.project_path)
        return "\n".join(structure)

    def concatenate(self, debug: bool = False):
        """Main method to concatenate all source files"""
        self.debug = debug
        if not self.project_path.exists():
            print(f"Error: Project path {self.project_path} does not exist")
            return False

        try:
            with open(self.output_file, 'w', encoding='utf-8') as out:
                # Write header
                header = f"""
# Project Source Code Concatenation
# Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
# Project path: {self.project_path}

"""
                out.write(header)

                # Write directory structure
                out.write(self._generate_directory_structure())
                out.write("\n\n" + "="*80 + "\n\n")

                # Process all files
                file_count = 0
                for file_path in self.project_path.rglob('*'):
                    if file_path.is_file() and self._should_include_file(file_path):
                        rel_path = file_path.relative_to(self.project_path)

                        # Write file header
                        out.write(f"\n\n# File: {rel_path}\n")
                        out.write("="*80 + "\n\n")

                        # Write file content
                        content = self._get_file_content(file_path)
                        out.write(content)
                        file_count += 1

                print(f"Successfully melted {file_count} files to {self.output_file}")
                return True

        except Exception as e:
            print(f"Error during melting: {e}")
            return False

def main():
    parser = argparse.ArgumentParser(
        description="CodeSmelt: Melt down your git project's source code into a single file"
    )
    parser.add_argument(
        "project_path",
        help="Path to the git project directory"
    )
    parser.add_argument(
        "-o", "--output",
        default="concatenated_source.txt",
        help="Output file path (default: concatenated_source.txt)"
    )
    parser.add_argument(
        "-d", "--debug",
        action="store_true",
        help="Enable debug logging"
    )

    args = parser.parse_args()

    concatenator = CodeSmelt(args.project_path, args.output)
    success = concatenator.concatenate(debug=args.debug)
    sys.exit(0 if success else 1)

if __name__ == "__main__":
    main()

# File: README.md
================================================================================

python --version
   ```

2. Install the required dependency:
   ```bash
   pip install gitignore-parser
   ```

## Usage

Basic usage:
```bash
python codesmelt.py /path/to/project -o output.txt
```

With debug logging:
```bash
python codesmelt.py /path/to/project -o output.txt --debug
```

### Command-line Arguments

- `project_path`: Path to the Git project directory (required)
- `-o, --output`: Output file path (default: concatenated_source.txt)
- `-d, --debug`: Enable debug logging

## Configuration

### Source File Extensions
The tool includes common source code file extensions by default (defined in `extensions.py`):
- Web: `.js`, `.ts`, `.jsx`, `.tsx`, `.vue`, `.svelte`, `.html`, `.css`, etc.
- Python: `.py`, `.pyi`, `.pyx`
- Java/Kotlin: `.java`, `.kt`, `.groovy`
- C-family: `.c`, `.cpp`, `.h`, `.hpp`
- And many more...

#### Customizing File Extensions
You can modify which file extensions are included by editing the `SOURCE_EXTENSIONS` set in `extensions.py`. For example, to include Unity3D script files while excluding other Unity files:

```python
SOURCE_EXTENSIONS = {
    # ... existing extensions ...

    # Unity3D specific
    '.cs',  # C# scripts
    '.shader', # Custom shaders
    '.asmdef', # Assembly definitions

    # ... other extensions ...
}
```

### Ignore Patterns
The tool automatically ignores files based on three levels:

1. Built-in patterns (`IGNORE_PATTERNS` in `extensions.py`):
   - Build outputs (`build/*`, `dist/*`, `*.pyc`, etc.)
   - Dependencies (`node_modules/*`, `vendor/*`, `venv/*`)
   - IDE files (`.idea/*`, `.vscode/*`)
   - Package lock files (`package-lock.json`, `poetry.lock`, etc.)
   - Binary and media files (`*.pdf`, `*.jpg`, `*.exe`, etc.)

2. Project's `.gitignore` rules (if present)
3. Directory-specific `.gitignore` rules

#### Customizing Ignore Patterns
To modify which files are ignored, you can:

1. Edit `IGNORE_PATTERNS` in `extensions.py`:
```python
IGNORE_PATTERNS = {
    # ... existing patterns ...

    # Unity3D specific ignores
    'Assets/AssetStoreTools/*',
    'Library/*',
    'Temp/*',
    'Logs/*',
    '*.unity',  # Unity scene files
    '*.meta',   # Unity meta files
    '*.prefab', # Unity prefab files

    # ... other patterns ...
}
```

2. Use your project's `.gitignore` file for project-specific exclusions

**Note**: Ignore patterns follow the same syntax as `.gitignore` files. The tool processes these rules in order:
1. Built-in `IGNORE_PATTERNS`
2. Project's root `.gitignore`
3. Directory-specific `.gitignore` files


## Tips for Using with LLMs

1. **Token Management**:
   - For large projects, consider concatenating only specific directories
   - Use the debug mode to see which files are included/excluded
   - Remove unnecessary documentation files if you're close to token limits

2. **Effective Prompting**:
   - Reference files using their relative paths as shown in the directory structure
   - Use the directory structure to ask about specific components
   - Refer to file relationships based on the visual structure

3. **Best Practices**:
   - Review the concatenated output before sending to ensure relevance
   - For large projects, break down analysis into smaller, focused components
   - Use the debug mode to verify file selection when customizing

## Output Format

The generated file includes:
1. A timestamp and project path header
2. A visual directory structure of the project
3. The contents of each source file, clearly separated with headers

Example output:
```
# Project Source Code Concatenation
# Generated on: 2025-02-15 20:53:29
# Project path: /path/to/project

Directory Structure:
├── src/
│   ├── main.py
│   └── utils.py
└── README.md

================================================================================

# File: src/main.py
================================================================================
[File contents here]

# File: src/utils.py
================================================================================
[File contents here]
```

## Troubleshooting

### Common Issues

1. **No Files Found**:
   - Verify the project path is correct
   - Check if files have supported extensions
   - Run with --debug to see which files are being filtered

2. **Missing Dependencies**:
   ```bash
   pip install --upgrade gitignore-parser

# File: codesmelt.py
================================================================================

#!/usr/bin/env python3
"""
CodeSmelt: Source Code Concatenator

This tool melts down source code files from a git project into a single file,
including directory structure information.
"""

import argparse
import sys
from pathlib import Path
import os
from typing import Set, List, Optional
import fnmatch
from datetime import datetime
import gitignore_parser
from extensions import SOURCE_EXTENSIONS, IGNORE_PATTERNS

class CodeSmelt:
    def __init__(self, project_path: str, output_file: str):
        self.project_path = Path(project_path).resolve()
        self.output_file = Path(output_file)
        self.gitignore_matcher = self._setup_gitignore()
        self.debug = False

    def _setup_gitignore(self) -> Optional[callable]:
        """Setup gitignore matcher if .gitignore exists"""
        gitignore_path = self.project_path / '.gitignore'
        if gitignore_path.exists():
            try:
                return gitignore_parser.parse_gitignore(gitignore_path)
            except Exception as e:
                print(f"Warning: Failed to parse .gitignore: {e}")
        return None

    def _should_include_file(self, file_path: Path) -> bool:
        """Check if file should be included based on extension and ignore rules"""
        # Skip common virtual environment and system directories
        excluded_dirs = {
            '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
            '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
            'dist', 'build', 'target'
        }

        try:
            # Convert to relative path for checking
            try:
                rel_path = file_path.relative_to(self.project_path)
            except ValueError:
                if self.debug:
                    print(f"Debug: Skipping file outside project path: {file_path}")
                return False

            # Check for excluded directories in the path
            if any(part in excluded_dirs for part in file_path.parts):
                if self.debug:
                    print(f"Debug: Skipping excluded directory: {file_path}")
                return False

            # Check if file extension is in whitelist
            if file_path.suffix.lower() not in SOURCE_EXTENSIONS:
                if self.debug:
                    print(f"Debug: Skipping non-source file: {file_path}")
                return False

            # Check custom ignore patterns
            for pattern in IGNORE_PATTERNS:
                if fnmatch.fnmatch(str(rel_path), pattern):
                    if self.debug:
                        print(f"Debug: Skipping ignored pattern {pattern}: {file_path}")
                    return False

            # Check .gitignore if available
            if self.gitignore_matcher:
                try:
                    should_include = not self.gitignore_matcher(str(file_path))
                    if self.debug and not should_include:
                        print(f"Debug: Skipping gitignored file: {file_path}")
                    return should_include
                except Exception as e:
                    print(f"Warning: gitignore matching failed for {file_path}: {e}")
                    return True

            if self.debug:
                print(f"Debug: Including file: {file_path}")
            return True

        except Exception as e:
            print(f"Warning: Error checking file {file_path}: {e}")
            return False

    def _get_file_content(self, file_path: Path) -> str:
        """Read file content with proper encoding handling"""
        try:
            # Try UTF-8 first
            with open(file_path, 'r', encoding='utf-8') as f:
                return f.read()
        except UnicodeDecodeError:
            try:
                # Fallback to latin-1
                with open(file_path, 'r', encoding='latin-1') as f:
                    return f.read()
            except Exception as e:
                print(f"Warning: Failed to read {file_path}: {e}")
                return f"ERROR: Could not read file {file_path}\n"

    def _generate_directory_structure(self) -> str:
        """Generate a tree-like directory structure"""
        structure = ["Directory Structure:", ""]

        def add_to_tree(path: Path, prefix: str = ""):
            # Skip excluded directories
            excluded_dirs = {
                '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
                '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
                'dist', 'build', 'target'
            }
            if path.name in excluded_dirs:
                return

            # Add files first
            files = sorted([p for p in path.iterdir() if p.is_file()])
            included_files = [f for f in files if self._should_include_file(f)]

            for idx, file in enumerate(included_files):
                is_last = idx == len(included_files) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {file.name}")

            # Then add directories
            dirs = sorted([p for p in path.iterdir() if p.is_dir()])
            included_dirs = [d for d in dirs if d.name not in excluded_dirs]

            for idx, dir in enumerate(included_dirs):
                is_last = idx == len(included_dirs) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {dir.name}/")
                add_to_tree(dir, prefix + ("    " if is_last else "│   "))

        add_to_tree(self.project_path)
        return "\n".join(structure)

    def concatenate(self, debug: bool = False):
        """Main method to concatenate all source files"""
        self.debug = debug
        if not self.project_path.exists():
            print(f"Error: Project path {self.project_path} does not exist")
            return False

        try:
            with open(self.output_file, 'w', encoding='utf-8') as out:
                # Write header
                header = f"""
# Project Source Code Concatenation
# Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
# Project path: {self.project_path}

"""
                out.write(header)

                # Write directory structure
                out.write(self._generate_directory_structure())
                out.write("\n\n" + "="*80 + "\n\n")

                # Process all files
                file_count = 0
                for file_path in self.project_path.rglob('*'):
                    if file_path.is_file() and self._should_include_file(file_path):
                        rel_path = file_path.relative_to(self.project_path)

                        # Write file header
                        out.write(f"\n\n# File: {rel_path}\n")
                        out.write("="*80 + "\n\n")

                        # Write file content
                        content = self._get_file_content(file_path)
                        out.write(content)
                        file_count += 1

                print(f"Successfully melted {file_count} files to {self.output_file}")
                return True

        except Exception as e:
            print(f"Error during melting: {e}")
            return False

def main():
    parser = argparse.ArgumentParser(
        description="CodeSmelt: Melt down your git project's source code into a single file",
        usage="%(prog)s [-o OUTPUT] [-d] project_path"
    )
    parser.add_argument(
        "-o", "--output",
        default="concatenated_source.txt",
        help="Output file path (default: concatenated_source.txt)"
    )
    parser.add_argument(
        "-d", "--debug",
        action="store_true",
        help="Enable debug logging"
    )
    parser.add_argument(
        "project_path",
        help="Path to the git project directory",
        nargs="?"  # Make it optional in the parser (though we'll check it's provided)
    )

    args = parser.parse_args()

    if not args.project_path:
        parser.error("project_path is required")

    concatenator = CodeSmelt(args.project_path, args.output)
    success = concatenator.concatenate(debug=args.debug)
    sys.exit(0 if success else 1)

if __name__ == "__main__":
    main()

# File: README.md
================================================================================

python codesmelt.py /path/to/project
```

Specify custom output file:
```bash
python codesmelt.py -o output.txt /path/to/project
```

With debug logging:
```bash
python codesmelt.py -d -o output.txt /path/to/project
```

### Command-line Arguments
- `project_path`: Path to the Git project directory (required)
- `-o, --output`: Output file path (default: concatenated_source.txt)
- `-d, --debug`: Enable debug logging

## Configuration

### Source File Extensions
The tool includes common source code file extensions by default (defined in `extensions.py`):
- Web: `.js`, `.ts`, `.jsx`, `.tsx`, `.vue`, `.svelte`, `.html`, `.css`, etc.
- Python: `.py`, `.pyi`, `.pyx`
- Java/Kotlin: `.java`, `.kt`, `.groovy`
- C-family: `.c`, `.cpp`, `.h`, `.hpp`
- And many more...

#### Customizing File Extensions
You can modify which file extensions are included by editing the `SOURCE_EXTENSIONS` set in `extensions.py`. For example, to include Unity3D script files while excluding other Unity files:

```python
SOURCE_EXTENSIONS = {
    # ... existing extensions ...

    # Unity3D specific
    '.cs',  # C# scripts
    '.shader', # Custom shaders
    '.asmdef', # Assembly definitions

    # ... other extensions ...
}
```

### Ignore Patterns
The tool automatically ignores files based on three levels:

1. Built-in patterns (`IGNORE_PATTERNS` in `extensions.py`):
   - Build outputs (`build/*`, `dist/*`, `*.pyc`, etc.)
   - Dependencies (`node_modules/*`, `vendor/*`, `venv/*`)
   - IDE files (`.idea/*`, `.vscode/*`)
   - Package lock files (`package-lock.json`, `poetry.lock`, etc.)
   - Binary and media files (`*.pdf`, `*.jpg`, `*.exe`, etc.)

2. Project's `.gitignore` rules (if present)
3. Directory-specific `.gitignore` rules

#### Customizing Ignore Patterns
To modify which files are ignored, you can:

1. Edit `IGNORE_PATTERNS` in `extensions.py`:
```python
IGNORE_PATTERNS = {
    # ... existing patterns ...

    # Unity3D specific ignores
    'Assets/AssetStoreTools/*',
    'Library/*',
    'Temp/*',
    'Logs/*',
    '*.unity',  # Unity scene files
    '*.meta',   # Unity meta files
    '*.prefab', # Unity prefab files

    # ... other patterns ...
}
```

2. Use your project's `.gitignore` file for project-specific exclusions

**Note**: Ignore patterns follow the same syntax as `.gitignore` files. The tool processes these rules in order:
1. Built-in `IGNORE_PATTERNS`
2. Project's root `.gitignore`
3. Directory-specific `.gitignore` files


## Tips for Using with LLMs

1. **Token Management**:
   - For large projects, consider concatenating only specific directories
   - Use the debug mode to see which files are included/excluded
   - Remove unnecessary documentation files if you're close to token limits

2. **Effective Prompting**:
   - Reference files using their relative paths as shown in the directory structure
   - Use the directory structure to ask about specific components
   - Refer to file relationships based on the visual structure

3. **Best Practices**:
   - Review the concatenated output before sending to ensure relevance
   - For large projects, break down analysis into smaller, focused components
   - Use the debug mode to verify file selection when customizing

## Output Format

The generated file includes:
1. A timestamp and project path header
2. A visual directory structure of the project
3. The contents of each source file, clearly separated with headers

Example output:
```
# Project Source Code Concatenation
# Generated on: 2025-02-15 20:53:29
# Project path: /path/to/project

Directory Structure:
├── src/
│   ├── main.py
│   └── utils.py
└── README.md

================================================================================

# File: src/main.py
================================================================================
[File contents here]

# File: src/utils.py
================================================================================
[File contents here]
```

## Troubleshooting

### Common Issues

1. **No Files Found**:
   - Verify the project path is correct
   - Check if files have supported extensions
   - Run with --debug to see which files are being filtered

2. **Missing Dependencies**:
   ```bash
   pip install --upgrade gitignore-parser

# File: codesmelt.py
================================================================================

#!/usr/bin/env python3
"""
CodeSmelt: Source Code Concatenator

This tool melts down source code files from a git project into a single file,
including directory structure information.
"""

import argparse
import sys
from pathlib import Path
import os
from typing import Set, List, Optional
import fnmatch
from datetime import datetime
import gitignore_parser
from extensions import SOURCE_EXTENSIONS, IGNORE_PATTERNS

class CodeSmelt:
    def __init__(self, project_path: str, output_file: str):
        self.project_path = Path(project_path).resolve()
        self.output_file = Path(output_file)
        self.gitignore_matcher = self._setup_gitignore()
        self.debug = False

    def _setup_gitignore(self) -> Optional[callable]:
        """Setup gitignore matcher if .gitignore exists"""
        gitignore_path = self.project_path / '.gitignore'
        if gitignore_path.exists():
            try:
                return gitignore_parser.parse_gitignore(gitignore_path)
            except Exception as e:
                print(f"Warning: Failed to parse .gitignore: {e}")
        return None

    def _should_include_file(self, file_path: Path) -> bool:
        """Check if file should be included based on extension and ignore rules"""
        # Skip common virtual environment and system directories
        excluded_dirs = {
            '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
            '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
            'dist', 'build', 'target'
        }

        try:
            # Convert to relative path for checking
            try:
                rel_path = file_path.relative_to(self.project_path)
            except ValueError:
                if self.debug:
                    print(f"Debug: Skipping file outside project path: {file_path}")
                return False

            # Check for excluded directories in the path
            if any(part in excluded_dirs for part in file_path.parts):
                if self.debug:
                    print(f"Debug: Skipping excluded directory: {file_path}")
                return False

            # Check if file extension is in whitelist
            if file_path.suffix.lower() not in SOURCE_EXTENSIONS:
                if self.debug:
                    print(f"Debug: Skipping non-source file: {file_path}")
                return False

            # Check custom ignore patterns
            for pattern in IGNORE_PATTERNS:
                if fnmatch.fnmatch(str(rel_path), pattern):
                    if self.debug:
                        print(f"Debug: Skipping ignored pattern {pattern}: {file_path}")
                    return False

            # Check .gitignore if available
            if self.gitignore_matcher:
                try:
                    should_include = not self.gitignore_matcher(str(file_path))
                    if self.debug and not should_include:
                        print(f"Debug: Skipping gitignored file: {file_path}")
                    return should_include
                except Exception as e:
                    print(f"Warning: gitignore matching failed for {file_path}: {e}")
                    return True

            if self.debug:
                print(f"Debug: Including file: {file_path}")
            return True

        except Exception as e:
            print(f"Warning: Error checking file {file_path}: {e}")
            return False

    def _get_file_content(self, file_path: Path) -> str:
        """Read file content with proper encoding handling"""
        try:
            # Try UTF-8 first
            with open(file_path, 'r', encoding='utf-8') as f:
                return f.read()
        except UnicodeDecodeError:
            try:
                # Fallback to latin-1
                with open(file_path, 'r', encoding='latin-1') as f:
                    return f.read()
            except Exception as e:
                print(f"Warning: Failed to read {file_path}: {e}")
                return f"ERROR: Could not read file {file_path}\n"

    def _generate_directory_structure(self) -> str:
        """Generate a tree-like directory structure"""
        structure = ["Directory Structure:", ""]

        def add_to_tree(path: Path, prefix: str = ""):
            # Skip excluded directories
            excluded_dirs = {
                '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
                '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
                'dist', 'build', 'target'
            }
            if path.name in excluded_dirs:
                return

            # Add files first
            files = sorted([p for p in path.iterdir() if p.is_file()])
            included_files = [f for f in files if self._should_include_file(f)]

            for idx, file in enumerate(included_files):
                is_last = idx == len(included_files) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {file.name}")

            # Then add directories
            dirs = sorted([p for p in path.iterdir() if p.is_dir()])
            included_dirs = [d for d in dirs if d.name not in excluded_dirs]

            for idx, dir in enumerate(included_dirs):
                is_last = idx == len(included_dirs) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {dir.name}/")
                add_to_tree(dir, prefix + ("    " if is_last else "│   "))

        add_to_tree(self.project_path)
        return "\n".join(structure)

    def concatenate(self, debug: bool = False):
        """Main method to concatenate all source files"""
        self.debug = debug
        if not self.project_path.exists():
            print(f"Error: Project path {self.project_path} does not exist")
            return False

        try:
            with open(self.output_file, 'w', encoding='utf-8') as out:
                # Write header
                header = f"""
# Project Source Code Concatenation
# Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
# Project path: {self.project_path}

"""
                out.write(header)

                # Write directory structure
                out.write(self._generate_directory_structure())
                out.write("\n\n" + "="*80 + "\n\n")

                # Process all files
                file_count = 0
                for file_path in self.project_path.rglob('*'):
                    if file_path.is_file() and self._should_include_file(file_path):
                        rel_path = file_path.relative_to(self.project_path)

                        # Write file header
                        out.write(f"\n\n# File: {rel_path}\n")
                        out.write("="*80 + "\n\n")

                        # Write file content
                        content = self._get_file_content(file_path)
                        out.write(content)
                        file_count += 1

                print(f"Successfully melted {file_count} files to {self.output_file}")
                return True

        except Exception as e:
            print(f"Error during melting: {e}")
            return False

def main():
    parser = argparse.ArgumentParser(
        description="CodeSmelt: Melt down your git project's source code into a single file",
        usage="%(prog)s [-o OUTPUT] [-d] project_path"
    )
    parser.add_argument(
        "-o", "--output",
        default="concatenated_source.txt",
        help="Output file path (default: concatenated_source.txt)"
    )
    parser.add_argument(
        "-d", "--debug",
        action="store_true",
        help="Enable debug logging"
    )
    parser.add_argument(
        "project_path",
        help="Path to the git project directory",
        nargs="?"  # Make it optional in the parser (though we'll check it's provided)
    )

    args = parser.parse_args()

    if not args.project_path:
        parser.error("project_path is required")

    concatenator = CodeSmelt(args.project_path, args.output)
    success = concatenator.concatenate(debug=args.debug)
    sys.exit(0 if success else 1)

if __name__ == "__main__":
    main()

# File: README.md
================================================================================

python codesmelt.py /path/to/project
```

Specify custom output file:
```bash
python codesmelt.py -o output.txt /path/to/project
```

With debug logging:
```bash
python codesmelt.py -d -o output.txt /path/to/project
```

### Command-line Arguments
- `project_path`: Path to the Git project directory (required)
- `-o, --output`: Output file path (default: concatenated_source.txt)
- `-d, --debug`: Enable debug logging

## Configuration

### Source File Extensions
The tool includes common source code file extensions by default (defined in `extensions.py`):
- Web: `.js`, `.ts`, `.jsx`, `.tsx`, `.vue`, `.svelte`, `.html`, `.css`, etc.
- Python: `.py`, `.pyi`, `.pyx`
- Java/Kotlin: `.java`, `.kt`, `.groovy`
- C-family: `.c`, `.cpp`, `.h`, `.hpp`
- And many more...

#### Customizing File Extensions
You can modify which file extensions are included by editing the `SOURCE_EXTENSIONS` set in `extensions.py`. For example, to include Unity3D script files while excluding other Unity files:

```python
SOURCE_EXTENSIONS = {
    # ... existing extensions ...

    # Unity3D specific
    '.cs',  # C# scripts
    '.shader', # Custom shaders
    '.asmdef', # Assembly definitions

    # ... other extensions ...
}
```

### Ignore Patterns
The tool automatically ignores files based on three levels:

1. Built-in patterns (`IGNORE_PATTERNS` in `extensions.py`):
   - Build outputs (`build/*`, `dist/*`, `*.pyc`, etc.)
   - Dependencies (`node_modules/*`, `vendor/*`, `venv/*`)
   - IDE files (`.idea/*`, `.vscode/*`)
   - Package lock files (`package-lock.json`, `poetry.lock`, etc.)
   - Binary and media files (`*.pdf`, `*.jpg`, `*.exe`, etc.)

2. Project's `.gitignore` rules (if present)
3. Directory-specific `.gitignore` rules

#### Customizing Ignore Patterns
To modify which files are ignored, you can:

1. Edit `IGNORE_PATTERNS` in `extensions.py`:
```python
IGNORE_PATTERNS = {
    # ... existing patterns ...

    # Unity3D specific ignores
    'Assets/AssetStoreTools/*',
    'Library/*',
    'Temp/*',
    'Logs/*',
    '*.unity',  # Unity scene files
    '*.meta',   # Unity meta files
    '*.prefab', # Unity prefab files

    # ... other patterns ...
}
```

2. Use your project's `.gitignore` file for project-specific exclusions

**Note**: Ignore patterns follow the same syntax as `.gitignore` files. The tool processes these rules in order:
1. Built-in `IGNORE_PATTERNS`
2. Project's root `.gitignore`
3. Directory-specific `.gitignore` files


## Tips for Using with LLMs

1. **Token Management**:
   - For large projects, consider concatenating only specific directories
   - Use the debug mode to see which files are included/excluded
   - Remove unnecessary documentation files if you're close to token limits

2. **Effective Prompting**:
   - Reference files using their relative paths as shown in the directory structure
   - Use the directory structure to ask about specific components
   - Refer to file relationships based on the visual structure

3. **Best Practices**:
   - Review the concatenated output before sending to ensure relevance
   - For large projects, break down analysis into smaller, focused components
   - Use the debug mode to verify file selection when customizing

## Output Format

The generated file includes:
1. A timestamp and project path header
2. A visual directory structure of the project
3. The contents of each source file, clearly separated with headers

Example output:
```
# Project Source Code Concatenation
# Generated on: 2025-02-15 20:53:29
# Project path: /path/to/project

Directory Structure:
├── src/
│   ├── main.py
│   └── utils.py
└── README.md

================================================================================

# File: src/main.py
================================================================================
[File contents here]

# File: src/utils.py
================================================================================
[File contents here]
```

## Troubleshooting

### Common Issues

1. **No Files Found**:
   - Verify the project path is correct
   - Check if files have supported extensions
   - Run with --debug to see which files are being filtered

2. **Missing Dependencies**:
   ```bash
   pip install --upgrade gitignore-parser

# File: test_output.txt
================================================================================


# Project Source Code Concatenation
# Generated on: 2025-02-15 22:55:02
# Project path: /home/runner/workspace

Directory Structure:

├── README.md
├── codesmelt.py
├── concatenated_source.txt
├── extensions.py
├── output.txt
├── pyproject.toml
└── test_output.txt

================================================================================



# File: extensions.py
================================================================================

"""
Source code file extension configurations
"""

# Common source code file extensions
SOURCE_EXTENSIONS = {
    # Web
    '.js', '.ts', '.jsx', '.tsx', '.vue', '.svelte',
    '.html', '.htm', '.css', '.scss', '.sass', '.less',
    
    # Python
    '.py', '.pyi', '.pyx',
    
    # Java/Kotlin
    '.java', '.kt', '.groovy',
    
    # C-family
    '.c', '.cpp', '.h', '.hpp', '.cc',
    
    # C#
    '.cs', '.cshtml', '.csx',
    
    # Ruby
    '.rb', '.erb',
    
    # PHP
    '.php', '.php5', '.phtml',
    
    # Go
    '.go',
    
    # Rust
    '.rs',
    
    # Swift
    '.swift',
    
    # Shell
    '.sh', '.bash', '.zsh',
    
    # Config/Data
    '.json', '.yaml', '.yml', '.toml', '.xml',
    '.conf', '.ini', '.env',
    
    # Documentation
    '.md', '.rst', '.txt'
}

# Files to always ignore
IGNORE_PATTERNS = {
    # Build outputs
    'build/*', 'dist/*', 'target/*', 'bin/*',
    '*.pyc', '__pycache__/*', '*.class',
    
    # Dependencies
    'node_modules/*', 'vendor/*', 'venv/*',
    
    # IDE files
    '.idea/*', '.vscode/*', '*.swp',
    
    # Package files
    'package-lock.json', 'yarn.lock',
    'Pipfile.lock', 'poetry.lock',
    
    # Large data files
    '*.csv', '*.json.gz', '*.sql',
    
    # Binary/Media files
    '*.pdf', '*.jpg', '*.png', '*.gif',
    '*.mp3', '*.mp4', '*.mov', '*.bin',
    '*.exe', '*.dll', '*.so', '*.dylib'
}


# File: pyproject.toml
================================================================================

[project]
name = "repl-nix-workspace"
version = "0.1.0"
description = "Add your description here"
requires-python = ">=3.11"
dependencies = [
    "gitignore-parser>=0.1.11",
]


# File: concatenated_source.txt
================================================================================


# Project Source Code Concatenation
# Generated on: 2025-02-15 22:55:02
# Project path: /home/runner/workspace

Directory Structure:

├── README.md
├── codesmelt.py
├── concatenated_source.txt
├── extensions.py
├── output.txt
└── pyproject.toml

================================================================================



# File: extensions.py
================================================================================

"""
Source code file extension configurations
"""

# Common source code file extensions
SOURCE_EXTENSIONS = {
    # Web
    '.js', '.ts', '.jsx', '.tsx', '.vue', '.svelte',
    '.html', '.htm', '.css', '.scss', '.sass', '.less',
    
    # Python
    '.py', '.pyi', '.pyx',
    
    # Java/Kotlin
    '.java', '.kt', '.groovy',
    
    # C-family
    '.c', '.cpp', '.h', '.hpp', '.cc',
    
    # C#
    '.cs', '.cshtml', '.csx',
    
    # Ruby
    '.rb', '.erb',
    
    # PHP
    '.php', '.php5', '.phtml',
    
    # Go
    '.go',
    
    # Rust
    '.rs',
    
    # Swift
    '.swift',
    
    # Shell
    '.sh', '.bash', '.zsh',
    
    # Config/Data
    '.json', '.yaml', '.yml', '.toml', '.xml',
    '.conf', '.ini', '.env',
    
    # Documentation
    '.md', '.rst', '.txt'
}

# Files to always ignore
IGNORE_PATTERNS = {
    # Build outputs
    'build/*', 'dist/*', 'target/*', 'bin/*',
    '*.pyc', '__pycache__/*', '*.class',
    
    # Dependencies
    'node_modules/*', 'vendor/*', 'venv/*',
    
    # IDE files
    '.idea/*', '.vscode/*', '*.swp',
    
    # Package files
    'package-lock.json', 'yarn.lock',
    'Pipfile.lock', 'poetry.lock',
    
    # Large data files
    '*.csv', '*.json.gz', '*.sql',
    
    # Binary/Media files
    '*.pdf', '*.jpg', '*.png', '*.gif',
    '*.mp3', '*.mp4', '*.mov', '*.bin',
    '*.exe', '*.dll', '*.so', '*.dylib'
}


# File: pyproject.toml
================================================================================

[project]
name = "repl-nix-workspace"
version = "0.1.0"
description = "Add your description here"
requires-python = ">=3.11"
dependencies = [
    "gitignore-parser>=0.1.11",
]


# File: concatenated_source.txt
================================================================================



# File: output.txt
================================================================================


# Project Source Code Concatenation
# Generated on: 2025-02-15 22:44:33
# Project path: /home/runner/workspace

Directory Structure:

├── README.md
├── codesmelt.py
├── concatenated_source.txt
├── extensions.py
├── output.txt
└── pyproject.toml

================================================================================



# File: extensions.py
================================================================================

"""
Source code file extension configurations
"""

# Common source code file extensions
SOURCE_EXTENSIONS = {
    # Web
    '.js', '.ts', '.jsx', '.tsx', '.vue', '.svelte',
    '.html', '.htm', '.css', '.scss', '.sass', '.less',
    
    # Python
    '.py', '.pyi', '.pyx',
    
    # Java/Kotlin
    '.java', '.kt', '.groovy',
    
    # C-family
    '.c', '.cpp', '.h', '.hpp', '.cc',
    
    # C#
    '.cs', '.cshtml', '.csx',
    
    # Ruby
    '.rb', '.erb',
    
    # PHP
    '.php', '.php5', '.phtml',
    
    # Go
    '.go',
    
    # Rust
    '.rs',
    
    # Swift
    '.swift',
    
    # Shell
    '.sh', '.bash', '.zsh',
    
    # Config/Data
    '.json', '.yaml', '.yml', '.toml', '.xml',
    '.conf', '.ini', '.env',
    
    # Documentation
    '.md', '.rst', '.txt'
}

# Files to always ignore
IGNORE_PATTERNS = {
    # Build outputs
    'build/*', 'dist/*', 'target/*', 'bin/*',
    '*.pyc', '__pycache__/*', '*.class',
    
    # Dependencies
    'node_modules/*', 'vendor/*', 'venv/*',
    
    # IDE files
    '.idea/*', '.vscode/*', '*.swp',
    
    # Package files
    'package-lock.json', 'yarn.lock',
    'Pipfile.lock', 'poetry.lock',
    
    # Large data files
    '*.csv', '*.json.gz', '*.sql',
    
    # Binary/Media files
    '*.pdf', '*.jpg', '*.png', '*.gif',
    '*.mp3', '*.mp4', '*.mov', '*.bin',
    '*.exe', '*.dll', '*.so', '*.dylib'
}


# File: pyproject.toml
================================================================================

[project]
name = "repl-nix-workspace"
version = "0.1.0"
description = "Add your description here"
requires-python = ">=3.11"
dependencies = [
    "gitignore-parser>=0.1.11",
]


# File: concatenated_source.txt
================================================================================


# Project Source Code Concatenation
# Generated on: 2025-02-15 21:22:24
# Project path: /home/runner/workspace

Directory Structure:

├── README.md
├── concatenated_source.txt
├── extensions.py
├── git_concatenator.py
└── pyproject.toml

================================================================================



# File: extensions.py
================================================================================

"""
Source code file extension configurations
"""

# Common source code file extensions
SOURCE_EXTENSIONS = {
    # Web
    '.js', '.ts', '.jsx', '.tsx', '.vue', '.svelte',
    '.html', '.htm', '.css', '.scss', '.sass', '.less',
    
    # Python
    '.py', '.pyi', '.pyx',
    
    # Java/Kotlin
    '.java', '.kt', '.groovy',
    
    # C-family
    '.c', '.cpp', '.h', '.hpp', '.cc',
    
    # C#
    '.cs', '.cshtml', '.csx',
    
    # Ruby
    '.rb', '.erb',
    
    # PHP
    '.php', '.php5', '.phtml',
    
    # Go
    '.go',
    
    # Rust
    '.rs',
    
    # Swift
    '.swift',
    
    # Shell
    '.sh', '.bash', '.zsh',
    
    # Config/Data
    '.json', '.yaml', '.yml', '.toml', '.xml',
    '.conf', '.ini', '.env',
    
    # Documentation
    '.md', '.rst', '.txt'
}

# Files to always ignore
IGNORE_PATTERNS = {
    # Build outputs
    'build/*', 'dist/*', 'target/*', 'bin/*',
    '*.pyc', '__pycache__/*', '*.class',
    
    # Dependencies
    'node_modules/*', 'vendor/*', 'venv/*',
    
    # IDE files
    '.idea/*', '.vscode/*', '*.swp',
    
    # Package files
    'package-lock.json', 'yarn.lock',
    'Pipfile.lock', 'poetry.lock',
    
    # Large data files
    '*.csv', '*.json.gz', '*.sql',
    
    # Binary/Media files
    '*.pdf', '*.jpg', '*.png', '*.gif',
    '*.mp3', '*.mp4', '*.mov', '*.bin',
    '*.exe', '*.dll', '*.so', '*.dylib'
}


# File: pyproject.toml
================================================================================

[project]
name = "repl-nix-workspace"
version = "0.1.0"
description = "Add your description here"
requires-python = ">=3.11"
dependencies = [
    "gitignore-parser>=0.1.11",
]


# File: concatenated_source.txt
================================================================================



# File: git_concatenator.py
================================================================================

#!/usr/bin/env python3
"""
Git Project Source Code Concatenator

This tool concatenates source code files from a git project into a single file,
including directory structure information.
"""

import argparse
import sys
from pathlib import Path
import os
from typing import Set, List, Optional
import fnmatch
from datetime import datetime
import gitignore_parser
from extensions import SOURCE_EXTENSIONS, IGNORE_PATTERNS

class GitConcatenator:
    def __init__(self, project_path: str, output_file: str):
        self.project_path = Path(project_path).resolve()
        self.output_file = Path(output_file)
        self.gitignore_matcher = self._setup_gitignore()
        self.debug = False

    def _setup_gitignore(self) -> Optional[callable]:
        """Setup gitignore matcher if .gitignore exists"""
        gitignore_path = self.project_path / '.gitignore'
        if gitignore_path.exists():
            try:
                return gitignore_parser.parse_gitignore(gitignore_path)
            except Exception as e:
                print(f"Warning: Failed to parse .gitignore: {e}")
        return None

    def _should_include_file(self, file_path: Path) -> bool:
        """Check if file should be included based on extension and ignore rules"""
        # Skip common virtual environment and system directories
        excluded_dirs = {
            '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
            '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
            'dist', 'build', 'target'
        }

        try:
            # Convert to relative path for checking
            try:
                rel_path = file_path.relative_to(self.project_path)
            except ValueError:
                if self.debug:
                    print(f"Debug: Skipping file outside project path: {file_path}")
                return False

            # Check for excluded directories in the path
            if any(part in excluded_dirs for part in file_path.parts):
                if self.debug:
                    print(f"Debug: Skipping excluded directory: {file_path}")
                return False

            # Check if file extension is in whitelist
            if file_path.suffix.lower() not in SOURCE_EXTENSIONS:
                if self.debug:
                    print(f"Debug: Skipping non-source file: {file_path}")
                return False

            # Check custom ignore patterns
            for pattern in IGNORE_PATTERNS:
                if fnmatch.fnmatch(str(rel_path), pattern):
                    if self.debug:
                        print(f"Debug: Skipping ignored pattern {pattern}: {file_path}")
                    return False

            # Check .gitignore if available
            if self.gitignore_matcher:
                try:
                    should_include = not self.gitignore_matcher(str(file_path))
                    if self.debug and not should_include:
                        print(f"Debug: Skipping gitignored file: {file_path}")
                    return should_include
                except Exception as e:
                    print(f"Warning: gitignore matching failed for {file_path}: {e}")
                    return True

            if self.debug:
                print(f"Debug: Including file: {file_path}")
            return True

        except Exception as e:
            print(f"Warning: Error checking file {file_path}: {e}")
            return False

    def _get_file_content(self, file_path: Path) -> str:
        """Read file content with proper encoding handling"""
        try:
            # Try UTF-8 first
            with open(file_path, 'r', encoding='utf-8') as f:
                return f.read()
        except UnicodeDecodeError:
            try:
                # Fallback to latin-1
                with open(file_path, 'r', encoding='latin-1') as f:
                    return f.read()
            except Exception as e:
                print(f"Warning: Failed to read {file_path}: {e}")
                return f"ERROR: Could not read file {file_path}\n"

    def _generate_directory_structure(self) -> str:
        """Generate a tree-like directory structure"""
        structure = ["Directory Structure:", ""]

        def add_to_tree(path: Path, prefix: str = ""):
            # Skip excluded directories
            excluded_dirs = {
                '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
                '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
                'dist', 'build', 'target'
            }
            if path.name in excluded_dirs:
                return

            # Add files first
            files = sorted([p for p in path.iterdir() if p.is_file()])
            included_files = [f for f in files if self._should_include_file(f)]

            for idx, file in enumerate(included_files):
                is_last = idx == len(included_files) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {file.name}")

            # Then add directories
            dirs = sorted([p for p in path.iterdir() if p.is_dir()])
            included_dirs = [d for d in dirs if d.name not in excluded_dirs]

            for idx, dir in enumerate(included_dirs):
                is_last = idx == len(included_dirs) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {dir.name}/")
                add_to_tree(dir, prefix + ("    " if is_last else "│   "))

        add_to_tree(self.project_path)
        return "\n".join(structure)

    def concatenate(self, debug: bool = False):
        """Main method to concatenate all source files"""
        self.debug = debug
        if not self.project_path.exists():
            print(f"Error: Project path {self.project_path} does not exist")
            return False

        try:
            with open(self.output_file, 'w', encoding='utf-8') as out:
                # Write header
                header = f"""
# Project Source Code Concatenation
# Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
# Project path: {self.project_path}

"""
                out.write(header)

                # Write directory structure
                out.write(self._generate_directory_structure())
                out.write("\n\n" + "="*80 + "\n\n")

                # Process all files
                file_count = 0
                for file_path in self.project_path.rglob('*'):
                    if file_path.is_file() and self._should_include_file(file_path):
                        rel_path = file_path.relative_to(self.project_path)

                        # Write file header
                        out.write(f"\n\n# File: {rel_path}\n")
                        out.write("="*80 + "\n\n")

                        # Write file content
                        content = self._get_file_content(file_path)
                        out.write(content)
                        file_count += 1

                print(f"Successfully concatenated {file_count} files to {self.output_file}")
                return True

        except Exception as e:
            print(f"Error during concatenation: {e}")
            return False

def main():
    parser = argparse.ArgumentParser(
        description="Concatenate git project source code into a single file"
    )
    parser.add_argument(
        "project_path",
        help="Path to the git project directory"
    )
    parser.add_argument(
        "-o", "--output",
        default="concatenated_source.txt",
        help="Output file path (default: concatenated_source.txt)"
    )
    parser.add_argument(
        "-d", "--debug",
        action="store_true",
        help="Enable debug logging"
    )

    args = parser.parse_args()

    concatenator = GitConcatenator(args.project_path, args.output)
    success = concatenator.concatenate(debug=args.debug)
    sys.exit(0 if success else 1)

if __name__ == "__main__":
    main()

# File: README.md
================================================================================

git clone https://github.com/yourusername/git-concatenator.git
   cd git-concatenator
   ```

2. Ensure you have Python 3.11 or later installed:
   ```bash
   python --version
   ```

3. Install the required dependency:
   ```bash
   pip install gitignore-parser
   ```

## Usage

Basic usage:
```bash
python git_concatenator.py /path/to/project -o output.txt
```

With debug logging:
```bash
python git_concatenator.py /path/to/project -o output.txt --debug
```

### Command-line Arguments

- `project_path`: Path to the Git project directory (required)
- `-o, --output`: Output file path (default: concatenated_source.txt)
- `-d, --debug`: Enable debug logging

## Output Format

The generated file includes:
1. A timestamp and project path header
2. A visual directory structure of the project
3. The contents of each source file, clearly separated with headers

Example output:
```
# Project Source Code Concatenation
# Generated on: 2025-02-15 20:53:29
# Project path: /path/to/project

Directory Structure:
├── src/
│   ├── main.py
│   └── utils.py
└── README.md

================================================================================

# File: src/main.py
================================================================================
[File contents here]

# File: src/utils.py
================================================================================
[File contents here]

# File: output.txt
================================================================================


# Project Source Code Concatenation
# Generated on: 2025-02-15 22:44:33
# Project path: /home/runner/workspace

Directory Structure:

├── README.md
├── codesmelt.py
├── concatenated_source.txt
├── extensions.py
├── output.txt
└── pyproject.toml

================================================================================



# File: extensions.py
================================================================================

"""
Source code file extension configurations
"""

# Common source code file extensions
SOURCE_EXTENSIONS = {
    # Web
    '.js', '.ts', '.jsx', '.tsx', '.vue', '.svelte',
    '.html', '.htm', '.css', '.scss', '.sass', '.less',
    
    # Python
    '.py', '.pyi', '.pyx',
    
    # Java/Kotlin
    '.java', '.kt', '.groovy',
    
    # C-family
    '.c', '.cpp', '.h', '.hpp', '.cc',
    
    # C#
    '.cs', '.cshtml', '.csx',
    
    # Ruby
    '.rb', '.erb',
    
    # PHP
    '.php', '.php5', '.phtml',
    
    # Go
    '.go',
    
    # Rust
    '.rs',
    
    # Swift
    '.swift',
    
    # Shell
    '.sh', '.bash', '.zsh',
    
    # Config/Data
    '.json', '.yaml', '.yml', '.toml', '.xml',
    '.conf', '.ini', '.env',
    
    # Documentation
    '.md', '.rst', '.txt'
}

# Files to always ignore
IGNORE_PATTERNS = {
    # Build outputs
    'build/*', 'dist/*', 'target/*', 'bin/*',
    '*.pyc', '__pycache__/*', '*.class',
    
    # Dependencies
    'node_modules/*', 'vendor/*', 'venv/*',
    
    # IDE files
    '.idea/*', '.vscode/*', '*.swp',
    
    # Package files
    'package-lock.json', 'yarn.lock',
    'Pipfile.lock', 'poetry.lock',
    
    # Large data files
    '*.csv', '*.json.gz', '*.sql',
    
    # Binary/Media files
    '*.pdf', '*.jpg', '*.png', '*.gif',
    '*.mp3', '*.mp4', '*.mov', '*.bin',
    '*.exe', '*.dll', '*.so', '*.dylib'
}


# File: pyproject.toml
================================================================================

[project]
name = "repl-nix-workspace"
version = "0.1.0"
description = "Add your description here"
requires-python = ">=3.11"
dependencies = [
    "gitignore-parser>=0.1.11",
]


# File: concatenated_source.txt
================================================================================


# Project Source Code Concatenation
# Generated on: 2025-02-15 21:22:24
# Project path: /home/runner/workspace

Directory Structure:

├── README.md
├── concatenated_source.txt
├── extensions.py
├── git_concatenator.py
└── pyproject.toml

================================================================================



# File: extensions.py
================================================================================

"""
Source code file extension configurations
"""

# Common source code file extensions
SOURCE_EXTENSIONS = {
    # Web
    '.js', '.ts', '.jsx', '.tsx', '.vue', '.svelte',
    '.html', '.htm', '.css', '.scss', '.sass', '.less',
    
    # Python
    '.py', '.pyi', '.pyx',
    
    # Java/Kotlin
    '.java', '.kt', '.groovy',
    
    # C-family
    '.c', '.cpp', '.h', '.hpp', '.cc',
    
    # C#
    '.cs', '.cshtml', '.csx',
    
    # Ruby
    '.rb', '.erb',
    
    # PHP
    '.php', '.php5', '.phtml',
    
    # Go
    '.go',
    
    # Rust
    '.rs',
    
    # Swift
    '.swift',
    
    # Shell
    '.sh', '.bash', '.zsh',
    
    # Config/Data
    '.json', '.yaml', '.yml', '.toml', '.xml',
    '.conf', '.ini', '.env',
    
    # Documentation
    '.md', '.rst', '.txt'
}

# Files to always ignore
IGNORE_PATTERNS = {
    # Build outputs
    'build/*', 'dist/*', 'target/*', 'bin/*',
    '*.pyc', '__pycache__/*', '*.class',
    
    # Dependencies
    'node_modules/*', 'vendor/*', 'venv/*',
    
    # IDE files
    '.idea/*', '.vscode/*', '*.swp',
    
    # Package files
    'package-lock.json', 'yarn.lock',
    'Pipfile.lock', 'poetry.lock',
    
    # Large data files
    '*.csv', '*.json.gz', '*.sql',
    
    # Binary/Media files
    '*.pdf', '*.jpg', '*.png', '*.gif',
    '*.mp3', '*.mp4', '*.mov', '*.bin',
    '*.exe', '*.dll', '*.so', '*.dylib'
}


# File: pyproject.toml
================================================================================

[project]
name = "repl-nix-workspace"
version = "0.1.0"
description = "Add your description here"
requires-python = ">=3.11"
dependencies = [
    "gitignore-parser>=0.1.11",
]


# File: concatenated_source.txt
================================================================================



# File: git_concatenator.py
================================================================================

#!/usr/bin/env python3
"""
Git Project Source Code Concatenator

This tool concatenates source code files from a git project into a single file,
including directory structure information.
"""

import argparse
import sys
from pathlib import Path
import os
from typing import Set, List, Optional
import fnmatch
from datetime import datetime
import gitignore_parser
from extensions import SOURCE_EXTENSIONS, IGNORE_PATTERNS

class GitConcatenator:
    def __init__(self, project_path: str, output_file: str):
        self.project_path = Path(project_path).resolve()
        self.output_file = Path(output_file)
        self.gitignore_matcher = self._setup_gitignore()
        self.debug = False

    def _setup_gitignore(self) -> Optional[callable]:
        """Setup gitignore matcher if .gitignore exists"""
        gitignore_path = self.project_path / '.gitignore'
        if gitignore_path.exists():
            try:
                return gitignore_parser.parse_gitignore(gitignore_path)
            except Exception as e:
                print(f"Warning: Failed to parse .gitignore: {e}")
        return None

    def _should_include_file(self, file_path: Path) -> bool:
        """Check if file should be included based on extension and ignore rules"""
        # Skip common virtual environment and system directories
        excluded_dirs = {
            '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
            '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
            'dist', 'build', 'target'
        }

        try:
            # Convert to relative path for checking
            try:
                rel_path = file_path.relative_to(self.project_path)
            except ValueError:
                if self.debug:
                    print(f"Debug: Skipping file outside project path: {file_path}")
                return False

            # Check for excluded directories in the path
            if any(part in excluded_dirs for part in file_path.parts):
                if self.debug:
                    print(f"Debug: Skipping excluded directory: {file_path}")
                return False

            # Check if file extension is in whitelist
            if file_path.suffix.lower() not in SOURCE_EXTENSIONS:
                if self.debug:
                    print(f"Debug: Skipping non-source file: {file_path}")
                return False

            # Check custom ignore patterns
            for pattern in IGNORE_PATTERNS:
                if fnmatch.fnmatch(str(rel_path), pattern):
                    if self.debug:
                        print(f"Debug: Skipping ignored pattern {pattern}: {file_path}")
                    return False

            # Check .gitignore if available
            if self.gitignore_matcher:
                try:
                    should_include = not self.gitignore_matcher(str(file_path))
                    if self.debug and not should_include:
                        print(f"Debug: Skipping gitignored file: {file_path}")
                    return should_include
                except Exception as e:
                    print(f"Warning: gitignore matching failed for {file_path}: {e}")
                    return True

            if self.debug:
                print(f"Debug: Including file: {file_path}")
            return True

        except Exception as e:
            print(f"Warning: Error checking file {file_path}: {e}")
            return False

    def _get_file_content(self, file_path: Path) -> str:
        """Read file content with proper encoding handling"""
        try:
            # Try UTF-8 first
            with open(file_path, 'r', encoding='utf-8') as f:
                return f.read()
        except UnicodeDecodeError:
            try:
                # Fallback to latin-1
                with open(file_path, 'r', encoding='latin-1') as f:
                    return f.read()
            except Exception as e:
                print(f"Warning: Failed to read {file_path}: {e}")
                return f"ERROR: Could not read file {file_path}\n"

    def _generate_directory_structure(self) -> str:
        """Generate a tree-like directory structure"""
        structure = ["Directory Structure:", ""]

        def add_to_tree(path: Path, prefix: str = ""):
            # Skip excluded directories
            excluded_dirs = {
                '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
                '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
                'dist', 'build', 'target'
            }
            if path.name in excluded_dirs:
                return

            # Add files first
            files = sorted([p for p in path.iterdir() if p.is_file()])
            included_files = [f for f in files if self._should_include_file(f)]

            for idx, file in enumerate(included_files):
                is_last = idx == len(included_files) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {file.name}")

            # Then add directories
            dirs = sorted([p for p in path.iterdir() if p.is_dir()])
            included_dirs = [d for d in dirs if d.name not in excluded_dirs]

            for idx, dir in enumerate(included_dirs):
                is_last = idx == len(included_dirs) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {dir.name}/")
                add_to_tree(dir, prefix + ("    " if is_last else "│   "))

        add_to_tree(self.project_path)
        return "\n".join(structure)

    def concatenate(self, debug: bool = False):
        """Main method to concatenate all source files"""
        self.debug = debug
        if not self.project_path.exists():
            print(f"Error: Project path {self.project_path} does not exist")
            return False

        try:
            with open(self.output_file, 'w', encoding='utf-8') as out:
                # Write header
                header = f"""
# Project Source Code Concatenation
# Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
# Project path: {self.project_path}

"""
                out.write(header)

                # Write directory structure
                out.write(self._generate_directory_structure())
                out.write("\n\n" + "="*80 + "\n\n")

                # Process all files
                file_count = 0
                for file_path in self.project_path.rglob('*'):
                    if file_path.is_file() and self._should_include_file(file_path):
                        rel_path = file_path.relative_to(self.project_path)

                        # Write file header
                        out.write(f"\n\n# File: {rel_path}\n")
                        out.write("="*80 + "\n\n")

                        # Write file content
                        content = self._get_file_content(file_path)
                        out.write(content)
                        file_count += 1

                print(f"Successfully concatenated {file_count} files to {self.output_file}")
                return True

        except Exception as e:
            print(f"Error during concatenation: {e}")
            return False

def main():
    parser = argparse.ArgumentParser(
        description="Concatenate git project source code into a single file"
    )
    parser.add_argument(
        "project_path",
        help="Path to the git project directory"
    )
    parser.add_argument(
        "-o", "--output",
        default="concatenated_source.txt",
        help="Output file path (default: concatenated_source.txt)"
    )
    parser.add_argument(
        "-d", "--debug",
        action="store_true",
        help="Enable debug logging"
    )

    args = parser.parse_args()

    concatenator = GitConcatenator(args.project_path, args.output)
    success = concatenator.concatenate(debug=args.debug)
    sys.exit(0 if success else 1)

if __name__ == "__main__":
    main()

# File: README.md
================================================================================

git clone https://github.com/yourusername/git-concatenator.git
   cd git-concatenator
   ```

2. Ensure you have Python 3.11 or later installed:
   ```bash
   python --version
   ```

3. Install the required dependency:
   ```bash
   pip install gitignore-parser
   ```

## Usage

Basic usage:
```bash
python git_concatenator.py /path/to/project -o output.txt
```

With debug logging:
```bash
python git_concatenator.py /path/to/project -o output.txt --debug
```

### Command-line Arguments

- `project_path`: Path to the Git project directory (required)
- `-o, --output`: Output file path (default: concatenated_source.txt)
- `-d, --debug`: Enable debug logging

## Output Format

The generated file includes:
1. A timestamp and project path header
2. A visual directory structure of the project
3. The contents of each source file, clearly separated with headers

Example output:
```
# Project Source Code Concatenation
# Generated on: 2025-02-15 20:53:29
# Project path: /path/to/project

Directory Structure:
├── src/
│   ├── main.py
│   └── utils.py
└── README.md

================================================================================

# File: src/main.py
================================================================================
[File contents here]

# File: src/utils.py
================================================================================
[File contents here]

# File: codesmelt.py
================================================================================

#!/usr/bin/env python3
"""
CodeSmelt: Source Code Concatenator

This tool melts down source code files from a git project into a single file,
including directory structure information.
"""

import argparse
import sys
from pathlib import Path
import os
from typing import Set, List, Optional
import fnmatch
from datetime import datetime
import gitignore_parser
from extensions import SOURCE_EXTENSIONS, IGNORE_PATTERNS

class CodeSmelt:
    def __init__(self, project_path: str, output_file: str):
        self.project_path = Path(project_path).resolve()
        self.output_file = Path(output_file)
        self.gitignore_matcher = self._setup_gitignore()
        self.debug = False

    def _setup_gitignore(self) -> Optional[callable]:
        """Setup gitignore matcher if .gitignore exists"""
        gitignore_path = self.project_path / '.gitignore'
        if gitignore_path.exists():
            try:
                return gitignore_parser.parse_gitignore(gitignore_path)
            except Exception as e:
                print(f"Warning: Failed to parse .gitignore: {e}")
        return None

    def _should_include_file(self, file_path: Path) -> bool:
        """Check if file should be included based on extension and ignore rules"""
        # Skip common virtual environment and system directories
        excluded_dirs = {
            '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
            '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
            'dist', 'build', 'target'
        }

        try:
            # Convert to relative path for checking
            try:
                rel_path = file_path.relative_to(self.project_path)
            except ValueError:
                if self.debug:
                    print(f"Debug: Skipping file outside project path: {file_path}")
                return False

            # Check for excluded directories in the path
            if any(part in excluded_dirs for part in file_path.parts):
                if self.debug:
                    print(f"Debug: Skipping excluded directory: {file_path}")
                return False

            # Check if file extension is in whitelist
            if file_path.suffix.lower() not in SOURCE_EXTENSIONS:
                if self.debug:
                    print(f"Debug: Skipping non-source file: {file_path}")
                return False

            # Check custom ignore patterns
            for pattern in IGNORE_PATTERNS:
                if fnmatch.fnmatch(str(rel_path), pattern):
                    if self.debug:
                        print(f"Debug: Skipping ignored pattern {pattern}: {file_path}")
                    return False

            # Check .gitignore if available
            if self.gitignore_matcher:
                try:
                    should_include = not self.gitignore_matcher(str(file_path))
                    if self.debug and not should_include:
                        print(f"Debug: Skipping gitignored file: {file_path}")
                    return should_include
                except Exception as e:
                    print(f"Warning: gitignore matching failed for {file_path}: {e}")
                    return True

            if self.debug:
                print(f"Debug: Including file: {file_path}")
            return True

        except Exception as e:
            print(f"Warning: Error checking file {file_path}: {e}")
            return False

    def _get_file_content(self, file_path: Path) -> str:
        """Read file content with proper encoding handling"""
        try:
            # Try UTF-8 first
            with open(file_path, 'r', encoding='utf-8') as f:
                return f.read()
        except UnicodeDecodeError:
            try:
                # Fallback to latin-1
                with open(file_path, 'r', encoding='latin-1') as f:
                    return f.read()
            except Exception as e:
                print(f"Warning: Failed to read {file_path}: {e}")
                return f"ERROR: Could not read file {file_path}\n"

    def _generate_directory_structure(self) -> str:
        """Generate a tree-like directory structure"""
        structure = ["Directory Structure:", ""]

        def add_to_tree(path: Path, prefix: str = ""):
            # Skip excluded directories
            excluded_dirs = {
                '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
                '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
                'dist', 'build', 'target'
            }
            if path.name in excluded_dirs:
                return

            # Add files first
            files = sorted([p for p in path.iterdir() if p.is_file()])
            included_files = [f for f in files if self._should_include_file(f)]

            for idx, file in enumerate(included_files):
                is_last = idx == len(included_files) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {file.name}")

            # Then add directories
            dirs = sorted([p for p in path.iterdir() if p.is_dir()])
            included_dirs = [d for d in dirs if d.name not in excluded_dirs]

            for idx, dir in enumerate(included_dirs):
                is_last = idx == len(included_dirs) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {dir.name}/")
                add_to_tree(dir, prefix + ("    " if is_last else "│   "))

        add_to_tree(self.project_path)
        return "\n".join(structure)

    def concatenate(self, debug: bool = False):
        """Main method to concatenate all source files"""
        self.debug = debug
        if not self.project_path.exists():
            print(f"Error: Project path {self.project_path} does not exist")
            return False

        try:
            with open(self.output_file, 'w', encoding='utf-8') as out:
                # Write header
                header = f"""
# Project Source Code Concatenation
# Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
# Project path: {self.project_path}

"""
                out.write(header)

                # Write directory structure
                out.write(self._generate_directory_structure())
                out.write("\n\n" + "="*80 + "\n\n")

                # Process all files
                file_count = 0
                for file_path in self.project_path.rglob('*'):
                    if file_path.is_file() and self._should_include_file(file_path):
                        rel_path = file_path.relative_to(self.project_path)

                        # Write file header
                        out.write(f"\n\n# File: {rel_path}\n")
                        out.write("="*80 + "\n\n")

                        # Write file content
                        content = self._get_file_content(file_path)
                        out.write(content)
                        file_count += 1

                print(f"Successfully melted {file_count} files to {self.output_file}")
                return True

        except Exception as e:
            print(f"Error during melting: {e}")
            return False

def main():
    parser = argparse.ArgumentParser(
        description="CodeSmelt: Melt down your git project's source code into a single file"
    )
    parser.add_argument(
        "project_path",
        help="Path to the git project directory"
    )
    parser.add_argument(
        "-o", "--output",
        default="concatenated_source.txt",
        help="Output file path (default: concatenated_source.txt)"
    )
    parser.add_argument(
        "-d", "--debug",
        action="store_true",
        help="Enable debug logging"
    )

    args = parser.parse_args()

    concatenator = CodeSmelt(args.project_path, args.output)
    success = concatenator.concatenate(debug=args.debug)
    sys.exit(0 if success else 1)

if __name__ == "__main__":
    main()

# File: README.md
================================================================================

python --version
   ```

2. Install the required dependency:
   ```bash
   pip install gitignore-parser
   ```

## Usage

Basic usage:
```bash
python codesmelt.py /path/to/project -o output.txt
```

With debug logging:
```bash
python codesmelt.py /path/to/project -o output.txt --debug
```

### Command-line Arguments

- `project_path`: Path to the Git project directory (required)
- `-o, --output`: Output file path (default: concatenated_source.txt)
- `-d, --debug`: Enable debug logging

## Configuration

### Source File Extensions
The tool includes common source code file extensions by default (defined in `extensions.py`):
- Web: `.js`, `.ts`, `.jsx`, `.tsx`, `.vue`, `.svelte`, `.html`, `.css`, etc.
- Python: `.py`, `.pyi`, `.pyx`
- Java/Kotlin: `.java`, `.kt`, `.groovy`
- C-family: `.c`, `.cpp`, `.h`, `.hpp`
- And many more...

#### Customizing File Extensions
You can modify which file extensions are included by editing the `SOURCE_EXTENSIONS` set in `extensions.py`. For example, to include Unity3D script files while excluding other Unity files:

```python
SOURCE_EXTENSIONS = {
    # ... existing extensions ...

    # Unity3D specific
    '.cs',  # C# scripts
    '.shader', # Custom shaders
    '.asmdef', # Assembly definitions

    # ... other extensions ...
}
```

### Ignore Patterns
The tool automatically ignores files based on three levels:

1. Built-in patterns (`IGNORE_PATTERNS` in `extensions.py`):
   - Build outputs (`build/*`, `dist/*`, `*.pyc`, etc.)
   - Dependencies (`node_modules/*`, `vendor/*`, `venv/*`)
   - IDE files (`.idea/*`, `.vscode/*`)
   - Package lock files (`package-lock.json`, `poetry.lock`, etc.)
   - Binary and media files (`*.pdf`, `*.jpg`, `*.exe`, etc.)

2. Project's `.gitignore` rules (if present)
3. Directory-specific `.gitignore` rules

#### Customizing Ignore Patterns
To modify which files are ignored, you can:

1. Edit `IGNORE_PATTERNS` in `extensions.py`:
```python
IGNORE_PATTERNS = {
    # ... existing patterns ...

    # Unity3D specific ignores
    'Assets/AssetStoreTools/*',
    'Library/*',
    'Temp/*',
    'Logs/*',
    '*.unity',  # Unity scene files
    '*.meta',   # Unity meta files
    '*.prefab', # Unity prefab files

    # ... other patterns ...
}
```

2. Use your project's `.gitignore` file for project-specific exclusions

**Note**: Ignore patterns follow the same syntax as `.gitignore` files. The tool processes these rules in order:
1. Built-in `IGNORE_PATTERNS`
2. Project's root `.gitignore`
3. Directory-specific `.gitignore` files


## Tips for Using with LLMs

1. **Token Management**:
   - For large projects, consider concatenating only specific directories
   - Use the debug mode to see which files are included/excluded
   - Remove unnecessary documentation files if you're close to token limits

2. **Effective Prompting**:
   - Reference files using their relative paths as shown in the directory structure
   - Use the directory structure to ask about specific components
   - Refer to file relationships based on the visual structure

3. **Best Practices**:
   - Review the concatenated output before sending to ensure relevance
   - For large projects, break down analysis into smaller, focused components
   - Use the debug mode to verify file selection when customizing

## Output Format

The generated file includes:
1. A timestamp and project path header
2. A visual directory structure of the project
3. The contents of each source file, clearly separated with headers

Example output:
```
# Project Source Code Concatenation
# Generated on: 2025-02-15 20:53:29
# Project path: /path/to/project

Directory Structure:
├── src/
│   ├── main.py
│   └── utils.py
└── README.md

================================================================================

# File: src/main.py
================================================================================
[File contents here]

# File: src/utils.py
================================================================================
[File contents here]
```

## Troubleshooting

### Common Issues

1. **No Files Found**:
   - Verify the project path is correct
   - Check if files have supported extensions
   - Run with --debug to see which files are being filtered

2. **Missing Dependencies**:
   ```bash
   pip install --upgrade gitignore-parser

# File: codesmelt.py
================================================================================

#!/usr/bin/env python3
"""
CodeSmelt: Source Code Concatenator

This tool melts down source code files from a git project into a single file,
including directory structure information.
"""

import argparse
import sys
from pathlib import Path
import os
from typing import Set, List, Optional
import fnmatch
from datetime import datetime
import gitignore_parser
from extensions import SOURCE_EXTENSIONS, IGNORE_PATTERNS

class CodeSmelt:
    def __init__(self, project_path: str, output_file: str):
        self.project_path = Path(project_path).resolve()
        self.output_file = Path(output_file)
        self.gitignore_matcher = self._setup_gitignore()
        self.debug = False

    def _setup_gitignore(self) -> Optional[callable]:
        """Setup gitignore matcher if .gitignore exists"""
        gitignore_path = self.project_path / '.gitignore'
        if gitignore_path.exists():
            try:
                return gitignore_parser.parse_gitignore(gitignore_path)
            except Exception as e:
                print(f"Warning: Failed to parse .gitignore: {e}")
        return None

    def _should_include_file(self, file_path: Path) -> bool:
        """Check if file should be included based on extension and ignore rules"""
        # Skip common virtual environment and system directories
        excluded_dirs = {
            '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
            '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
            'dist', 'build', 'target'
        }

        try:
            # Convert to relative path for checking
            try:
                rel_path = file_path.relative_to(self.project_path)
            except ValueError:
                if self.debug:
                    print(f"Debug: Skipping file outside project path: {file_path}")
                return False

            # Check for excluded directories in the path
            if any(part in excluded_dirs for part in file_path.parts):
                if self.debug:
                    print(f"Debug: Skipping excluded directory: {file_path}")
                return False

            # Check if file extension is in whitelist
            if file_path.suffix.lower() not in SOURCE_EXTENSIONS:
                if self.debug:
                    print(f"Debug: Skipping non-source file: {file_path}")
                return False

            # Check custom ignore patterns
            for pattern in IGNORE_PATTERNS:
                if fnmatch.fnmatch(str(rel_path), pattern):
                    if self.debug:
                        print(f"Debug: Skipping ignored pattern {pattern}: {file_path}")
                    return False

            # Check .gitignore if available
            if self.gitignore_matcher:
                try:
                    should_include = not self.gitignore_matcher(str(file_path))
                    if self.debug and not should_include:
                        print(f"Debug: Skipping gitignored file: {file_path}")
                    return should_include
                except Exception as e:
                    print(f"Warning: gitignore matching failed for {file_path}: {e}")
                    return True

            if self.debug:
                print(f"Debug: Including file: {file_path}")
            return True

        except Exception as e:
            print(f"Warning: Error checking file {file_path}: {e}")
            return False

    def _get_file_content(self, file_path: Path) -> str:
        """Read file content with proper encoding handling"""
        try:
            # Try UTF-8 first
            with open(file_path, 'r', encoding='utf-8') as f:
                return f.read()
        except UnicodeDecodeError:
            try:
                # Fallback to latin-1
                with open(file_path, 'r', encoding='latin-1') as f:
                    return f.read()
            except Exception as e:
                print(f"Warning: Failed to read {file_path}: {e}")
                return f"ERROR: Could not read file {file_path}\n"

    def _generate_directory_structure(self) -> str:
        """Generate a tree-like directory structure"""
        structure = ["Directory Structure:", ""]

        def add_to_tree(path: Path, prefix: str = ""):
            # Skip excluded directories
            excluded_dirs = {
                '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
                '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
                'dist', 'build', 'target'
            }
            if path.name in excluded_dirs:
                return

            # Add files first
            files = sorted([p for p in path.iterdir() if p.is_file()])
            included_files = [f for f in files if self._should_include_file(f)]

            for idx, file in enumerate(included_files):
                is_last = idx == len(included_files) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {file.name}")

            # Then add directories
            dirs = sorted([p for p in path.iterdir() if p.is_dir()])
            included_dirs = [d for d in dirs if d.name not in excluded_dirs]

            for idx, dir in enumerate(included_dirs):
                is_last = idx == len(included_dirs) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {dir.name}/")
                add_to_tree(dir, prefix + ("    " if is_last else "│   "))

        add_to_tree(self.project_path)
        return "\n".join(structure)

    def concatenate(self, debug: bool = False):
        """Main method to concatenate all source files"""
        self.debug = debug
        if not self.project_path.exists():
            print(f"Error: Project path {self.project_path} does not exist")
            return False

        try:
            with open(self.output_file, 'w', encoding='utf-8') as out:
                # Write header
                header = f"""
# Project Source Code Concatenation
# Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
# Project path: {self.project_path}

"""
                out.write(header)

                # Write directory structure
                out.write(self._generate_directory_structure())
                out.write("\n\n" + "="*80 + "\n\n")

                # Process all files
                file_count = 0
                for file_path in self.project_path.rglob('*'):
                    if file_path.is_file() and self._should_include_file(file_path):
                        rel_path = file_path.relative_to(self.project_path)

                        # Write file header
                        out.write(f"\n\n# File: {rel_path}\n")
                        out.write("="*80 + "\n\n")

                        # Write file content
                        content = self._get_file_content(file_path)
                        out.write(content)
                        file_count += 1

                print(f"Successfully melted {file_count} files to {self.output_file}")
                return True

        except Exception as e:
            print(f"Error during melting: {e}")
            return False

def main():
    parser = argparse.ArgumentParser(
        description="CodeSmelt: Melt down your git project's source code into a single file",
        usage="%(prog)s [-o OUTPUT] [-d] project_path"
    )
    parser.add_argument(
        "-o", "--output",
        default="concatenated_source.txt",
        help="Output file path (default: concatenated_source.txt)"
    )
    parser.add_argument(
        "-d", "--debug",
        action="store_true",
        help="Enable debug logging"
    )
    parser.add_argument(
        "project_path",
        help="Path to the git project directory",
        nargs="?"  # Make it optional in the parser (though we'll check it's provided)
    )

    args = parser.parse_args()

    if not args.project_path:
        parser.error("project_path is required")

    concatenator = CodeSmelt(args.project_path, args.output)
    success = concatenator.concatenate(debug=args.debug)
    sys.exit(0 if success else 1)

if __name__ == "__main__":
    main()

# File: README.md
================================================================================

python codesmelt.py /path/to/project
```

Specify custom output file:
```bash
python codesmelt.py -o output.txt /path/to/project
```

With debug logging:
```bash
python codesmelt.py -d -o output.txt /path/to/project
```

### Command-line Arguments
- `project_path`: Path to the Git project directory (required)
- `-o, --output`: Output file path (default: concatenated_source.txt)
- `-d, --debug`: Enable debug logging

## Configuration

### Source File Extensions
The tool includes common source code file extensions by default (defined in `extensions.py`):
- Web: `.js`, `.ts`, `.jsx`, `.tsx`, `.vue`, `.svelte`, `.html`, `.css`, etc.
- Python: `.py`, `.pyi`, `.pyx`
- Java/Kotlin: `.java`, `.kt`, `.groovy`
- C-family: `.c`, `.cpp`, `.h`, `.hpp`
- And many more...

#### Customizing File Extensions
You can modify which file extensions are included by editing the `SOURCE_EXTENSIONS` set in `extensions.py`. For example, to include Unity3D script files while excluding other Unity files:

```python
SOURCE_EXTENSIONS = {
    # ... existing extensions ...

    # Unity3D specific
    '.cs',  # C# scripts
    '.shader', # Custom shaders
    '.asmdef', # Assembly definitions

    # ... other extensions ...
}
```

### Ignore Patterns
The tool automatically ignores files based on three levels:

1. Built-in patterns (`IGNORE_PATTERNS` in `extensions.py`):
   - Build outputs (`build/*`, `dist/*`, `*.pyc`, etc.)
   - Dependencies (`node_modules/*`, `vendor/*`, `venv/*`)
   - IDE files (`.idea/*`, `.vscode/*`)
   - Package lock files (`package-lock.json`, `poetry.lock`, etc.)
   - Binary and media files (`*.pdf`, `*.jpg`, `*.exe`, etc.)

2. Project's `.gitignore` rules (if present)
3. Directory-specific `.gitignore` rules

#### Customizing Ignore Patterns
To modify which files are ignored, you can:

1. Edit `IGNORE_PATTERNS` in `extensions.py`:
```python
IGNORE_PATTERNS = {
    # ... existing patterns ...

    # Unity3D specific ignores
    'Assets/AssetStoreTools/*',
    'Library/*',
    'Temp/*',
    'Logs/*',
    '*.unity',  # Unity scene files
    '*.meta',   # Unity meta files
    '*.prefab', # Unity prefab files

    # ... other patterns ...
}
```

2. Use your project's `.gitignore` file for project-specific exclusions

**Note**: Ignore patterns follow the same syntax as `.gitignore` files. The tool processes these rules in order:
1. Built-in `IGNORE_PATTERNS`
2. Project's root `.gitignore`
3. Directory-specific `.gitignore` files


## Tips for Using with LLMs

1. **Token Management**:
   - For large projects, consider concatenating only specific directories
   - Use the debug mode to see which files are included/excluded
   - Remove unnecessary documentation files if you're close to token limits

2. **Effective Prompting**:
   - Reference files using their relative paths as shown in the directory structure
   - Use the directory structure to ask about specific components
   - Refer to file relationships based on the visual structure

3. **Best Practices**:
   - Review the concatenated output before sending to ensure relevance
   - For large projects, break down analysis into smaller, focused components
   - Use the debug mode to verify file selection when customizing

## Output Format

The generated file includes:
1. A timestamp and project path header
2. A visual directory structure of the project
3. The contents of each source file, clearly separated with headers

Example output:
```
# Project Source Code Concatenation
# Generated on: 2025-02-15 20:53:29
# Project path: /path/to/project

Directory Structure:
├── src/
│   ├── main.py
│   └── utils.py
└── README.md

================================================================================

# File: src/main.py
================================================================================
[File contents here]

# File: src/utils.py
================================================================================
[File contents here]
```

## Troubleshooting

### Common Issues

1. **No Files Found**:
   - Verify the project path is correct
   - Check if files have supported extensions
   - Run with --debug to see which files are being filtered

2. **Missing Dependencies**:
   ```bash
   pip install --upgrade gitignore-parser

# File: output.txt
================================================================================


# Project Source Code Concatenation
# Generated on: 2025-02-15 22:44:33
# Project path: /home/runner/workspace

Directory Structure:

├── README.md
├── codesmelt.py
├── concatenated_source.txt
├── extensions.py
├── output.txt
└── pyproject.toml

================================================================================



# File: extensions.py
================================================================================

"""
Source code file extension configurations
"""

# Common source code file extensions
SOURCE_EXTENSIONS = {
    # Web
    '.js', '.ts', '.jsx', '.tsx', '.vue', '.svelte',
    '.html', '.htm', '.css', '.scss', '.sass', '.less',
    
    # Python
    '.py', '.pyi', '.pyx',
    
    # Java/Kotlin
    '.java', '.kt', '.groovy',
    
    # C-family
    '.c', '.cpp', '.h', '.hpp', '.cc',
    
    # C#
    '.cs', '.cshtml', '.csx',
    
    # Ruby
    '.rb', '.erb',
    
    # PHP
    '.php', '.php5', '.phtml',
    
    # Go
    '.go',
    
    # Rust
    '.rs',
    
    # Swift
    '.swift',
    
    # Shell
    '.sh', '.bash', '.zsh',
    
    # Config/Data
    '.json', '.yaml', '.yml', '.toml', '.xml',
    '.conf', '.ini', '.env',
    
    # Documentation
    '.md', '.rst', '.txt'
}

# Files to always ignore
IGNORE_PATTERNS = {
    # Build outputs
    'build/*', 'dist/*', 'target/*', 'bin/*',
    '*.pyc', '__pycache__/*', '*.class',
    
    # Dependencies
    'node_modules/*', 'vendor/*', 'venv/*',
    
    # IDE files
    '.idea/*', '.vscode/*', '*.swp',
    
    # Package files
    'package-lock.json', 'yarn.lock',
    'Pipfile.lock', 'poetry.lock',
    
    # Large data files
    '*.csv', '*.json.gz', '*.sql',
    
    # Binary/Media files
    '*.pdf', '*.jpg', '*.png', '*.gif',
    '*.mp3', '*.mp4', '*.mov', '*.bin',
    '*.exe', '*.dll', '*.so', '*.dylib'
}


# File: pyproject.toml
================================================================================

[project]
name = "repl-nix-workspace"
version = "0.1.0"
description = "Add your description here"
requires-python = ">=3.11"
dependencies = [
    "gitignore-parser>=0.1.11",
]


# File: concatenated_source.txt
================================================================================


# Project Source Code Concatenation
# Generated on: 2025-02-15 21:22:24
# Project path: /home/runner/workspace

Directory Structure:

├── README.md
├── concatenated_source.txt
├── extensions.py
├── git_concatenator.py
└── pyproject.toml

================================================================================



# File: extensions.py
================================================================================

"""
Source code file extension configurations
"""

# Common source code file extensions
SOURCE_EXTENSIONS = {
    # Web
    '.js', '.ts', '.jsx', '.tsx', '.vue', '.svelte',
    '.html', '.htm', '.css', '.scss', '.sass', '.less',
    
    # Python
    '.py', '.pyi', '.pyx',
    
    # Java/Kotlin
    '.java', '.kt', '.groovy',
    
    # C-family
    '.c', '.cpp', '.h', '.hpp', '.cc',
    
    # C#
    '.cs', '.cshtml', '.csx',
    
    # Ruby
    '.rb', '.erb',
    
    # PHP
    '.php', '.php5', '.phtml',
    
    # Go
    '.go',
    
    # Rust
    '.rs',
    
    # Swift
    '.swift',
    
    # Shell
    '.sh', '.bash', '.zsh',
    
    # Config/Data
    '.json', '.yaml', '.yml', '.toml', '.xml',
    '.conf', '.ini', '.env',
    
    # Documentation
    '.md', '.rst', '.txt'
}

# Files to always ignore
IGNORE_PATTERNS = {
    # Build outputs
    'build/*', 'dist/*', 'target/*', 'bin/*',
    '*.pyc', '__pycache__/*', '*.class',
    
    # Dependencies
    'node_modules/*', 'vendor/*', 'venv/*',
    
    # IDE files
    '.idea/*', '.vscode/*', '*.swp',
    
    # Package files
    'package-lock.json', 'yarn.lock',
    'Pipfile.lock', 'poetry.lock',
    
    # Large data files
    '*.csv', '*.json.gz', '*.sql',
    
    # Binary/Media files
    '*.pdf', '*.jpg', '*.png', '*.gif',
    '*.mp3', '*.mp4', '*.mov', '*.bin',
    '*.exe', '*.dll', '*.so', '*.dylib'
}


# File: pyproject.toml
================================================================================

[project]
name = "repl-nix-workspace"
version = "0.1.0"
description = "Add your description here"
requires-python = ">=3.11"
dependencies = [
    "gitignore-parser>=0.1.11",
]


# File: concatenated_source.txt
================================================================================



# File: git_concatenator.py
================================================================================

#!/usr/bin/env python3
"""
Git Project Source Code Concatenator

This tool concatenates source code files from a git project into a single file,
including directory structure information.
"""

import argparse
import sys
from pathlib import Path
import os
from typing import Set, List, Optional
import fnmatch
from datetime import datetime
import gitignore_parser
from extensions import SOURCE_EXTENSIONS, IGNORE_PATTERNS

class GitConcatenator:
    def __init__(self, project_path: str, output_file: str):
        self.project_path = Path(project_path).resolve()
        self.output_file = Path(output_file)
        self.gitignore_matcher = self._setup_gitignore()
        self.debug = False

    def _setup_gitignore(self) -> Optional[callable]:
        """Setup gitignore matcher if .gitignore exists"""
        gitignore_path = self.project_path / '.gitignore'
        if gitignore_path.exists():
            try:
                return gitignore_parser.parse_gitignore(gitignore_path)
            except Exception as e:
                print(f"Warning: Failed to parse .gitignore: {e}")
        return None

    def _should_include_file(self, file_path: Path) -> bool:
        """Check if file should be included based on extension and ignore rules"""
        # Skip common virtual environment and system directories
        excluded_dirs = {
            '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
            '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
            'dist', 'build', 'target'
        }

        try:
            # Convert to relative path for checking
            try:
                rel_path = file_path.relative_to(self.project_path)
            except ValueError:
                if self.debug:
                    print(f"Debug: Skipping file outside project path: {file_path}")
                return False

            # Check for excluded directories in the path
            if any(part in excluded_dirs for part in file_path.parts):
                if self.debug:
                    print(f"Debug: Skipping excluded directory: {file_path}")
                return False

            # Check if file extension is in whitelist
            if file_path.suffix.lower() not in SOURCE_EXTENSIONS:
                if self.debug:
                    print(f"Debug: Skipping non-source file: {file_path}")
                return False

            # Check custom ignore patterns
            for pattern in IGNORE_PATTERNS:
                if fnmatch.fnmatch(str(rel_path), pattern):
                    if self.debug:
                        print(f"Debug: Skipping ignored pattern {pattern}: {file_path}")
                    return False

            # Check .gitignore if available
            if self.gitignore_matcher:
                try:
                    should_include = not self.gitignore_matcher(str(file_path))
                    if self.debug and not should_include:
                        print(f"Debug: Skipping gitignored file: {file_path}")
                    return should_include
                except Exception as e:
                    print(f"Warning: gitignore matching failed for {file_path}: {e}")
                    return True

            if self.debug:
                print(f"Debug: Including file: {file_path}")
            return True

        except Exception as e:
            print(f"Warning: Error checking file {file_path}: {e}")
            return False

    def _get_file_content(self, file_path: Path) -> str:
        """Read file content with proper encoding handling"""
        try:
            # Try UTF-8 first
            with open(file_path, 'r', encoding='utf-8') as f:
                return f.read()
        except UnicodeDecodeError:
            try:
                # Fallback to latin-1
                with open(file_path, 'r', encoding='latin-1') as f:
                    return f.read()
            except Exception as e:
                print(f"Warning: Failed to read {file_path}: {e}")
                return f"ERROR: Could not read file {file_path}\n"

    def _generate_directory_structure(self) -> str:
        """Generate a tree-like directory structure"""
        structure = ["Directory Structure:", ""]

        def add_to_tree(path: Path, prefix: str = ""):
            # Skip excluded directories
            excluded_dirs = {
                '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
                '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
                'dist', 'build', 'target'
            }
            if path.name in excluded_dirs:
                return

            # Add files first
            files = sorted([p for p in path.iterdir() if p.is_file()])
            included_files = [f for f in files if self._should_include_file(f)]

            for idx, file in enumerate(included_files):
                is_last = idx == len(included_files) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {file.name}")

            # Then add directories
            dirs = sorted([p for p in path.iterdir() if p.is_dir()])
            included_dirs = [d for d in dirs if d.name not in excluded_dirs]

            for idx, dir in enumerate(included_dirs):
                is_last = idx == len(included_dirs) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {dir.name}/")
                add_to_tree(dir, prefix + ("    " if is_last else "│   "))

        add_to_tree(self.project_path)
        return "\n".join(structure)

    def concatenate(self, debug: bool = False):
        """Main method to concatenate all source files"""
        self.debug = debug
        if not self.project_path.exists():
            print(f"Error: Project path {self.project_path} does not exist")
            return False

        try:
            with open(self.output_file, 'w', encoding='utf-8') as out:
                # Write header
                header = f"""
# Project Source Code Concatenation
# Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
# Project path: {self.project_path}

"""
                out.write(header)

                # Write directory structure
                out.write(self._generate_directory_structure())
                out.write("\n\n" + "="*80 + "\n\n")

                # Process all files
                file_count = 0
                for file_path in self.project_path.rglob('*'):
                    if file_path.is_file() and self._should_include_file(file_path):
                        rel_path = file_path.relative_to(self.project_path)

                        # Write file header
                        out.write(f"\n\n# File: {rel_path}\n")
                        out.write("="*80 + "\n\n")

                        # Write file content
                        content = self._get_file_content(file_path)
                        out.write(content)
                        file_count += 1

                print(f"Successfully concatenated {file_count} files to {self.output_file}")
                return True

        except Exception as e:
            print(f"Error during concatenation: {e}")
            return False

def main():
    parser = argparse.ArgumentParser(
        description="Concatenate git project source code into a single file"
    )
    parser.add_argument(
        "project_path",
        help="Path to the git project directory"
    )
    parser.add_argument(
        "-o", "--output",
        default="concatenated_source.txt",
        help="Output file path (default: concatenated_source.txt)"
    )
    parser.add_argument(
        "-d", "--debug",
        action="store_true",
        help="Enable debug logging"
    )

    args = parser.parse_args()

    concatenator = GitConcatenator(args.project_path, args.output)
    success = concatenator.concatenate(debug=args.debug)
    sys.exit(0 if success else 1)

if __name__ == "__main__":
    main()

# File: README.md
================================================================================

git clone https://github.com/yourusername/git-concatenator.git
   cd git-concatenator
   ```

2. Ensure you have Python 3.11 or later installed:
   ```bash
   python --version
   ```

3. Install the required dependency:
   ```bash
   pip install gitignore-parser
   ```

## Usage

Basic usage:
```bash
python git_concatenator.py /path/to/project -o output.txt
```

With debug logging:
```bash
python git_concatenator.py /path/to/project -o output.txt --debug
```

### Command-line Arguments

- `project_path`: Path to the Git project directory (required)
- `-o, --output`: Output file path (default: concatenated_source.txt)
- `-d, --debug`: Enable debug logging

## Output Format

The generated file includes:
1. A timestamp and project path header
2. A visual directory structure of the project
3. The contents of each source file, clearly separated with headers

Example output:
```
# Project Source Code Concatenation
# Generated on: 2025-02-15 20:53:29
# Project path: /path/to/project

Directory Structure:
├── src/
│   ├── main.py
│   └── utils.py
└── README.md

================================================================================

# File: src/main.py
================================================================================
[File contents here]

# File: src/utils.py
================================================================================
[File contents here]

# File: output.txt
================================================================================


# Project Source Code Concatenation
# Generated on: 2025-02-15 22:44:33
# Project path: /home/runner/workspace

Directory Structure:

├── README.md
├── codesmelt.py
├── concatenated_source.txt
├── extensions.py
├── output.txt
└── pyproject.toml

================================================================================



# File: extensions.py
================================================================================

"""
Source code file extension configurations
"""

# Common source code file extensions
SOURCE_EXTENSIONS = {
    # Web
    '.js', '.ts', '.jsx', '.tsx', '.vue', '.svelte',
    '.html', '.htm', '.css', '.scss', '.sass', '.less',
    
    # Python
    '.py', '.pyi', '.pyx',
    
    # Java/Kotlin
    '.java', '.kt', '.groovy',
    
    # C-family
    '.c', '.cpp', '.h', '.hpp', '.cc',
    
    # C#
    '.cs', '.cshtml', '.csx',
    
    # Ruby
    '.rb', '.erb',
    
    # PHP
    '.php', '.php5', '.phtml',
    
    # Go
    '.go',
    
    # Rust
    '.rs',
    
    # Swift
    '.swift',
    
    # Shell
    '.sh', '.bash', '.zsh',
    
    # Config/Data
    '.json', '.yaml', '.yml', '.toml', '.xml',
    '.conf', '.ini', '.env',
    
    # Documentation
    '.md', '.rst', '.txt'
}

# Files to always ignore
IGNORE_PATTERNS = {
    # Build outputs
    'build/*', 'dist/*', 'target/*', 'bin/*',
    '*.pyc', '__pycache__/*', '*.class',
    
    # Dependencies
    'node_modules/*', 'vendor/*', 'venv/*',
    
    # IDE files
    '.idea/*', '.vscode/*', '*.swp',
    
    # Package files
    'package-lock.json', 'yarn.lock',
    'Pipfile.lock', 'poetry.lock',
    
    # Large data files
    '*.csv', '*.json.gz', '*.sql',
    
    # Binary/Media files
    '*.pdf', '*.jpg', '*.png', '*.gif',
    '*.mp3', '*.mp4', '*.mov', '*.bin',
    '*.exe', '*.dll', '*.so', '*.dylib'
}


# File: pyproject.toml
================================================================================

[project]
name = "repl-nix-workspace"
version = "0.1.0"
description = "Add your description here"
requires-python = ">=3.11"
dependencies = [
    "gitignore-parser>=0.1.11",
]


# File: concatenated_source.txt
================================================================================


# Project Source Code Concatenation
# Generated on: 2025-02-15 21:22:24
# Project path: /home/runner/workspace

Directory Structure:

├── README.md
├── concatenated_source.txt
├── extensions.py
├── git_concatenator.py
└── pyproject.toml

================================================================================



# File: extensions.py
================================================================================

"""
Source code file extension configurations
"""

# Common source code file extensions
SOURCE_EXTENSIONS = {
    # Web
    '.js', '.ts', '.jsx', '.tsx', '.vue', '.svelte',
    '.html', '.htm', '.css', '.scss', '.sass', '.less',
    
    # Python
    '.py', '.pyi', '.pyx',
    
    # Java/Kotlin
    '.java', '.kt', '.groovy',
    
    # C-family
    '.c', '.cpp', '.h', '.hpp', '.cc',
    
    # C#
    '.cs', '.cshtml', '.csx',
    
    # Ruby
    '.rb', '.erb',
    
    # PHP
    '.php', '.php5', '.phtml',
    
    # Go
    '.go',
    
    # Rust
    '.rs',
    
    # Swift
    '.swift',
    
    # Shell
    '.sh', '.bash', '.zsh',
    
    # Config/Data
    '.json', '.yaml', '.yml', '.toml', '.xml',
    '.conf', '.ini', '.env',
    
    # Documentation
    '.md', '.rst', '.txt'
}

# Files to always ignore
IGNORE_PATTERNS = {
    # Build outputs
    'build/*', 'dist/*', 'target/*', 'bin/*',
    '*.pyc', '__pycache__/*', '*.class',
    
    # Dependencies
    'node_modules/*', 'vendor/*', 'venv/*',
    
    # IDE files
    '.idea/*', '.vscode/*', '*.swp',
    
    # Package files
    'package-lock.json', 'yarn.lock',
    'Pipfile.lock', 'poetry.lock',
    
    # Large data files
    '*.csv', '*.json.gz', '*.sql',
    
    # Binary/Media files
    '*.pdf', '*.jpg', '*.png', '*.gif',
    '*.mp3', '*.mp4', '*.mov', '*.bin',
    '*.exe', '*.dll', '*.so', '*.dylib'
}


# File: pyproject.toml
================================================================================

[project]
name = "repl-nix-workspace"
version = "0.1.0"
description = "Add your description here"
requires-python = ">=3.11"
dependencies = [
    "gitignore-parser>=0.1.11",
]


# File: concatenated_source.txt
================================================================================



# File: git_concatenator.py
================================================================================

#!/usr/bin/env python3
"""
Git Project Source Code Concatenator

This tool concatenates source code files from a git project into a single file,
including directory structure information.
"""

import argparse
import sys
from pathlib import Path
import os
from typing import Set, List, Optional
import fnmatch
from datetime import datetime
import gitignore_parser
from extensions import SOURCE_EXTENSIONS, IGNORE_PATTERNS

class GitConcatenator:
    def __init__(self, project_path: str, output_file: str):
        self.project_path = Path(project_path).resolve()
        self.output_file = Path(output_file)
        self.gitignore_matcher = self._setup_gitignore()
        self.debug = False

    def _setup_gitignore(self) -> Optional[callable]:
        """Setup gitignore matcher if .gitignore exists"""
        gitignore_path = self.project_path / '.gitignore'
        if gitignore_path.exists():
            try:
                return gitignore_parser.parse_gitignore(gitignore_path)
            except Exception as e:
                print(f"Warning: Failed to parse .gitignore: {e}")
        return None

    def _should_include_file(self, file_path: Path) -> bool:
        """Check if file should be included based on extension and ignore rules"""
        # Skip common virtual environment and system directories
        excluded_dirs = {
            '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
            '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
            'dist', 'build', 'target'
        }

        try:
            # Convert to relative path for checking
            try:
                rel_path = file_path.relative_to(self.project_path)
            except ValueError:
                if self.debug:
                    print(f"Debug: Skipping file outside project path: {file_path}")
                return False

            # Check for excluded directories in the path
            if any(part in excluded_dirs for part in file_path.parts):
                if self.debug:
                    print(f"Debug: Skipping excluded directory: {file_path}")
                return False

            # Check if file extension is in whitelist
            if file_path.suffix.lower() not in SOURCE_EXTENSIONS:
                if self.debug:
                    print(f"Debug: Skipping non-source file: {file_path}")
                return False

            # Check custom ignore patterns
            for pattern in IGNORE_PATTERNS:
                if fnmatch.fnmatch(str(rel_path), pattern):
                    if self.debug:
                        print(f"Debug: Skipping ignored pattern {pattern}: {file_path}")
                    return False

            # Check .gitignore if available
            if self.gitignore_matcher:
                try:
                    should_include = not self.gitignore_matcher(str(file_path))
                    if self.debug and not should_include:
                        print(f"Debug: Skipping gitignored file: {file_path}")
                    return should_include
                except Exception as e:
                    print(f"Warning: gitignore matching failed for {file_path}: {e}")
                    return True

            if self.debug:
                print(f"Debug: Including file: {file_path}")
            return True

        except Exception as e:
            print(f"Warning: Error checking file {file_path}: {e}")
            return False

    def _get_file_content(self, file_path: Path) -> str:
        """Read file content with proper encoding handling"""
        try:
            # Try UTF-8 first
            with open(file_path, 'r', encoding='utf-8') as f:
                return f.read()
        except UnicodeDecodeError:
            try:
                # Fallback to latin-1
                with open(file_path, 'r', encoding='latin-1') as f:
                    return f.read()
            except Exception as e:
                print(f"Warning: Failed to read {file_path}: {e}")
                return f"ERROR: Could not read file {file_path}\n"

    def _generate_directory_structure(self) -> str:
        """Generate a tree-like directory structure"""
        structure = ["Directory Structure:", ""]

        def add_to_tree(path: Path, prefix: str = ""):
            # Skip excluded directories
            excluded_dirs = {
                '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
                '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
                'dist', 'build', 'target'
            }
            if path.name in excluded_dirs:
                return

            # Add files first
            files = sorted([p for p in path.iterdir() if p.is_file()])
            included_files = [f for f in files if self._should_include_file(f)]

            for idx, file in enumerate(included_files):
                is_last = idx == len(included_files) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {file.name}")

            # Then add directories
            dirs = sorted([p for p in path.iterdir() if p.is_dir()])
            included_dirs = [d for d in dirs if d.name not in excluded_dirs]

            for idx, dir in enumerate(included_dirs):
                is_last = idx == len(included_dirs) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {dir.name}/")
                add_to_tree(dir, prefix + ("    " if is_last else "│   "))

        add_to_tree(self.project_path)
        return "\n".join(structure)

    def concatenate(self, debug: bool = False):
        """Main method to concatenate all source files"""
        self.debug = debug
        if not self.project_path.exists():
            print(f"Error: Project path {self.project_path} does not exist")
            return False

        try:
            with open(self.output_file, 'w', encoding='utf-8') as out:
                # Write header
                header = f"""
# Project Source Code Concatenation
# Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
# Project path: {self.project_path}

"""
                out.write(header)

                # Write directory structure
                out.write(self._generate_directory_structure())
                out.write("\n\n" + "="*80 + "\n\n")

                # Process all files
                file_count = 0
                for file_path in self.project_path.rglob('*'):
                    if file_path.is_file() and self._should_include_file(file_path):
                        rel_path = file_path.relative_to(self.project_path)

                        # Write file header
                        out.write(f"\n\n# File: {rel_path}\n")
                        out.write("="*80 + "\n\n")

                        # Write file content
                        content = self._get_file_content(file_path)
                        out.write(content)
                        file_count += 1

                print(f"Successfully concatenated {file_count} files to {self.output_file}")
                return True

        except Exception as e:
            print(f"Error during concatenation: {e}")
            return False

def main():
    parser = argparse.ArgumentParser(
        description="Concatenate git project source code into a single file"
    )
    parser.add_argument(
        "project_path",
        help="Path to the git project directory"
    )
    parser.add_argument(
        "-o", "--output",
        default="concatenated_source.txt",
        help="Output file path (default: concatenated_source.txt)"
    )
    parser.add_argument(
        "-d", "--debug",
        action="store_true",
        help="Enable debug logging"
    )

    args = parser.parse_args()

    concatenator = GitConcatenator(args.project_path, args.output)
    success = concatenator.concatenate(debug=args.debug)
    sys.exit(0 if success else 1)

if __name__ == "__main__":
    main()

# File: README.md
================================================================================

git clone https://github.com/yourusername/git-concatenator.git
   cd git-concatenator
   ```

2. Ensure you have Python 3.11 or later installed:
   ```bash
   python --version
   ```

3. Install the required dependency:
   ```bash
   pip install gitignore-parser
   ```

## Usage

Basic usage:
```bash
python git_concatenator.py /path/to/project -o output.txt
```

With debug logging:
```bash
python git_concatenator.py /path/to/project -o output.txt --debug
```

### Command-line Arguments

- `project_path`: Path to the Git project directory (required)
- `-o, --output`: Output file path (default: concatenated_source.txt)
- `-d, --debug`: Enable debug logging

## Output Format

The generated file includes:
1. A timestamp and project path header
2. A visual directory structure of the project
3. The contents of each source file, clearly separated with headers

Example output:
```
# Project Source Code Concatenation
# Generated on: 2025-02-15 20:53:29
# Project path: /path/to/project

Directory Structure:
├── src/
│   ├── main.py
│   └── utils.py
└── README.md

================================================================================

# File: src/main.py
================================================================================
[File contents here]

# File: src/utils.py
================================================================================
[File contents here]

# File: codesmelt.py
================================================================================

#!/usr/bin/env python3
"""
CodeSmelt: Source Code Concatenator

This tool melts down source code files from a git project into a single file,
including directory structure information.
"""

import argparse
import sys
from pathlib import Path
import os
from typing import Set, List, Optional
import fnmatch
from datetime import datetime
import gitignore_parser
from extensions import SOURCE_EXTENSIONS, IGNORE_PATTERNS

class CodeSmelt:
    def __init__(self, project_path: str, output_file: str):
        self.project_path = Path(project_path).resolve()
        self.output_file = Path(output_file)
        self.gitignore_matcher = self._setup_gitignore()
        self.debug = False

    def _setup_gitignore(self) -> Optional[callable]:
        """Setup gitignore matcher if .gitignore exists"""
        gitignore_path = self.project_path / '.gitignore'
        if gitignore_path.exists():
            try:
                return gitignore_parser.parse_gitignore(gitignore_path)
            except Exception as e:
                print(f"Warning: Failed to parse .gitignore: {e}")
        return None

    def _should_include_file(self, file_path: Path) -> bool:
        """Check if file should be included based on extension and ignore rules"""
        # Skip common virtual environment and system directories
        excluded_dirs = {
            '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
            '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
            'dist', 'build', 'target'
        }

        try:
            # Convert to relative path for checking
            try:
                rel_path = file_path.relative_to(self.project_path)
            except ValueError:
                if self.debug:
                    print(f"Debug: Skipping file outside project path: {file_path}")
                return False

            # Check for excluded directories in the path
            if any(part in excluded_dirs for part in file_path.parts):
                if self.debug:
                    print(f"Debug: Skipping excluded directory: {file_path}")
                return False

            # Check if file extension is in whitelist
            if file_path.suffix.lower() not in SOURCE_EXTENSIONS:
                if self.debug:
                    print(f"Debug: Skipping non-source file: {file_path}")
                return False

            # Check custom ignore patterns
            for pattern in IGNORE_PATTERNS:
                if fnmatch.fnmatch(str(rel_path), pattern):
                    if self.debug:
                        print(f"Debug: Skipping ignored pattern {pattern}: {file_path}")
                    return False

            # Check .gitignore if available
            if self.gitignore_matcher:
                try:
                    should_include = not self.gitignore_matcher(str(file_path))
                    if self.debug and not should_include:
                        print(f"Debug: Skipping gitignored file: {file_path}")
                    return should_include
                except Exception as e:
                    print(f"Warning: gitignore matching failed for {file_path}: {e}")
                    return True

            if self.debug:
                print(f"Debug: Including file: {file_path}")
            return True

        except Exception as e:
            print(f"Warning: Error checking file {file_path}: {e}")
            return False

    def _get_file_content(self, file_path: Path) -> str:
        """Read file content with proper encoding handling"""
        try:
            # Try UTF-8 first
            with open(file_path, 'r', encoding='utf-8') as f:
                return f.read()
        except UnicodeDecodeError:
            try:
                # Fallback to latin-1
                with open(file_path, 'r', encoding='latin-1') as f:
                    return f.read()
            except Exception as e:
                print(f"Warning: Failed to read {file_path}: {e}")
                return f"ERROR: Could not read file {file_path}\n"

    def _generate_directory_structure(self) -> str:
        """Generate a tree-like directory structure"""
        structure = ["Directory Structure:", ""]

        def add_to_tree(path: Path, prefix: str = ""):
            # Skip excluded directories
            excluded_dirs = {
                '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
                '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
                'dist', 'build', 'target'
            }
            if path.name in excluded_dirs:
                return

            # Add files first
            files = sorted([p for p in path.iterdir() if p.is_file()])
            included_files = [f for f in files if self._should_include_file(f)]

            for idx, file in enumerate(included_files):
                is_last = idx == len(included_files) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {file.name}")

            # Then add directories
            dirs = sorted([p for p in path.iterdir() if p.is_dir()])
            included_dirs = [d for d in dirs if d.name not in excluded_dirs]

            for idx, dir in enumerate(included_dirs):
                is_last = idx == len(included_dirs) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {dir.name}/")
                add_to_tree(dir, prefix + ("    " if is_last else "│   "))

        add_to_tree(self.project_path)
        return "\n".join(structure)

    def concatenate(self, debug: bool = False):
        """Main method to concatenate all source files"""
        self.debug = debug
        if not self.project_path.exists():
            print(f"Error: Project path {self.project_path} does not exist")
            return False

        try:
            with open(self.output_file, 'w', encoding='utf-8') as out:
                # Write header
                header = f"""
# Project Source Code Concatenation
# Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
# Project path: {self.project_path}

"""
                out.write(header)

                # Write directory structure
                out.write(self._generate_directory_structure())
                out.write("\n\n" + "="*80 + "\n\n")

                # Process all files
                file_count = 0
                for file_path in self.project_path.rglob('*'):
                    if file_path.is_file() and self._should_include_file(file_path):
                        rel_path = file_path.relative_to(self.project_path)

                        # Write file header
                        out.write(f"\n\n# File: {rel_path}\n")
                        out.write("="*80 + "\n\n")

                        # Write file content
                        content = self._get_file_content(file_path)
                        out.write(content)
                        file_count += 1

                print(f"Successfully melted {file_count} files to {self.output_file}")
                return True

        except Exception as e:
            print(f"Error during melting: {e}")
            return False

def main():
    parser = argparse.ArgumentParser(
        description="CodeSmelt: Melt down your git project's source code into a single file"
    )
    parser.add_argument(
        "project_path",
        help="Path to the git project directory"
    )
    parser.add_argument(
        "-o", "--output",
        default="concatenated_source.txt",
        help="Output file path (default: concatenated_source.txt)"
    )
    parser.add_argument(
        "-d", "--debug",
        action="store_true",
        help="Enable debug logging"
    )

    args = parser.parse_args()

    concatenator = CodeSmelt(args.project_path, args.output)
    success = concatenator.concatenate(debug=args.debug)
    sys.exit(0 if success else 1)

if __name__ == "__main__":
    main()

# File: README.md
================================================================================

python --version
   ```

2. Install the required dependency:
   ```bash
   pip install gitignore-parser
   ```

## Usage

Basic usage:
```bash
python codesmelt.py /path/to/project -o output.txt
```

With debug logging:
```bash
python codesmelt.py /path/to/project -o output.txt --debug
```

### Command-line Arguments

- `project_path`: Path to the Git project directory (required)
- `-o, --output`: Output file path (default: concatenated_source.txt)
- `-d, --debug`: Enable debug logging

## Configuration

### Source File Extensions
The tool includes common source code file extensions by default (defined in `extensions.py`):
- Web: `.js`, `.ts`, `.jsx`, `.tsx`, `.vue`, `.svelte`, `.html`, `.css`, etc.
- Python: `.py`, `.pyi`, `.pyx`
- Java/Kotlin: `.java`, `.kt`, `.groovy`
- C-family: `.c`, `.cpp`, `.h`, `.hpp`
- And many more...

#### Customizing File Extensions
You can modify which file extensions are included by editing the `SOURCE_EXTENSIONS` set in `extensions.py`. For example, to include Unity3D script files while excluding other Unity files:

```python
SOURCE_EXTENSIONS = {
    # ... existing extensions ...

    # Unity3D specific
    '.cs',  # C# scripts
    '.shader', # Custom shaders
    '.asmdef', # Assembly definitions

    # ... other extensions ...
}
```

### Ignore Patterns
The tool automatically ignores files based on three levels:

1. Built-in patterns (`IGNORE_PATTERNS` in `extensions.py`):
   - Build outputs (`build/*`, `dist/*`, `*.pyc`, etc.)
   - Dependencies (`node_modules/*`, `vendor/*`, `venv/*`)
   - IDE files (`.idea/*`, `.vscode/*`)
   - Package lock files (`package-lock.json`, `poetry.lock`, etc.)
   - Binary and media files (`*.pdf`, `*.jpg`, `*.exe`, etc.)

2. Project's `.gitignore` rules (if present)
3. Directory-specific `.gitignore` rules

#### Customizing Ignore Patterns
To modify which files are ignored, you can:

1. Edit `IGNORE_PATTERNS` in `extensions.py`:
```python
IGNORE_PATTERNS = {
    # ... existing patterns ...

    # Unity3D specific ignores
    'Assets/AssetStoreTools/*',
    'Library/*',
    'Temp/*',
    'Logs/*',
    '*.unity',  # Unity scene files
    '*.meta',   # Unity meta files
    '*.prefab', # Unity prefab files

    # ... other patterns ...
}
```

2. Use your project's `.gitignore` file for project-specific exclusions

**Note**: Ignore patterns follow the same syntax as `.gitignore` files. The tool processes these rules in order:
1. Built-in `IGNORE_PATTERNS`
2. Project's root `.gitignore`
3. Directory-specific `.gitignore` files


## Tips for Using with LLMs

1. **Token Management**:
   - For large projects, consider concatenating only specific directories
   - Use the debug mode to see which files are included/excluded
   - Remove unnecessary documentation files if you're close to token limits

2. **Effective Prompting**:
   - Reference files using their relative paths as shown in the directory structure
   - Use the directory structure to ask about specific components
   - Refer to file relationships based on the visual structure

3. **Best Practices**:
   - Review the concatenated output before sending to ensure relevance
   - For large projects, break down analysis into smaller, focused components
   - Use the debug mode to verify file selection when customizing

## Output Format

The generated file includes:
1. A timestamp and project path header
2. A visual directory structure of the project
3. The contents of each source file, clearly separated with headers

Example output:
```
# Project Source Code Concatenation
# Generated on: 2025-02-15 20:53:29
# Project path: /path/to/project

Directory Structure:
├── src/
│   ├── main.py
│   └── utils.py
└── README.md

================================================================================

# File: src/main.py
================================================================================
[File contents here]

# File: src/utils.py
================================================================================
[File contents here]
```

## Troubleshooting

### Common Issues

1. **No Files Found**:
   - Verify the project path is correct
   - Check if files have supported extensions
   - Run with --debug to see which files are being filtered

2. **Missing Dependencies**:
   ```bash
   pip install --upgrade gitignore-parser

# File: codesmelt.py
================================================================================

#!/usr/bin/env python3
"""
CodeSmelt: Source Code Concatenator

This tool melts down source code files from a git project into a single file,
including directory structure information.
"""

import argparse
import sys
from pathlib import Path
import os
from typing import Set, List, Optional
import fnmatch
from datetime import datetime
import gitignore_parser
from extensions import SOURCE_EXTENSIONS, IGNORE_PATTERNS

class CodeSmelt:
    def __init__(self, project_path: str, output_file: str):
        self.project_path = Path(project_path).resolve()
        self.output_file = Path(output_file)
        self.gitignore_matcher = self._setup_gitignore()
        self.debug = False

    def _setup_gitignore(self) -> Optional[callable]:
        """Setup gitignore matcher if .gitignore exists"""
        gitignore_path = self.project_path / '.gitignore'
        if gitignore_path.exists():
            try:
                return gitignore_parser.parse_gitignore(gitignore_path)
            except Exception as e:
                print(f"Warning: Failed to parse .gitignore: {e}")
        return None

    def _should_include_file(self, file_path: Path) -> bool:
        """Check if file should be included based on extension and ignore rules"""
        # Skip common virtual environment and system directories
        excluded_dirs = {
            '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
            '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
            'dist', 'build', 'target'
        }

        try:
            # Convert to relative path for checking
            try:
                rel_path = file_path.relative_to(self.project_path)
            except ValueError:
                if self.debug:
                    print(f"Debug: Skipping file outside project path: {file_path}")
                return False

            # Check for excluded directories in the path
            if any(part in excluded_dirs for part in file_path.parts):
                if self.debug:
                    print(f"Debug: Skipping excluded directory: {file_path}")
                return False

            # Check if file extension is in whitelist
            if file_path.suffix.lower() not in SOURCE_EXTENSIONS:
                if self.debug:
                    print(f"Debug: Skipping non-source file: {file_path}")
                return False

            # Check custom ignore patterns
            for pattern in IGNORE_PATTERNS:
                if fnmatch.fnmatch(str(rel_path), pattern):
                    if self.debug:
                        print(f"Debug: Skipping ignored pattern {pattern}: {file_path}")
                    return False

            # Check .gitignore if available
            if self.gitignore_matcher:
                try:
                    should_include = not self.gitignore_matcher(str(file_path))
                    if self.debug and not should_include:
                        print(f"Debug: Skipping gitignored file: {file_path}")
                    return should_include
                except Exception as e:
                    print(f"Warning: gitignore matching failed for {file_path}: {e}")
                    return True

            if self.debug:
                print(f"Debug: Including file: {file_path}")
            return True

        except Exception as e:
            print(f"Warning: Error checking file {file_path}: {e}")
            return False

    def _get_file_content(self, file_path: Path) -> str:
        """Read file content with proper encoding handling"""
        try:
            # Try UTF-8 first
            with open(file_path, 'r', encoding='utf-8') as f:
                return f.read()
        except UnicodeDecodeError:
            try:
                # Fallback to latin-1
                with open(file_path, 'r', encoding='latin-1') as f:
                    return f.read()
            except Exception as e:
                print(f"Warning: Failed to read {file_path}: {e}")
                return f"ERROR: Could not read file {file_path}\n"

    def _generate_directory_structure(self) -> str:
        """Generate a tree-like directory structure"""
        structure = ["Directory Structure:", ""]

        def add_to_tree(path: Path, prefix: str = ""):
            # Skip excluded directories
            excluded_dirs = {
                '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
                '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
                'dist', 'build', 'target'
            }
            if path.name in excluded_dirs:
                return

            # Add files first
            files = sorted([p for p in path.iterdir() if p.is_file()])
            included_files = [f for f in files if self._should_include_file(f)]

            for idx, file in enumerate(included_files):
                is_last = idx == len(included_files) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {file.name}")

            # Then add directories
            dirs = sorted([p for p in path.iterdir() if p.is_dir()])
            included_dirs = [d for d in dirs if d.name not in excluded_dirs]

            for idx, dir in enumerate(included_dirs):
                is_last = idx == len(included_dirs) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {dir.name}/")
                add_to_tree(dir, prefix + ("    " if is_last else "│   "))

        add_to_tree(self.project_path)
        return "\n".join(structure)

    def concatenate(self, debug: bool = False):
        """Main method to concatenate all source files"""
        self.debug = debug
        if not self.project_path.exists():
            print(f"Error: Project path {self.project_path} does not exist")
            return False

        try:
            with open(self.output_file, 'w', encoding='utf-8') as out:
                # Write header
                header = f"""
# Project Source Code Concatenation
# Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
# Project path: {self.project_path}

"""
                out.write(header)

                # Write directory structure
                out.write(self._generate_directory_structure())
                out.write("\n\n" + "="*80 + "\n\n")

                # Process all files
                file_count = 0
                for file_path in self.project_path.rglob('*'):
                    if file_path.is_file() and self._should_include_file(file_path):
                        rel_path = file_path.relative_to(self.project_path)

                        # Write file header
                        out.write(f"\n\n# File: {rel_path}\n")
                        out.write("="*80 + "\n\n")

                        # Write file content
                        content = self._get_file_content(file_path)
                        out.write(content)
                        file_count += 1

                print(f"Successfully melted {file_count} files to {self.output_file}")
                return True

        except Exception as e:
            print(f"Error during melting: {e}")
            return False

def main():
    parser = argparse.ArgumentParser(
        description="CodeSmelt: Melt down your git project's source code into a single file",
        usage="%(prog)s [-o OUTPUT] [-d] project_path"
    )
    parser.add_argument(
        "-o", "--output",
        default="concatenated_source.txt",
        help="Output file path (default: concatenated_source.txt)"
    )
    parser.add_argument(
        "-d", "--debug",
        action="store_true",
        help="Enable debug logging"
    )
    parser.add_argument(
        "project_path",
        help="Path to the git project directory",
        nargs="?"  # Make it optional in the parser (though we'll check it's provided)
    )

    args = parser.parse_args()

    if not args.project_path:
        parser.error("project_path is required")

    concatenator = CodeSmelt(args.project_path, args.output)
    success = concatenator.concatenate(debug=args.debug)
    sys.exit(0 if success else 1)

if __name__ == "__main__":
    main()

# File: README.md
================================================================================

python codesmelt.py /path/to/project
```

Specify custom output file:
```bash
python codesmelt.py -o output.txt /path/to/project
```

With debug logging:
```bash
python codesmelt.py -d -o output.txt /path/to/project
```

### Command-line Arguments
- `project_path`: Path to the Git project directory (required)
- `-o, --output`: Output file path (default: concatenated_source.txt)
- `-d, --debug`: Enable debug logging

## Configuration

### Source File Extensions
The tool includes common source code file extensions by default (defined in `extensions.py`):
- Web: `.js`, `.ts`, `.jsx`, `.tsx`, `.vue`, `.svelte`, `.html`, `.css`, etc.
- Python: `.py`, `.pyi`, `.pyx`
- Java/Kotlin: `.java`, `.kt`, `.groovy`
- C-family: `.c`, `.cpp`, `.h`, `.hpp`
- And many more...

#### Customizing File Extensions
You can modify which file extensions are included by editing the `SOURCE_EXTENSIONS` set in `extensions.py`. For example, to include Unity3D script files while excluding other Unity files:

```python
SOURCE_EXTENSIONS = {
    # ... existing extensions ...

    # Unity3D specific
    '.cs',  # C# scripts
    '.shader', # Custom shaders
    '.asmdef', # Assembly definitions

    # ... other extensions ...
}
```

### Ignore Patterns
The tool automatically ignores files based on three levels:

1. Built-in patterns (`IGNORE_PATTERNS` in `extensions.py`):
   - Build outputs (`build/*`, `dist/*`, `*.pyc`, etc.)
   - Dependencies (`node_modules/*`, `vendor/*`, `venv/*`)
   - IDE files (`.idea/*`, `.vscode/*`)
   - Package lock files (`package-lock.json`, `poetry.lock`, etc.)
   - Binary and media files (`*.pdf`, `*.jpg`, `*.exe`, etc.)

2. Project's `.gitignore` rules (if present)
3. Directory-specific `.gitignore` rules

#### Customizing Ignore Patterns
To modify which files are ignored, you can:

1. Edit `IGNORE_PATTERNS` in `extensions.py`:
```python
IGNORE_PATTERNS = {
    # ... existing patterns ...

    # Unity3D specific ignores
    'Assets/AssetStoreTools/*',
    'Library/*',
    'Temp/*',
    'Logs/*',
    '*.unity',  # Unity scene files
    '*.meta',   # Unity meta files
    '*.prefab', # Unity prefab files

    # ... other patterns ...
}
```

2. Use your project's `.gitignore` file for project-specific exclusions

**Note**: Ignore patterns follow the same syntax as `.gitignore` files. The tool processes these rules in order:
1. Built-in `IGNORE_PATTERNS`
2. Project's root `.gitignore`
3. Directory-specific `.gitignore` files


## Tips for Using with LLMs

1. **Token Management**:
   - For large projects, consider concatenating only specific directories
   - Use the debug mode to see which files are included/excluded
   - Remove unnecessary documentation files if you're close to token limits

2. **Effective Prompting**:
   - Reference files using their relative paths as shown in the directory structure
   - Use the directory structure to ask about specific components
   - Refer to file relationships based on the visual structure

3. **Best Practices**:
   - Review the concatenated output before sending to ensure relevance
   - For large projects, break down analysis into smaller, focused components
   - Use the debug mode to verify file selection when customizing

## Output Format

The generated file includes:
1. A timestamp and project path header
2. A visual directory structure of the project
3. The contents of each source file, clearly separated with headers

Example output:
```
# Project Source Code Concatenation
# Generated on: 2025-02-15 20:53:29
# Project path: /path/to/project

Directory Structure:
├── src/
│   ├── main.py
│   └── utils.py
└── README.md

================================================================================

# File: src/main.py
================================================================================
[File contents here]

# File: src/utils.py
================================================================================
[File contents here]
```

## Troubleshooting

### Common Issues

1. **No Files Found**:
   - Verify the project path is correct
   - Check if files have supported extensions
   - Run with --debug to see which files are being filtered

2. **Missing Dependencies**:
   ```bash
   pip install --upgrade gitignore-parser

# File: test_output.txt
================================================================================


# Project Source Code Concatenation
# Generated on: 2025-02-15 22:55:02
# Project path: /home/runner/workspace

Directory Structure:

├── README.md
├── codesmelt.py
├── concatenated_source.txt
├── extensions.py
├── output.txt
├── pyproject.toml
└── test_output.txt

================================================================================



# File: extensions.py
================================================================================

"""
Source code file extension configurations
"""

# Common source code file extensions
SOURCE_EXTENSIONS = {
    # Web
    '.js', '.ts', '.jsx', '.tsx', '.vue', '.svelte',
    '.html', '.htm', '.css', '.scss', '.sass', '.less',
    
    # Python
    '.py', '.pyi', '.pyx',
    
    # Java/Kotlin
    '.java', '.kt', '.groovy',
    
    # C-family
    '.c', '.cpp', '.h', '.hpp', '.cc',
    
    # C#
    '.cs', '.cshtml', '.csx',
    
    # Ruby
    '.rb', '.erb',
    
    # PHP
    '.php', '.php5', '.phtml',
    
    # Go
    '.go',
    
    # Rust
    '.rs',
    
    # Swift
    '.swift',
    
    # Shell
    '.sh', '.bash', '.zsh',
    
    # Config/Data
    '.json', '.yaml', '.yml', '.toml', '.xml',
    '.conf', '.ini', '.env',
    
    # Documentation
    '.md', '.rst', '.txt'
}

# Files to always ignore
IGNORE_PATTERNS = {
    # Build outputs
    'build/*', 'dist/*', 'target/*', 'bin/*',
    '*.pyc', '__pycache__/*', '*.class',
    
    # Dependencies
    'node_modules/*', 'vendor/*', 'venv/*',
    
    # IDE files
    '.idea/*', '.vscode/*', '*.swp',
    
    # Package files
    'package-lock.json', 'yarn.lock',
    'Pipfile.lock', 'poetry.lock',
    
    # Large data files
    '*.csv', '*.json.gz', '*.sql',
    
    # Binary/Media files
    '*.pdf', '*.jpg', '*.png', '*.gif',
    '*.mp3', '*.mp4', '*.mov', '*.bin',
    '*.exe', '*.dll', '*.so', '*.dylib'
}


# File: pyproject.toml
================================================================================

[project]
name = "repl-nix-workspace"
version = "0.1.0"
description = "Add your description here"
requires-python = ">=3.11"
dependencies = [
    "gitignore-parser>=0.1.11",
]


# File: concatenated_source.txt
================================================================================


# Project Source Code Concatenation
# Generated on: 2025-02-15 22:55:02
# Project path: /home/runner/workspace

Directory Structure:

├── README.md
├── codesmelt.py
├── concatenated_source.txt
├── extensions.py
├── output.txt
└── pyproject.toml

================================================================================



# File: extensions.py
================================================================================

"""
Source code file extension configurations
"""

# Common source code file extensions
SOURCE_EXTENSIONS = {
    # Web
    '.js', '.ts', '.jsx', '.tsx', '.vue', '.svelte',
    '.html', '.htm', '.css', '.scss', '.sass', '.less',
    
    # Python
    '.py', '.pyi', '.pyx',
    
    # Java/Kotlin
    '.java', '.kt', '.groovy',
    
    # C-family
    '.c', '.cpp', '.h', '.hpp', '.cc',
    
    # C#
    '.cs', '.cshtml', '.csx',
    
    # Ruby
    '.rb', '.erb',
    
    # PHP
    '.php', '.php5', '.phtml',
    
    # Go
    '.go',
    
    # Rust
    '.rs',
    
    # Swift
    '.swift',
    
    # Shell
    '.sh', '.bash', '.zsh',
    
    # Config/Data
    '.json', '.yaml', '.yml', '.toml', '.xml',
    '.conf', '.ini', '.env',
    
    # Documentation
    '.md', '.rst', '.txt'
}

# Files to always ignore
IGNORE_PATTERNS = {
    # Build outputs
    'build/*', 'dist/*', 'target/*', 'bin/*',
    '*.pyc', '__pycache__/*', '*.class',
    
    # Dependencies
    'node_modules/*', 'vendor/*', 'venv/*',
    
    # IDE files
    '.idea/*', '.vscode/*', '*.swp',
    
    # Package files
    'package-lock.json', 'yarn.lock',
    'Pipfile.lock', 'poetry.lock',
    
    # Large data files
    '*.csv', '*.json.gz', '*.sql',
    
    # Binary/Media files
    '*.pdf', '*.jpg', '*.png', '*.gif',
    '*.mp3', '*.mp4', '*.mov', '*.bin',
    '*.exe', '*.dll', '*.so', '*.dylib'
}


# File: pyproject.toml
================================================================================

[project]
name = "repl-nix-workspace"
version = "0.1.0"
description = "Add your description here"
requires-python = ">=3.11"
dependencies = [
    "gitignore-parser>=0.1.11",
]


# File: concatenated_source.txt
================================================================================



# File: output.txt
================================================================================


# Project Source Code Concatenation
# Generated on: 2025-02-15 22:44:33
# Project path: /home/runner/workspace

Directory Structure:

├── README.md
├── codesmelt.py
├── concatenated_source.txt
├── extensions.py
├── output.txt
└── pyproject.toml

================================================================================



# File: extensions.py
================================================================================

"""
Source code file extension configurations
"""

# Common source code file extensions
SOURCE_EXTENSIONS = {
    # Web
    '.js', '.ts', '.jsx', '.tsx', '.vue', '.svelte',
    '.html', '.htm', '.css', '.scss', '.sass', '.less',
    
    # Python
    '.py', '.pyi', '.pyx',
    
    # Java/Kotlin
    '.java', '.kt', '.groovy',
    
    # C-family
    '.c', '.cpp', '.h', '.hpp', '.cc',
    
    # C#
    '.cs', '.cshtml', '.csx',
    
    # Ruby
    '.rb', '.erb',
    
    # PHP
    '.php', '.php5', '.phtml',
    
    # Go
    '.go',
    
    # Rust
    '.rs',
    
    # Swift
    '.swift',
    
    # Shell
    '.sh', '.bash', '.zsh',
    
    # Config/Data
    '.json', '.yaml', '.yml', '.toml', '.xml',
    '.conf', '.ini', '.env',
    
    # Documentation
    '.md', '.rst', '.txt'
}

# Files to always ignore
IGNORE_PATTERNS = {
    # Build outputs
    'build/*', 'dist/*', 'target/*', 'bin/*',
    '*.pyc', '__pycache__/*', '*.class',
    
    # Dependencies
    'node_modules/*', 'vendor/*', 'venv/*',
    
    # IDE files
    '.idea/*', '.vscode/*', '*.swp',
    
    # Package files
    'package-lock.json', 'yarn.lock',
    'Pipfile.lock', 'poetry.lock',
    
    # Large data files
    '*.csv', '*.json.gz', '*.sql',
    
    # Binary/Media files
    '*.pdf', '*.jpg', '*.png', '*.gif',
    '*.mp3', '*.mp4', '*.mov', '*.bin',
    '*.exe', '*.dll', '*.so', '*.dylib'
}


# File: pyproject.toml
================================================================================

[project]
name = "repl-nix-workspace"
version = "0.1.0"
description = "Add your description here"
requires-python = ">=3.11"
dependencies = [
    "gitignore-parser>=0.1.11",
]


# File: concatenated_source.txt
================================================================================


# Project Source Code Concatenation
# Generated on: 2025-02-15 21:22:24
# Project path: /home/runner/workspace

Directory Structure:

├── README.md
├── concatenated_source.txt
├── extensions.py
├── git_concatenator.py
└── pyproject.toml

================================================================================



# File: extensions.py
================================================================================

"""
Source code file extension configurations
"""

# Common source code file extensions
SOURCE_EXTENSIONS = {
    # Web
    '.js', '.ts', '.jsx', '.tsx', '.vue', '.svelte',
    '.html', '.htm', '.css', '.scss', '.sass', '.less',
    
    # Python
    '.py', '.pyi', '.pyx',
    
    # Java/Kotlin
    '.java', '.kt', '.groovy',
    
    # C-family
    '.c', '.cpp', '.h', '.hpp', '.cc',
    
    # C#
    '.cs', '.cshtml', '.csx',
    
    # Ruby
    '.rb', '.erb',
    
    # PHP
    '.php', '.php5', '.phtml',
    
    # Go
    '.go',
    
    # Rust
    '.rs',
    
    # Swift
    '.swift',
    
    # Shell
    '.sh', '.bash', '.zsh',
    
    # Config/Data
    '.json', '.yaml', '.yml', '.toml', '.xml',
    '.conf', '.ini', '.env',
    
    # Documentation
    '.md', '.rst', '.txt'
}

# Files to always ignore
IGNORE_PATTERNS = {
    # Build outputs
    'build/*', 'dist/*', 'target/*', 'bin/*',
    '*.pyc', '__pycache__/*', '*.class',
    
    # Dependencies
    'node_modules/*', 'vendor/*', 'venv/*',
    
    # IDE files
    '.idea/*', '.vscode/*', '*.swp',
    
    # Package files
    'package-lock.json', 'yarn.lock',
    'Pipfile.lock', 'poetry.lock',
    
    # Large data files
    '*.csv', '*.json.gz', '*.sql',
    
    # Binary/Media files
    '*.pdf', '*.jpg', '*.png', '*.gif',
    '*.mp3', '*.mp4', '*.mov', '*.bin',
    '*.exe', '*.dll', '*.so', '*.dylib'
}


# File: pyproject.toml
================================================================================

[project]
name = "repl-nix-workspace"
version = "0.1.0"
description = "Add your description here"
requires-python = ">=3.11"
dependencies = [
    "gitignore-parser>=0.1.11",
]


# File: concatenated_source.txt
================================================================================



# File: git_concatenator.py
================================================================================

#!/usr/bin/env python3
"""
Git Project Source Code Concatenator

This tool concatenates source code files from a git project into a single file,
including directory structure information.
"""

import argparse
import sys
from pathlib import Path
import os
from typing import Set, List, Optional
import fnmatch
from datetime import datetime
import gitignore_parser
from extensions import SOURCE_EXTENSIONS, IGNORE_PATTERNS

class GitConcatenator:
    def __init__(self, project_path: str, output_file: str):
        self.project_path = Path(project_path).resolve()
        self.output_file = Path(output_file)
        self.gitignore_matcher = self._setup_gitignore()
        self.debug = False

    def _setup_gitignore(self) -> Optional[callable]:
        """Setup gitignore matcher if .gitignore exists"""
        gitignore_path = self.project_path / '.gitignore'
        if gitignore_path.exists():
            try:
                return gitignore_parser.parse_gitignore(gitignore_path)
            except Exception as e:
                print(f"Warning: Failed to parse .gitignore: {e}")
        return None

    def _should_include_file(self, file_path: Path) -> bool:
        """Check if file should be included based on extension and ignore rules"""
        # Skip common virtual environment and system directories
        excluded_dirs = {
            '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
            '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
            'dist', 'build', 'target'
        }

        try:
            # Convert to relative path for checking
            try:
                rel_path = file_path.relative_to(self.project_path)
            except ValueError:
                if self.debug:
                    print(f"Debug: Skipping file outside project path: {file_path}")
                return False

            # Check for excluded directories in the path
            if any(part in excluded_dirs for part in file_path.parts):
                if self.debug:
                    print(f"Debug: Skipping excluded directory: {file_path}")
                return False

            # Check if file extension is in whitelist
            if file_path.suffix.lower() not in SOURCE_EXTENSIONS:
                if self.debug:
                    print(f"Debug: Skipping non-source file: {file_path}")
                return False

            # Check custom ignore patterns
            for pattern in IGNORE_PATTERNS:
                if fnmatch.fnmatch(str(rel_path), pattern):
                    if self.debug:
                        print(f"Debug: Skipping ignored pattern {pattern}: {file_path}")
                    return False

            # Check .gitignore if available
            if self.gitignore_matcher:
                try:
                    should_include = not self.gitignore_matcher(str(file_path))
                    if self.debug and not should_include:
                        print(f"Debug: Skipping gitignored file: {file_path}")
                    return should_include
                except Exception as e:
                    print(f"Warning: gitignore matching failed for {file_path}: {e}")
                    return True

            if self.debug:
                print(f"Debug: Including file: {file_path}")
            return True

        except Exception as e:
            print(f"Warning: Error checking file {file_path}: {e}")
            return False

    def _get_file_content(self, file_path: Path) -> str:
        """Read file content with proper encoding handling"""
        try:
            # Try UTF-8 first
            with open(file_path, 'r', encoding='utf-8') as f:
                return f.read()
        except UnicodeDecodeError:
            try:
                # Fallback to latin-1
                with open(file_path, 'r', encoding='latin-1') as f:
                    return f.read()
            except Exception as e:
                print(f"Warning: Failed to read {file_path}: {e}")
                return f"ERROR: Could not read file {file_path}\n"

    def _generate_directory_structure(self) -> str:
        """Generate a tree-like directory structure"""
        structure = ["Directory Structure:", ""]

        def add_to_tree(path: Path, prefix: str = ""):
            # Skip excluded directories
            excluded_dirs = {
                '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
                '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
                'dist', 'build', 'target'
            }
            if path.name in excluded_dirs:
                return

            # Add files first
            files = sorted([p for p in path.iterdir() if p.is_file()])
            included_files = [f for f in files if self._should_include_file(f)]

            for idx, file in enumerate(included_files):
                is_last = idx == len(included_files) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {file.name}")

            # Then add directories
            dirs = sorted([p for p in path.iterdir() if p.is_dir()])
            included_dirs = [d for d in dirs if d.name not in excluded_dirs]

            for idx, dir in enumerate(included_dirs):
                is_last = idx == len(included_dirs) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {dir.name}/")
                add_to_tree(dir, prefix + ("    " if is_last else "│   "))

        add_to_tree(self.project_path)
        return "\n".join(structure)

    def concatenate(self, debug: bool = False):
        """Main method to concatenate all source files"""
        self.debug = debug
        if not self.project_path.exists():
            print(f"Error: Project path {self.project_path} does not exist")
            return False

        try:
            with open(self.output_file, 'w', encoding='utf-8') as out:
                # Write header
                header = f"""
# Project Source Code Concatenation
# Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
# Project path: {self.project_path}

"""
                out.write(header)

                # Write directory structure
                out.write(self._generate_directory_structure())
                out.write("\n\n" + "="*80 + "\n\n")

                # Process all files
                file_count = 0
                for file_path in self.project_path.rglob('*'):
                    if file_path.is_file() and self._should_include_file(file_path):
                        rel_path = file_path.relative_to(self.project_path)

                        # Write file header
                        out.write(f"\n\n# File: {rel_path}\n")
                        out.write("="*80 + "\n\n")

                        # Write file content
                        content = self._get_file_content(file_path)
                        out.write(content)
                        file_count += 1

                print(f"Successfully concatenated {file_count} files to {self.output_file}")
                return True

        except Exception as e:
            print(f"Error during concatenation: {e}")
            return False

def main():
    parser = argparse.ArgumentParser(
        description="Concatenate git project source code into a single file"
    )
    parser.add_argument(
        "project_path",
        help="Path to the git project directory"
    )
    parser.add_argument(
        "-o", "--output",
        default="concatenated_source.txt",
        help="Output file path (default: concatenated_source.txt)"
    )
    parser.add_argument(
        "-d", "--debug",
        action="store_true",
        help="Enable debug logging"
    )

    args = parser.parse_args()

    concatenator = GitConcatenator(args.project_path, args.output)
    success = concatenator.concatenate(debug=args.debug)
    sys.exit(0 if success else 1)

if __name__ == "__main__":
    main()

# File: README.md
================================================================================

git clone https://github.com/yourusername/git-concatenator.git
   cd git-concatenator
   ```

2. Ensure you have Python 3.11 or later installed:
   ```bash
   python --version
   ```

3. Install the required dependency:
   ```bash
   pip install gitignore-parser
   ```

## Usage

Basic usage:
```bash
python git_concatenator.py /path/to/project -o output.txt
```

With debug logging:
```bash
python git_concatenator.py /path/to/project -o output.txt --debug
```

### Command-line Arguments

- `project_path`: Path to the Git project directory (required)
- `-o, --output`: Output file path (default: concatenated_source.txt)
- `-d, --debug`: Enable debug logging

## Output Format

The generated file includes:
1. A timestamp and project path header
2. A visual directory structure of the project
3. The contents of each source file, clearly separated with headers

Example output:
```
# Project Source Code Concatenation
# Generated on: 2025-02-15 20:53:29
# Project path: /path/to/project

Directory Structure:
├── src/
│   ├── main.py
│   └── utils.py
└── README.md

================================================================================

# File: src/main.py
================================================================================
[File contents here]

# File: src/utils.py
================================================================================
[File contents here]

# File: output.txt
================================================================================


# Project Source Code Concatenation
# Generated on: 2025-02-15 22:44:33
# Project path: /home/runner/workspace

Directory Structure:

├── README.md
├── codesmelt.py
├── concatenated_source.txt
├── extensions.py
├── output.txt
└── pyproject.toml

================================================================================



# File: extensions.py
================================================================================

"""
Source code file extension configurations
"""

# Common source code file extensions
SOURCE_EXTENSIONS = {
    # Web
    '.js', '.ts', '.jsx', '.tsx', '.vue', '.svelte',
    '.html', '.htm', '.css', '.scss', '.sass', '.less',
    
    # Python
    '.py', '.pyi', '.pyx',
    
    # Java/Kotlin
    '.java', '.kt', '.groovy',
    
    # C-family
    '.c', '.cpp', '.h', '.hpp', '.cc',
    
    # C#
    '.cs', '.cshtml', '.csx',
    
    # Ruby
    '.rb', '.erb',
    
    # PHP
    '.php', '.php5', '.phtml',
    
    # Go
    '.go',
    
    # Rust
    '.rs',
    
    # Swift
    '.swift',
    
    # Shell
    '.sh', '.bash', '.zsh',
    
    # Config/Data
    '.json', '.yaml', '.yml', '.toml', '.xml',
    '.conf', '.ini', '.env',
    
    # Documentation
    '.md', '.rst', '.txt'
}

# Files to always ignore
IGNORE_PATTERNS = {
    # Build outputs
    'build/*', 'dist/*', 'target/*', 'bin/*',
    '*.pyc', '__pycache__/*', '*.class',
    
    # Dependencies
    'node_modules/*', 'vendor/*', 'venv/*',
    
    # IDE files
    '.idea/*', '.vscode/*', '*.swp',
    
    # Package files
    'package-lock.json', 'yarn.lock',
    'Pipfile.lock', 'poetry.lock',
    
    # Large data files
    '*.csv', '*.json.gz', '*.sql',
    
    # Binary/Media files
    '*.pdf', '*.jpg', '*.png', '*.gif',
    '*.mp3', '*.mp4', '*.mov', '*.bin',
    '*.exe', '*.dll', '*.so', '*.dylib'
}


# File: pyproject.toml
================================================================================

[project]
name = "repl-nix-workspace"
version = "0.1.0"
description = "Add your description here"
requires-python = ">=3.11"
dependencies = [
    "gitignore-parser>=0.1.11",
]


# File: concatenated_source.txt
================================================================================


# Project Source Code Concatenation
# Generated on: 2025-02-15 21:22:24
# Project path: /home/runner/workspace

Directory Structure:

├── README.md
├── concatenated_source.txt
├── extensions.py
├── git_concatenator.py
└── pyproject.toml

================================================================================



# File: extensions.py
================================================================================

"""
Source code file extension configurations
"""

# Common source code file extensions
SOURCE_EXTENSIONS = {
    # Web
    '.js', '.ts', '.jsx', '.tsx', '.vue', '.svelte',
    '.html', '.htm', '.css', '.scss', '.sass', '.less',
    
    # Python
    '.py', '.pyi', '.pyx',
    
    # Java/Kotlin
    '.java', '.kt', '.groovy',
    
    # C-family
    '.c', '.cpp', '.h', '.hpp', '.cc',
    
    # C#
    '.cs', '.cshtml', '.csx',
    
    # Ruby
    '.rb', '.erb',
    
    # PHP
    '.php', '.php5', '.phtml',
    
    # Go
    '.go',
    
    # Rust
    '.rs',
    
    # Swift
    '.swift',
    
    # Shell
    '.sh', '.bash', '.zsh',
    
    # Config/Data
    '.json', '.yaml', '.yml', '.toml', '.xml',
    '.conf', '.ini', '.env',
    
    # Documentation
    '.md', '.rst', '.txt'
}

# Files to always ignore
IGNORE_PATTERNS = {
    # Build outputs
    'build/*', 'dist/*', 'target/*', 'bin/*',
    '*.pyc', '__pycache__/*', '*.class',
    
    # Dependencies
    'node_modules/*', 'vendor/*', 'venv/*',
    
    # IDE files
    '.idea/*', '.vscode/*', '*.swp',
    
    # Package files
    'package-lock.json', 'yarn.lock',
    'Pipfile.lock', 'poetry.lock',
    
    # Large data files
    '*.csv', '*.json.gz', '*.sql',
    
    # Binary/Media files
    '*.pdf', '*.jpg', '*.png', '*.gif',
    '*.mp3', '*.mp4', '*.mov', '*.bin',
    '*.exe', '*.dll', '*.so', '*.dylib'
}


# File: pyproject.toml
================================================================================

[project]
name = "repl-nix-workspace"
version = "0.1.0"
description = "Add your description here"
requires-python = ">=3.11"
dependencies = [
    "gitignore-parser>=0.1.11",
]


# File: concatenated_source.txt
================================================================================



# File: git_concatenator.py
================================================================================

#!/usr/bin/env python3
"""
Git Project Source Code Concatenator

This tool concatenates source code files from a git project into a single file,
including directory structure information.
"""

import argparse
import sys
from pathlib import Path
import os
from typing import Set, List, Optional
import fnmatch
from datetime import datetime
import gitignore_parser
from extensions import SOURCE_EXTENSIONS, IGNORE_PATTERNS

class GitConcatenator:
    def __init__(self, project_path: str, output_file: str):
        self.project_path = Path(project_path).resolve()
        self.output_file = Path(output_file)
        self.gitignore_matcher = self._setup_gitignore()
        self.debug = False

    def _setup_gitignore(self) -> Optional[callable]:
        """Setup gitignore matcher if .gitignore exists"""
        gitignore_path = self.project_path / '.gitignore'
        if gitignore_path.exists():
            try:
                return gitignore_parser.parse_gitignore(gitignore_path)
            except Exception as e:
                print(f"Warning: Failed to parse .gitignore: {e}")
        return None

    def _should_include_file(self, file_path: Path) -> bool:
        """Check if file should be included based on extension and ignore rules"""
        # Skip common virtual environment and system directories
        excluded_dirs = {
            '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
            '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
            'dist', 'build', 'target'
        }

        try:
            # Convert to relative path for checking
            try:
                rel_path = file_path.relative_to(self.project_path)
            except ValueError:
                if self.debug:
                    print(f"Debug: Skipping file outside project path: {file_path}")
                return False

            # Check for excluded directories in the path
            if any(part in excluded_dirs for part in file_path.parts):
                if self.debug:
                    print(f"Debug: Skipping excluded directory: {file_path}")
                return False

            # Check if file extension is in whitelist
            if file_path.suffix.lower() not in SOURCE_EXTENSIONS:
                if self.debug:
                    print(f"Debug: Skipping non-source file: {file_path}")
                return False

            # Check custom ignore patterns
            for pattern in IGNORE_PATTERNS:
                if fnmatch.fnmatch(str(rel_path), pattern):
                    if self.debug:
                        print(f"Debug: Skipping ignored pattern {pattern}: {file_path}")
                    return False

            # Check .gitignore if available
            if self.gitignore_matcher:
                try:
                    should_include = not self.gitignore_matcher(str(file_path))
                    if self.debug and not should_include:
                        print(f"Debug: Skipping gitignored file: {file_path}")
                    return should_include
                except Exception as e:
                    print(f"Warning: gitignore matching failed for {file_path}: {e}")
                    return True

            if self.debug:
                print(f"Debug: Including file: {file_path}")
            return True

        except Exception as e:
            print(f"Warning: Error checking file {file_path}: {e}")
            return False

    def _get_file_content(self, file_path: Path) -> str:
        """Read file content with proper encoding handling"""
        try:
            # Try UTF-8 first
            with open(file_path, 'r', encoding='utf-8') as f:
                return f.read()
        except UnicodeDecodeError:
            try:
                # Fallback to latin-1
                with open(file_path, 'r', encoding='latin-1') as f:
                    return f.read()
            except Exception as e:
                print(f"Warning: Failed to read {file_path}: {e}")
                return f"ERROR: Could not read file {file_path}\n"

    def _generate_directory_structure(self) -> str:
        """Generate a tree-like directory structure"""
        structure = ["Directory Structure:", ""]

        def add_to_tree(path: Path, prefix: str = ""):
            # Skip excluded directories
            excluded_dirs = {
                '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
                '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
                'dist', 'build', 'target'
            }
            if path.name in excluded_dirs:
                return

            # Add files first
            files = sorted([p for p in path.iterdir() if p.is_file()])
            included_files = [f for f in files if self._should_include_file(f)]

            for idx, file in enumerate(included_files):
                is_last = idx == len(included_files) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {file.name}")

            # Then add directories
            dirs = sorted([p for p in path.iterdir() if p.is_dir()])
            included_dirs = [d for d in dirs if d.name not in excluded_dirs]

            for idx, dir in enumerate(included_dirs):
                is_last = idx == len(included_dirs) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {dir.name}/")
                add_to_tree(dir, prefix + ("    " if is_last else "│   "))

        add_to_tree(self.project_path)
        return "\n".join(structure)

    def concatenate(self, debug: bool = False):
        """Main method to concatenate all source files"""
        self.debug = debug
        if not self.project_path.exists():
            print(f"Error: Project path {self.project_path} does not exist")
            return False

        try:
            with open(self.output_file, 'w', encoding='utf-8') as out:
                # Write header
                header = f"""
# Project Source Code Concatenation
# Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
# Project path: {self.project_path}

"""
                out.write(header)

                # Write directory structure
                out.write(self._generate_directory_structure())
                out.write("\n\n" + "="*80 + "\n\n")

                # Process all files
                file_count = 0
                for file_path in self.project_path.rglob('*'):
                    if file_path.is_file() and self._should_include_file(file_path):
                        rel_path = file_path.relative_to(self.project_path)

                        # Write file header
                        out.write(f"\n\n# File: {rel_path}\n")
                        out.write("="*80 + "\n\n")

                        # Write file content
                        content = self._get_file_content(file_path)
                        out.write(content)
                        file_count += 1

                print(f"Successfully concatenated {file_count} files to {self.output_file}")
                return True

        except Exception as e:
            print(f"Error during concatenation: {e}")
            return False

def main():
    parser = argparse.ArgumentParser(
        description="Concatenate git project source code into a single file"
    )
    parser.add_argument(
        "project_path",
        help="Path to the git project directory"
    )
    parser.add_argument(
        "-o", "--output",
        default="concatenated_source.txt",
        help="Output file path (default: concatenated_source.txt)"
    )
    parser.add_argument(
        "-d", "--debug",
        action="store_true",
        help="Enable debug logging"
    )

    args = parser.parse_args()

    concatenator = GitConcatenator(args.project_path, args.output)
    success = concatenator.concatenate(debug=args.debug)
    sys.exit(0 if success else 1)

if __name__ == "__main__":
    main()

# File: README.md
================================================================================

git clone https://github.com/yourusername/git-concatenator.git
   cd git-concatenator
   ```

2. Ensure you have Python 3.11 or later installed:
   ```bash
   python --version
   ```

3. Install the required dependency:
   ```bash
   pip install gitignore-parser
   ```

## Usage

Basic usage:
```bash
python git_concatenator.py /path/to/project -o output.txt
```

With debug logging:
```bash
python git_concatenator.py /path/to/project -o output.txt --debug
```

### Command-line Arguments

- `project_path`: Path to the Git project directory (required)
- `-o, --output`: Output file path (default: concatenated_source.txt)
- `-d, --debug`: Enable debug logging

## Output Format

The generated file includes:
1. A timestamp and project path header
2. A visual directory structure of the project
3. The contents of each source file, clearly separated with headers

Example output:
```
# Project Source Code Concatenation
# Generated on: 2025-02-15 20:53:29
# Project path: /path/to/project

Directory Structure:
├── src/
│   ├── main.py
│   └── utils.py
└── README.md

================================================================================

# File: src/main.py
================================================================================
[File contents here]

# File: src/utils.py
================================================================================
[File contents here]

# File: codesmelt.py
================================================================================

#!/usr/bin/env python3
"""
CodeSmelt: Source Code Concatenator

This tool melts down source code files from a git project into a single file,
including directory structure information.
"""

import argparse
import sys
from pathlib import Path
import os
from typing import Set, List, Optional
import fnmatch
from datetime import datetime
import gitignore_parser
from extensions import SOURCE_EXTENSIONS, IGNORE_PATTERNS

class CodeSmelt:
    def __init__(self, project_path: str, output_file: str):
        self.project_path = Path(project_path).resolve()
        self.output_file = Path(output_file)
        self.gitignore_matcher = self._setup_gitignore()
        self.debug = False

    def _setup_gitignore(self) -> Optional[callable]:
        """Setup gitignore matcher if .gitignore exists"""
        gitignore_path = self.project_path / '.gitignore'
        if gitignore_path.exists():
            try:
                return gitignore_parser.parse_gitignore(gitignore_path)
            except Exception as e:
                print(f"Warning: Failed to parse .gitignore: {e}")
        return None

    def _should_include_file(self, file_path: Path) -> bool:
        """Check if file should be included based on extension and ignore rules"""
        # Skip common virtual environment and system directories
        excluded_dirs = {
            '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
            '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
            'dist', 'build', 'target'
        }

        try:
            # Convert to relative path for checking
            try:
                rel_path = file_path.relative_to(self.project_path)
            except ValueError:
                if self.debug:
                    print(f"Debug: Skipping file outside project path: {file_path}")
                return False

            # Check for excluded directories in the path
            if any(part in excluded_dirs for part in file_path.parts):
                if self.debug:
                    print(f"Debug: Skipping excluded directory: {file_path}")
                return False

            # Check if file extension is in whitelist
            if file_path.suffix.lower() not in SOURCE_EXTENSIONS:
                if self.debug:
                    print(f"Debug: Skipping non-source file: {file_path}")
                return False

            # Check custom ignore patterns
            for pattern in IGNORE_PATTERNS:
                if fnmatch.fnmatch(str(rel_path), pattern):
                    if self.debug:
                        print(f"Debug: Skipping ignored pattern {pattern}: {file_path}")
                    return False

            # Check .gitignore if available
            if self.gitignore_matcher:
                try:
                    should_include = not self.gitignore_matcher(str(file_path))
                    if self.debug and not should_include:
                        print(f"Debug: Skipping gitignored file: {file_path}")
                    return should_include
                except Exception as e:
                    print(f"Warning: gitignore matching failed for {file_path}: {e}")
                    return True

            if self.debug:
                print(f"Debug: Including file: {file_path}")
            return True

        except Exception as e:
            print(f"Warning: Error checking file {file_path}: {e}")
            return False

    def _get_file_content(self, file_path: Path) -> str:
        """Read file content with proper encoding handling"""
        try:
            # Try UTF-8 first
            with open(file_path, 'r', encoding='utf-8') as f:
                return f.read()
        except UnicodeDecodeError:
            try:
                # Fallback to latin-1
                with open(file_path, 'r', encoding='latin-1') as f:
                    return f.read()
            except Exception as e:
                print(f"Warning: Failed to read {file_path}: {e}")
                return f"ERROR: Could not read file {file_path}\n"

    def _generate_directory_structure(self) -> str:
        """Generate a tree-like directory structure"""
        structure = ["Directory Structure:", ""]

        def add_to_tree(path: Path, prefix: str = ""):
            # Skip excluded directories
            excluded_dirs = {
                '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
                '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
                'dist', 'build', 'target'
            }
            if path.name in excluded_dirs:
                return

            # Add files first
            files = sorted([p for p in path.iterdir() if p.is_file()])
            included_files = [f for f in files if self._should_include_file(f)]

            for idx, file in enumerate(included_files):
                is_last = idx == len(included_files) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {file.name}")

            # Then add directories
            dirs = sorted([p for p in path.iterdir() if p.is_dir()])
            included_dirs = [d for d in dirs if d.name not in excluded_dirs]

            for idx, dir in enumerate(included_dirs):
                is_last = idx == len(included_dirs) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {dir.name}/")
                add_to_tree(dir, prefix + ("    " if is_last else "│   "))

        add_to_tree(self.project_path)
        return "\n".join(structure)

    def concatenate(self, debug: bool = False):
        """Main method to concatenate all source files"""
        self.debug = debug
        if not self.project_path.exists():
            print(f"Error: Project path {self.project_path} does not exist")
            return False

        try:
            with open(self.output_file, 'w', encoding='utf-8') as out:
                # Write header
                header = f"""
# Project Source Code Concatenation
# Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
# Project path: {self.project_path}

"""
                out.write(header)

                # Write directory structure
                out.write(self._generate_directory_structure())
                out.write("\n\n" + "="*80 + "\n\n")

                # Process all files
                file_count = 0
                for file_path in self.project_path.rglob('*'):
                    if file_path.is_file() and self._should_include_file(file_path):
                        rel_path = file_path.relative_to(self.project_path)

                        # Write file header
                        out.write(f"\n\n# File: {rel_path}\n")
                        out.write("="*80 + "\n\n")

                        # Write file content
                        content = self._get_file_content(file_path)
                        out.write(content)
                        file_count += 1

                print(f"Successfully melted {file_count} files to {self.output_file}")
                return True

        except Exception as e:
            print(f"Error during melting: {e}")
            return False

def main():
    parser = argparse.ArgumentParser(
        description="CodeSmelt: Melt down your git project's source code into a single file"
    )
    parser.add_argument(
        "project_path",
        help="Path to the git project directory"
    )
    parser.add_argument(
        "-o", "--output",
        default="concatenated_source.txt",
        help="Output file path (default: concatenated_source.txt)"
    )
    parser.add_argument(
        "-d", "--debug",
        action="store_true",
        help="Enable debug logging"
    )

    args = parser.parse_args()

    concatenator = CodeSmelt(args.project_path, args.output)
    success = concatenator.concatenate(debug=args.debug)
    sys.exit(0 if success else 1)

if __name__ == "__main__":
    main()

# File: README.md
================================================================================

python --version
   ```

2. Install the required dependency:
   ```bash
   pip install gitignore-parser
   ```

## Usage

Basic usage:
```bash
python codesmelt.py /path/to/project -o output.txt
```

With debug logging:
```bash
python codesmelt.py /path/to/project -o output.txt --debug
```

### Command-line Arguments

- `project_path`: Path to the Git project directory (required)
- `-o, --output`: Output file path (default: concatenated_source.txt)
- `-d, --debug`: Enable debug logging

## Configuration

### Source File Extensions
The tool includes common source code file extensions by default (defined in `extensions.py`):
- Web: `.js`, `.ts`, `.jsx`, `.tsx`, `.vue`, `.svelte`, `.html`, `.css`, etc.
- Python: `.py`, `.pyi`, `.pyx`
- Java/Kotlin: `.java`, `.kt`, `.groovy`
- C-family: `.c`, `.cpp`, `.h`, `.hpp`
- And many more...

#### Customizing File Extensions
You can modify which file extensions are included by editing the `SOURCE_EXTENSIONS` set in `extensions.py`. For example, to include Unity3D script files while excluding other Unity files:

```python
SOURCE_EXTENSIONS = {
    # ... existing extensions ...

    # Unity3D specific
    '.cs',  # C# scripts
    '.shader', # Custom shaders
    '.asmdef', # Assembly definitions

    # ... other extensions ...
}
```

### Ignore Patterns
The tool automatically ignores files based on three levels:

1. Built-in patterns (`IGNORE_PATTERNS` in `extensions.py`):
   - Build outputs (`build/*`, `dist/*`, `*.pyc`, etc.)
   - Dependencies (`node_modules/*`, `vendor/*`, `venv/*`)
   - IDE files (`.idea/*`, `.vscode/*`)
   - Package lock files (`package-lock.json`, `poetry.lock`, etc.)
   - Binary and media files (`*.pdf`, `*.jpg`, `*.exe`, etc.)

2. Project's `.gitignore` rules (if present)
3. Directory-specific `.gitignore` rules

#### Customizing Ignore Patterns
To modify which files are ignored, you can:

1. Edit `IGNORE_PATTERNS` in `extensions.py`:
```python
IGNORE_PATTERNS = {
    # ... existing patterns ...

    # Unity3D specific ignores
    'Assets/AssetStoreTools/*',
    'Library/*',
    'Temp/*',
    'Logs/*',
    '*.unity',  # Unity scene files
    '*.meta',   # Unity meta files
    '*.prefab', # Unity prefab files

    # ... other patterns ...
}
```

2. Use your project's `.gitignore` file for project-specific exclusions

**Note**: Ignore patterns follow the same syntax as `.gitignore` files. The tool processes these rules in order:
1. Built-in `IGNORE_PATTERNS`
2. Project's root `.gitignore`
3. Directory-specific `.gitignore` files


## Tips for Using with LLMs

1. **Token Management**:
   - For large projects, consider concatenating only specific directories
   - Use the debug mode to see which files are included/excluded
   - Remove unnecessary documentation files if you're close to token limits

2. **Effective Prompting**:
   - Reference files using their relative paths as shown in the directory structure
   - Use the directory structure to ask about specific components
   - Refer to file relationships based on the visual structure

3. **Best Practices**:
   - Review the concatenated output before sending to ensure relevance
   - For large projects, break down analysis into smaller, focused components
   - Use the debug mode to verify file selection when customizing

## Output Format

The generated file includes:
1. A timestamp and project path header
2. A visual directory structure of the project
3. The contents of each source file, clearly separated with headers

Example output:
```
# Project Source Code Concatenation
# Generated on: 2025-02-15 20:53:29
# Project path: /path/to/project

Directory Structure:
├── src/
│   ├── main.py
│   └── utils.py
└── README.md

================================================================================

# File: src/main.py
================================================================================
[File contents here]

# File: src/utils.py
================================================================================
[File contents here]
```

## Troubleshooting

### Common Issues

1. **No Files Found**:
   - Verify the project path is correct
   - Check if files have supported extensions
   - Run with --debug to see which files are being filtered

2. **Missing Dependencies**:
   ```bash
   pip install --upgrade gitignore-parser

# File: codesmelt.py
================================================================================

#!/usr/bin/env python3
"""
CodeSmelt: Source Code Concatenator

This tool melts down source code files from a git project into a single file,
including directory structure information.
"""

import argparse
import sys
from pathlib import Path
import os
from typing import Set, List, Optional
import fnmatch
from datetime import datetime
import gitignore_parser
from extensions import SOURCE_EXTENSIONS, IGNORE_PATTERNS

class CodeSmelt:
    def __init__(self, project_path: str, output_file: str):
        self.project_path = Path(project_path).resolve()
        self.output_file = Path(output_file)
        self.gitignore_matcher = self._setup_gitignore()
        self.debug = False

    def _setup_gitignore(self) -> Optional[callable]:
        """Setup gitignore matcher if .gitignore exists"""
        gitignore_path = self.project_path / '.gitignore'
        if gitignore_path.exists():
            try:
                return gitignore_parser.parse_gitignore(gitignore_path)
            except Exception as e:
                print(f"Warning: Failed to parse .gitignore: {e}")
        return None

    def _should_include_file(self, file_path: Path) -> bool:
        """Check if file should be included based on extension and ignore rules"""
        # Skip common virtual environment and system directories
        excluded_dirs = {
            '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
            '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
            'dist', 'build', 'target'
        }

        try:
            # Convert to relative path for checking
            try:
                rel_path = file_path.relative_to(self.project_path)
            except ValueError:
                if self.debug:
                    print(f"Debug: Skipping file outside project path: {file_path}")
                return False

            # Check for excluded directories in the path
            if any(part in excluded_dirs for part in file_path.parts):
                if self.debug:
                    print(f"Debug: Skipping excluded directory: {file_path}")
                return False

            # Check if file extension is in whitelist
            if file_path.suffix.lower() not in SOURCE_EXTENSIONS:
                if self.debug:
                    print(f"Debug: Skipping non-source file: {file_path}")
                return False

            # Check custom ignore patterns
            for pattern in IGNORE_PATTERNS:
                if fnmatch.fnmatch(str(rel_path), pattern):
                    if self.debug:
                        print(f"Debug: Skipping ignored pattern {pattern}: {file_path}")
                    return False

            # Check .gitignore if available
            if self.gitignore_matcher:
                try:
                    should_include = not self.gitignore_matcher(str(file_path))
                    if self.debug and not should_include:
                        print(f"Debug: Skipping gitignored file: {file_path}")
                    return should_include
                except Exception as e:
                    print(f"Warning: gitignore matching failed for {file_path}: {e}")
                    return True

            if self.debug:
                print(f"Debug: Including file: {file_path}")
            return True

        except Exception as e:
            print(f"Warning: Error checking file {file_path}: {e}")
            return False

    def _get_file_content(self, file_path: Path) -> str:
        """Read file content with proper encoding handling"""
        try:
            # Try UTF-8 first
            with open(file_path, 'r', encoding='utf-8') as f:
                return f.read()
        except UnicodeDecodeError:
            try:
                # Fallback to latin-1
                with open(file_path, 'r', encoding='latin-1') as f:
                    return f.read()
            except Exception as e:
                print(f"Warning: Failed to read {file_path}: {e}")
                return f"ERROR: Could not read file {file_path}\n"

    def _generate_directory_structure(self) -> str:
        """Generate a tree-like directory structure"""
        structure = ["Directory Structure:", ""]

        def add_to_tree(path: Path, prefix: str = ""):
            # Skip excluded directories
            excluded_dirs = {
                '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
                '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
                'dist', 'build', 'target'
            }
            if path.name in excluded_dirs:
                return

            # Add files first
            files = sorted([p for p in path.iterdir() if p.is_file()])
            included_files = [f for f in files if self._should_include_file(f)]

            for idx, file in enumerate(included_files):
                is_last = idx == len(included_files) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {file.name}")

            # Then add directories
            dirs = sorted([p for p in path.iterdir() if p.is_dir()])
            included_dirs = [d for d in dirs if d.name not in excluded_dirs]

            for idx, dir in enumerate(included_dirs):
                is_last = idx == len(included_dirs) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {dir.name}/")
                add_to_tree(dir, prefix + ("    " if is_last else "│   "))

        add_to_tree(self.project_path)
        return "\n".join(structure)

    def concatenate(self, debug: bool = False):
        """Main method to concatenate all source files"""
        self.debug = debug
        if not self.project_path.exists():
            print(f"Error: Project path {self.project_path} does not exist")
            return False

        try:
            with open(self.output_file, 'w', encoding='utf-8') as out:
                # Write header
                header = f"""
# Project Source Code Concatenation
# Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
# Project path: {self.project_path}

"""
                out.write(header)

                # Write directory structure
                out.write(self._generate_directory_structure())
                out.write("\n\n" + "="*80 + "\n\n")

                # Process all files
                file_count = 0
                for file_path in self.project_path.rglob('*'):
                    if file_path.is_file() and self._should_include_file(file_path):
                        rel_path = file_path.relative_to(self.project_path)

                        # Write file header
                        out.write(f"\n\n# File: {rel_path}\n")
                        out.write("="*80 + "\n\n")

                        # Write file content
                        content = self._get_file_content(file_path)
                        out.write(content)
                        file_count += 1

                print(f"Successfully melted {file_count} files to {self.output_file}")
                return True

        except Exception as e:
            print(f"Error during melting: {e}")
            return False

def main():
    parser = argparse.ArgumentParser(
        description="CodeSmelt: Melt down your git project's source code into a single file",
        usage="%(prog)s [-o OUTPUT] [-d] project_path"
    )
    parser.add_argument(
        "-o", "--output",
        default="concatenated_source.txt",
        help="Output file path (default: concatenated_source.txt)"
    )
    parser.add_argument(
        "-d", "--debug",
        action="store_true",
        help="Enable debug logging"
    )
    parser.add_argument(
        "project_path",
        help="Path to the git project directory",
        nargs="?"  # Make it optional in the parser (though we'll check it's provided)
    )

    args = parser.parse_args()

    if not args.project_path:
        parser.error("project_path is required")

    concatenator = CodeSmelt(args.project_path, args.output)
    success = concatenator.concatenate(debug=args.debug)
    sys.exit(0 if success else 1)

if __name__ == "__main__":
    main()

# File: README.md
================================================================================

python codesmelt.py /path/to/project
```

Specify custom output file:
```bash
python codesmelt.py -o output.txt /path/to/project
```

With debug logging:
```bash
python codesmelt.py -d -o output.txt /path/to/project
```

### Command-line Arguments
- `project_path`: Path to the Git project directory (required)
- `-o, --output`: Output file path (default: concatenated_source.txt)
- `-d, --debug`: Enable debug logging

## Configuration

### Source File Extensions
The tool includes common source code file extensions by default (defined in `extensions.py`):
- Web: `.js`, `.ts`, `.jsx`, `.tsx`, `.vue`, `.svelte`, `.html`, `.css`, etc.
- Python: `.py`, `.pyi`, `.pyx`
- Java/Kotlin: `.java`, `.kt`, `.groovy`
- C-family: `.c`, `.cpp`, `.h`, `.hpp`
- And many more...

#### Customizing File Extensions
You can modify which file extensions are included by editing the `SOURCE_EXTENSIONS` set in `extensions.py`. For example, to include Unity3D script files while excluding other Unity files:

```python
SOURCE_EXTENSIONS = {
    # ... existing extensions ...

    # Unity3D specific
    '.cs',  # C# scripts
    '.shader', # Custom shaders
    '.asmdef', # Assembly definitions

    # ... other extensions ...
}
```

### Ignore Patterns
The tool automatically ignores files based on three levels:

1. Built-in patterns (`IGNORE_PATTERNS` in `extensions.py`):
   - Build outputs (`build/*`, `dist/*`, `*.pyc`, etc.)
   - Dependencies (`node_modules/*`, `vendor/*`, `venv/*`)
   - IDE files (`.idea/*`, `.vscode/*`)
   - Package lock files (`package-lock.json`, `poetry.lock`, etc.)
   - Binary and media files (`*.pdf`, `*.jpg`, `*.exe`, etc.)

2. Project's `.gitignore` rules (if present)
3. Directory-specific `.gitignore` rules

#### Customizing Ignore Patterns
To modify which files are ignored, you can:

1. Edit `IGNORE_PATTERNS` in `extensions.py`:
```python
IGNORE_PATTERNS = {
    # ... existing patterns ...

    # Unity3D specific ignores
    'Assets/AssetStoreTools/*',
    'Library/*',
    'Temp/*',
    'Logs/*',
    '*.unity',  # Unity scene files
    '*.meta',   # Unity meta files
    '*.prefab', # Unity prefab files

    # ... other patterns ...
}
```

2. Use your project's `.gitignore` file for project-specific exclusions

**Note**: Ignore patterns follow the same syntax as `.gitignore` files. The tool processes these rules in order:
1. Built-in `IGNORE_PATTERNS`
2. Project's root `.gitignore`
3. Directory-specific `.gitignore` files


## Tips for Using with LLMs

1. **Token Management**:
   - For large projects, consider concatenating only specific directories
   - Use the debug mode to see which files are included/excluded
   - Remove unnecessary documentation files if you're close to token limits

2. **Effective Prompting**:
   - Reference files using their relative paths as shown in the directory structure
   - Use the directory structure to ask about specific components
   - Refer to file relationships based on the visual structure

3. **Best Practices**:
   - Review the concatenated output before sending to ensure relevance
   - For large projects, break down analysis into smaller, focused components
   - Use the debug mode to verify file selection when customizing

## Output Format

The generated file includes:
1. A timestamp and project path header
2. A visual directory structure of the project
3. The contents of each source file, clearly separated with headers

Example output:
```
# Project Source Code Concatenation
# Generated on: 2025-02-15 20:53:29
# Project path: /path/to/project

Directory Structure:
├── src/
│   ├── main.py
│   └── utils.py
└── README.md

================================================================================

# File: src/main.py
================================================================================
[File contents here]

# File: src/utils.py
================================================================================
[File contents here]
```

## Troubleshooting

### Common Issues

1. **No Files Found**:
   - Verify the project path is correct
   - Check if files have supported extensions
   - Run with --debug to see which files are being filtered

2. **Missing Dependencies**:
   ```bash
   pip install --upgrade gitignore-parser

# File: output.txt
================================================================================


# Project Source Code Concatenation
# Generated on: 2025-02-15 22:44:33
# Project path: /home/runner/workspace

Directory Structure:

├── README.md
├── codesmelt.py
├── concatenated_source.txt
├── extensions.py
├── output.txt
└── pyproject.toml

================================================================================



# File: extensions.py
================================================================================

"""
Source code file extension configurations
"""

# Common source code file extensions
SOURCE_EXTENSIONS = {
    # Web
    '.js', '.ts', '.jsx', '.tsx', '.vue', '.svelte',
    '.html', '.htm', '.css', '.scss', '.sass', '.less',
    
    # Python
    '.py', '.pyi', '.pyx',
    
    # Java/Kotlin
    '.java', '.kt', '.groovy',
    
    # C-family
    '.c', '.cpp', '.h', '.hpp', '.cc',
    
    # C#
    '.cs', '.cshtml', '.csx',
    
    # Ruby
    '.rb', '.erb',
    
    # PHP
    '.php', '.php5', '.phtml',
    
    # Go
    '.go',
    
    # Rust
    '.rs',
    
    # Swift
    '.swift',
    
    # Shell
    '.sh', '.bash', '.zsh',
    
    # Config/Data
    '.json', '.yaml', '.yml', '.toml', '.xml',
    '.conf', '.ini', '.env',
    
    # Documentation
    '.md', '.rst', '.txt'
}

# Files to always ignore
IGNORE_PATTERNS = {
    # Build outputs
    'build/*', 'dist/*', 'target/*', 'bin/*',
    '*.pyc', '__pycache__/*', '*.class',
    
    # Dependencies
    'node_modules/*', 'vendor/*', 'venv/*',
    
    # IDE files
    '.idea/*', '.vscode/*', '*.swp',
    
    # Package files
    'package-lock.json', 'yarn.lock',
    'Pipfile.lock', 'poetry.lock',
    
    # Large data files
    '*.csv', '*.json.gz', '*.sql',
    
    # Binary/Media files
    '*.pdf', '*.jpg', '*.png', '*.gif',
    '*.mp3', '*.mp4', '*.mov', '*.bin',
    '*.exe', '*.dll', '*.so', '*.dylib'
}


# File: pyproject.toml
================================================================================

[project]
name = "repl-nix-workspace"
version = "0.1.0"
description = "Add your description here"
requires-python = ">=3.11"
dependencies = [
    "gitignore-parser>=0.1.11",
]


# File: concatenated_source.txt
================================================================================


# Project Source Code Concatenation
# Generated on: 2025-02-15 21:22:24
# Project path: /home/runner/workspace

Directory Structure:

├── README.md
├── concatenated_source.txt
├── extensions.py
├── git_concatenator.py
└── pyproject.toml

================================================================================



# File: extensions.py
================================================================================

"""
Source code file extension configurations
"""

# Common source code file extensions
SOURCE_EXTENSIONS = {
    # Web
    '.js', '.ts', '.jsx', '.tsx', '.vue', '.svelte',
    '.html', '.htm', '.css', '.scss', '.sass', '.less',
    
    # Python
    '.py', '.pyi', '.pyx',
    
    # Java/Kotlin
    '.java', '.kt', '.groovy',
    
    # C-family
    '.c', '.cpp', '.h', '.hpp', '.cc',
    
    # C#
    '.cs', '.cshtml', '.csx',
    
    # Ruby
    '.rb', '.erb',
    
    # PHP
    '.php', '.php5', '.phtml',
    
    # Go
    '.go',
    
    # Rust
    '.rs',
    
    # Swift
    '.swift',
    
    # Shell
    '.sh', '.bash', '.zsh',
    
    # Config/Data
    '.json', '.yaml', '.yml', '.toml', '.xml',
    '.conf', '.ini', '.env',
    
    # Documentation
    '.md', '.rst', '.txt'
}

# Files to always ignore
IGNORE_PATTERNS = {
    # Build outputs
    'build/*', 'dist/*', 'target/*', 'bin/*',
    '*.pyc', '__pycache__/*', '*.class',
    
    # Dependencies
    'node_modules/*', 'vendor/*', 'venv/*',
    
    # IDE files
    '.idea/*', '.vscode/*', '*.swp',
    
    # Package files
    'package-lock.json', 'yarn.lock',
    'Pipfile.lock', 'poetry.lock',
    
    # Large data files
    '*.csv', '*.json.gz', '*.sql',
    
    # Binary/Media files
    '*.pdf', '*.jpg', '*.png', '*.gif',
    '*.mp3', '*.mp4', '*.mov', '*.bin',
    '*.exe', '*.dll', '*.so', '*.dylib'
}


# File: pyproject.toml
================================================================================

[project]
name = "repl-nix-workspace"
version = "0.1.0"
description = "Add your description here"
requires-python = ">=3.11"
dependencies = [
    "gitignore-parser>=0.1.11",
]


# File: concatenated_source.txt
================================================================================



# File: git_concatenator.py
================================================================================

#!/usr/bin/env python3
"""
Git Project Source Code Concatenator

This tool concatenates source code files from a git project into a single file,
including directory structure information.
"""

import argparse
import sys
from pathlib import Path
import os
from typing import Set, List, Optional
import fnmatch
from datetime import datetime
import gitignore_parser
from extensions import SOURCE_EXTENSIONS, IGNORE_PATTERNS

class GitConcatenator:
    def __init__(self, project_path: str, output_file: str):
        self.project_path = Path(project_path).resolve()
        self.output_file = Path(output_file)
        self.gitignore_matcher = self._setup_gitignore()
        self.debug = False

    def _setup_gitignore(self) -> Optional[callable]:
        """Setup gitignore matcher if .gitignore exists"""
        gitignore_path = self.project_path / '.gitignore'
        if gitignore_path.exists():
            try:
                return gitignore_parser.parse_gitignore(gitignore_path)
            except Exception as e:
                print(f"Warning: Failed to parse .gitignore: {e}")
        return None

    def _should_include_file(self, file_path: Path) -> bool:
        """Check if file should be included based on extension and ignore rules"""
        # Skip common virtual environment and system directories
        excluded_dirs = {
            '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
            '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
            'dist', 'build', 'target'
        }

        try:
            # Convert to relative path for checking
            try:
                rel_path = file_path.relative_to(self.project_path)
            except ValueError:
                if self.debug:
                    print(f"Debug: Skipping file outside project path: {file_path}")
                return False

            # Check for excluded directories in the path
            if any(part in excluded_dirs for part in file_path.parts):
                if self.debug:
                    print(f"Debug: Skipping excluded directory: {file_path}")
                return False

            # Check if file extension is in whitelist
            if file_path.suffix.lower() not in SOURCE_EXTENSIONS:
                if self.debug:
                    print(f"Debug: Skipping non-source file: {file_path}")
                return False

            # Check custom ignore patterns
            for pattern in IGNORE_PATTERNS:
                if fnmatch.fnmatch(str(rel_path), pattern):
                    if self.debug:
                        print(f"Debug: Skipping ignored pattern {pattern}: {file_path}")
                    return False

            # Check .gitignore if available
            if self.gitignore_matcher:
                try:
                    should_include = not self.gitignore_matcher(str(file_path))
                    if self.debug and not should_include:
                        print(f"Debug: Skipping gitignored file: {file_path}")
                    return should_include
                except Exception as e:
                    print(f"Warning: gitignore matching failed for {file_path}: {e}")
                    return True

            if self.debug:
                print(f"Debug: Including file: {file_path}")
            return True

        except Exception as e:
            print(f"Warning: Error checking file {file_path}: {e}")
            return False

    def _get_file_content(self, file_path: Path) -> str:
        """Read file content with proper encoding handling"""
        try:
            # Try UTF-8 first
            with open(file_path, 'r', encoding='utf-8') as f:
                return f.read()
        except UnicodeDecodeError:
            try:
                # Fallback to latin-1
                with open(file_path, 'r', encoding='latin-1') as f:
                    return f.read()
            except Exception as e:
                print(f"Warning: Failed to read {file_path}: {e}")
                return f"ERROR: Could not read file {file_path}\n"

    def _generate_directory_structure(self) -> str:
        """Generate a tree-like directory structure"""
        structure = ["Directory Structure:", ""]

        def add_to_tree(path: Path, prefix: str = ""):
            # Skip excluded directories
            excluded_dirs = {
                '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
                '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
                'dist', 'build', 'target'
            }
            if path.name in excluded_dirs:
                return

            # Add files first
            files = sorted([p for p in path.iterdir() if p.is_file()])
            included_files = [f for f in files if self._should_include_file(f)]

            for idx, file in enumerate(included_files):
                is_last = idx == len(included_files) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {file.name}")

            # Then add directories
            dirs = sorted([p for p in path.iterdir() if p.is_dir()])
            included_dirs = [d for d in dirs if d.name not in excluded_dirs]

            for idx, dir in enumerate(included_dirs):
                is_last = idx == len(included_dirs) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {dir.name}/")
                add_to_tree(dir, prefix + ("    " if is_last else "│   "))

        add_to_tree(self.project_path)
        return "\n".join(structure)

    def concatenate(self, debug: bool = False):
        """Main method to concatenate all source files"""
        self.debug = debug
        if not self.project_path.exists():
            print(f"Error: Project path {self.project_path} does not exist")
            return False

        try:
            with open(self.output_file, 'w', encoding='utf-8') as out:
                # Write header
                header = f"""
# Project Source Code Concatenation
# Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
# Project path: {self.project_path}

"""
                out.write(header)

                # Write directory structure
                out.write(self._generate_directory_structure())
                out.write("\n\n" + "="*80 + "\n\n")

                # Process all files
                file_count = 0
                for file_path in self.project_path.rglob('*'):
                    if file_path.is_file() and self._should_include_file(file_path):
                        rel_path = file_path.relative_to(self.project_path)

                        # Write file header
                        out.write(f"\n\n# File: {rel_path}\n")
                        out.write("="*80 + "\n\n")

                        # Write file content
                        content = self._get_file_content(file_path)
                        out.write(content)
                        file_count += 1

                print(f"Successfully concatenated {file_count} files to {self.output_file}")
                return True

        except Exception as e:
            print(f"Error during concatenation: {e}")
            return False

def main():
    parser = argparse.ArgumentParser(
        description="Concatenate git project source code into a single file"
    )
    parser.add_argument(
        "project_path",
        help="Path to the git project directory"
    )
    parser.add_argument(
        "-o", "--output",
        default="concatenated_source.txt",
        help="Output file path (default: concatenated_source.txt)"
    )
    parser.add_argument(
        "-d", "--debug",
        action="store_true",
        help="Enable debug logging"
    )

    args = parser.parse_args()

    concatenator = GitConcatenator(args.project_path, args.output)
    success = concatenator.concatenate(debug=args.debug)
    sys.exit(0 if success else 1)

if __name__ == "__main__":
    main()

# File: README.md
================================================================================

git clone https://github.com/yourusername/git-concatenator.git
   cd git-concatenator
   ```

2. Ensure you have Python 3.11 or later installed:
   ```bash
   python --version
   ```

3. Install the required dependency:
   ```bash
   pip install gitignore-parser
   ```

## Usage

Basic usage:
```bash
python git_concatenator.py /path/to/project -o output.txt
```

With debug logging:
```bash
python git_concatenator.py /path/to/project -o output.txt --debug
```

### Command-line Arguments

- `project_path`: Path to the Git project directory (required)
- `-o, --output`: Output file path (default: concatenated_source.txt)
- `-d, --debug`: Enable debug logging

## Output Format

The generated file includes:
1. A timestamp and project path header
2. A visual directory structure of the project
3. The contents of each source file, clearly separated with headers

Example output:
```
# Project Source Code Concatenation
# Generated on: 2025-02-15 20:53:29
# Project path: /path/to/project

Directory Structure:
├── src/
│   ├── main.py
│   └── utils.py
└── README.md

================================================================================

# File: src/main.py
================================================================================
[File contents here]

# File: src/utils.py
================================================================================
[File contents here]

# File: output.txt
================================================================================


# Project Source Code Concatenation
# Generated on: 2025-02-15 22:44:33
# Project path: /home/runner/workspace

Directory Structure:

├── README.md
├── codesmelt.py
├── concatenated_source.txt
├── extensions.py
├── output.txt
└── pyproject.toml

================================================================================



# File: extensions.py
================================================================================

"""
Source code file extension configurations
"""

# Common source code file extensions
SOURCE_EXTENSIONS = {
    # Web
    '.js', '.ts', '.jsx', '.tsx', '.vue', '.svelte',
    '.html', '.htm', '.css', '.scss', '.sass', '.less',
    
    # Python
    '.py', '.pyi', '.pyx',
    
    # Java/Kotlin
    '.java', '.kt', '.groovy',
    
    # C-family
    '.c', '.cpp', '.h', '.hpp', '.cc',
    
    # C#
    '.cs', '.cshtml', '.csx',
    
    # Ruby
    '.rb', '.erb',
    
    # PHP
    '.php', '.php5', '.phtml',
    
    # Go
    '.go',
    
    # Rust
    '.rs',
    
    # Swift
    '.swift',
    
    # Shell
    '.sh', '.bash', '.zsh',
    
    # Config/Data
    '.json', '.yaml', '.yml', '.toml', '.xml',
    '.conf', '.ini', '.env',
    
    # Documentation
    '.md', '.rst', '.txt'
}

# Files to always ignore
IGNORE_PATTERNS = {
    # Build outputs
    'build/*', 'dist/*', 'target/*', 'bin/*',
    '*.pyc', '__pycache__/*', '*.class',
    
    # Dependencies
    'node_modules/*', 'vendor/*', 'venv/*',
    
    # IDE files
    '.idea/*', '.vscode/*', '*.swp',
    
    # Package files
    'package-lock.json', 'yarn.lock',
    'Pipfile.lock', 'poetry.lock',
    
    # Large data files
    '*.csv', '*.json.gz', '*.sql',
    
    # Binary/Media files
    '*.pdf', '*.jpg', '*.png', '*.gif',
    '*.mp3', '*.mp4', '*.mov', '*.bin',
    '*.exe', '*.dll', '*.so', '*.dylib'
}


# File: pyproject.toml
================================================================================

[project]
name = "repl-nix-workspace"
version = "0.1.0"
description = "Add your description here"
requires-python = ">=3.11"
dependencies = [
    "gitignore-parser>=0.1.11",
]


# File: concatenated_source.txt
================================================================================


# Project Source Code Concatenation
# Generated on: 2025-02-15 21:22:24
# Project path: /home/runner/workspace

Directory Structure:

├── README.md
├── concatenated_source.txt
├── extensions.py
├── git_concatenator.py
└── pyproject.toml

================================================================================



# File: extensions.py
================================================================================

"""
Source code file extension configurations
"""

# Common source code file extensions
SOURCE_EXTENSIONS = {
    # Web
    '.js', '.ts', '.jsx', '.tsx', '.vue', '.svelte',
    '.html', '.htm', '.css', '.scss', '.sass', '.less',
    
    # Python
    '.py', '.pyi', '.pyx',
    
    # Java/Kotlin
    '.java', '.kt', '.groovy',
    
    # C-family
    '.c', '.cpp', '.h', '.hpp', '.cc',
    
    # C#
    '.cs', '.cshtml', '.csx',
    
    # Ruby
    '.rb', '.erb',
    
    # PHP
    '.php', '.php5', '.phtml',
    
    # Go
    '.go',
    
    # Rust
    '.rs',
    
    # Swift
    '.swift',
    
    # Shell
    '.sh', '.bash', '.zsh',
    
    # Config/Data
    '.json', '.yaml', '.yml', '.toml', '.xml',
    '.conf', '.ini', '.env',
    
    # Documentation
    '.md', '.rst', '.txt'
}

# Files to always ignore
IGNORE_PATTERNS = {
    # Build outputs
    'build/*', 'dist/*', 'target/*', 'bin/*',
    '*.pyc', '__pycache__/*', '*.class',
    
    # Dependencies
    'node_modules/*', 'vendor/*', 'venv/*',
    
    # IDE files
    '.idea/*', '.vscode/*', '*.swp',
    
    # Package files
    'package-lock.json', 'yarn.lock',
    'Pipfile.lock', 'poetry.lock',
    
    # Large data files
    '*.csv', '*.json.gz', '*.sql',
    
    # Binary/Media files
    '*.pdf', '*.jpg', '*.png', '*.gif',
    '*.mp3', '*.mp4', '*.mov', '*.bin',
    '*.exe', '*.dll', '*.so', '*.dylib'
}


# File: pyproject.toml
================================================================================

[project]
name = "repl-nix-workspace"
version = "0.1.0"
description = "Add your description here"
requires-python = ">=3.11"
dependencies = [
    "gitignore-parser>=0.1.11",
]


# File: concatenated_source.txt
================================================================================



# File: git_concatenator.py
================================================================================

#!/usr/bin/env python3
"""
Git Project Source Code Concatenator

This tool concatenates source code files from a git project into a single file,
including directory structure information.
"""

import argparse
import sys
from pathlib import Path
import os
from typing import Set, List, Optional
import fnmatch
from datetime import datetime
import gitignore_parser
from extensions import SOURCE_EXTENSIONS, IGNORE_PATTERNS

class GitConcatenator:
    def __init__(self, project_path: str, output_file: str):
        self.project_path = Path(project_path).resolve()
        self.output_file = Path(output_file)
        self.gitignore_matcher = self._setup_gitignore()
        self.debug = False

    def _setup_gitignore(self) -> Optional[callable]:
        """Setup gitignore matcher if .gitignore exists"""
        gitignore_path = self.project_path / '.gitignore'
        if gitignore_path.exists():
            try:
                return gitignore_parser.parse_gitignore(gitignore_path)
            except Exception as e:
                print(f"Warning: Failed to parse .gitignore: {e}")
        return None

    def _should_include_file(self, file_path: Path) -> bool:
        """Check if file should be included based on extension and ignore rules"""
        # Skip common virtual environment and system directories
        excluded_dirs = {
            '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
            '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
            'dist', 'build', 'target'
        }

        try:
            # Convert to relative path for checking
            try:
                rel_path = file_path.relative_to(self.project_path)
            except ValueError:
                if self.debug:
                    print(f"Debug: Skipping file outside project path: {file_path}")
                return False

            # Check for excluded directories in the path
            if any(part in excluded_dirs for part in file_path.parts):
                if self.debug:
                    print(f"Debug: Skipping excluded directory: {file_path}")
                return False

            # Check if file extension is in whitelist
            if file_path.suffix.lower() not in SOURCE_EXTENSIONS:
                if self.debug:
                    print(f"Debug: Skipping non-source file: {file_path}")
                return False

            # Check custom ignore patterns
            for pattern in IGNORE_PATTERNS:
                if fnmatch.fnmatch(str(rel_path), pattern):
                    if self.debug:
                        print(f"Debug: Skipping ignored pattern {pattern}: {file_path}")
                    return False

            # Check .gitignore if available
            if self.gitignore_matcher:
                try:
                    should_include = not self.gitignore_matcher(str(file_path))
                    if self.debug and not should_include:
                        print(f"Debug: Skipping gitignored file: {file_path}")
                    return should_include
                except Exception as e:
                    print(f"Warning: gitignore matching failed for {file_path}: {e}")
                    return True

            if self.debug:
                print(f"Debug: Including file: {file_path}")
            return True

        except Exception as e:
            print(f"Warning: Error checking file {file_path}: {e}")
            return False

    def _get_file_content(self, file_path: Path) -> str:
        """Read file content with proper encoding handling"""
        try:
            # Try UTF-8 first
            with open(file_path, 'r', encoding='utf-8') as f:
                return f.read()
        except UnicodeDecodeError:
            try:
                # Fallback to latin-1
                with open(file_path, 'r', encoding='latin-1') as f:
                    return f.read()
            except Exception as e:
                print(f"Warning: Failed to read {file_path}: {e}")
                return f"ERROR: Could not read file {file_path}\n"

    def _generate_directory_structure(self) -> str:
        """Generate a tree-like directory structure"""
        structure = ["Directory Structure:", ""]

        def add_to_tree(path: Path, prefix: str = ""):
            # Skip excluded directories
            excluded_dirs = {
                '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
                '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
                'dist', 'build', 'target'
            }
            if path.name in excluded_dirs:
                return

            # Add files first
            files = sorted([p for p in path.iterdir() if p.is_file()])
            included_files = [f for f in files if self._should_include_file(f)]

            for idx, file in enumerate(included_files):
                is_last = idx == len(included_files) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {file.name}")

            # Then add directories
            dirs = sorted([p for p in path.iterdir() if p.is_dir()])
            included_dirs = [d for d in dirs if d.name not in excluded_dirs]

            for idx, dir in enumerate(included_dirs):
                is_last = idx == len(included_dirs) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {dir.name}/")
                add_to_tree(dir, prefix + ("    " if is_last else "│   "))

        add_to_tree(self.project_path)
        return "\n".join(structure)

    def concatenate(self, debug: bool = False):
        """Main method to concatenate all source files"""
        self.debug = debug
        if not self.project_path.exists():
            print(f"Error: Project path {self.project_path} does not exist")
            return False

        try:
            with open(self.output_file, 'w', encoding='utf-8') as out:
                # Write header
                header = f"""
# Project Source Code Concatenation
# Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
# Project path: {self.project_path}

"""
                out.write(header)

                # Write directory structure
                out.write(self._generate_directory_structure())
                out.write("\n\n" + "="*80 + "\n\n")

                # Process all files
                file_count = 0
                for file_path in self.project_path.rglob('*'):
                    if file_path.is_file() and self._should_include_file(file_path):
                        rel_path = file_path.relative_to(self.project_path)

                        # Write file header
                        out.write(f"\n\n# File: {rel_path}\n")
                        out.write("="*80 + "\n\n")

                        # Write file content
                        content = self._get_file_content(file_path)
                        out.write(content)
                        file_count += 1

                print(f"Successfully concatenated {file_count} files to {self.output_file}")
                return True

        except Exception as e:
            print(f"Error during concatenation: {e}")
            return False

def main():
    parser = argparse.ArgumentParser(
        description="Concatenate git project source code into a single file"
    )
    parser.add_argument(
        "project_path",
        help="Path to the git project directory"
    )
    parser.add_argument(
        "-o", "--output",
        default="concatenated_source.txt",
        help="Output file path (default: concatenated_source.txt)"
    )
    parser.add_argument(
        "-d", "--debug",
        action="store_true",
        help="Enable debug logging"
    )

    args = parser.parse_args()

    concatenator = GitConcatenator(args.project_path, args.output)
    success = concatenator.concatenate(debug=args.debug)
    sys.exit(0 if success else 1)

if __name__ == "__main__":
    main()

# File: README.md
================================================================================

git clone https://github.com/yourusername/git-concatenator.git
   cd git-concatenator
   ```

2. Ensure you have Python 3.11 or later installed:
   ```bash
   python --version
   ```

3. Install the required dependency:
   ```bash
   pip install gitignore-parser
   ```

## Usage

Basic usage:
```bash
python git_concatenator.py /path/to/project -o output.txt
```

With debug logging:
```bash
python git_concatenator.py /path/to/project -o output.txt --debug
```

### Command-line Arguments

- `project_path`: Path to the Git project directory (required)
- `-o, --output`: Output file path (default: concatenated_source.txt)
- `-d, --debug`: Enable debug logging

## Output Format

The generated file includes:
1. A timestamp and project path header
2. A visual directory structure of the project
3. The contents of each source file, clearly separated with headers

Example output:
```
# Project Source Code Concatenation
# Generated on: 2025-02-15 20:53:29
# Project path: /path/to/project

Directory Structure:
├── src/
│   ├── main.py
│   └── utils.py
└── README.md

================================================================================

# File: src/main.py
================================================================================
[File contents here]

# File: src/utils.py
================================================================================
[File contents here]

# File: codesmelt.py
================================================================================

#!/usr/bin/env python3
"""
CodeSmelt: Source Code Concatenator

This tool melts down source code files from a git project into a single file,
including directory structure information.
"""

import argparse
import sys
from pathlib import Path
import os
from typing import Set, List, Optional
import fnmatch
from datetime import datetime
import gitignore_parser
from extensions import SOURCE_EXTENSIONS, IGNORE_PATTERNS

class CodeSmelt:
    def __init__(self, project_path: str, output_file: str):
        self.project_path = Path(project_path).resolve()
        self.output_file = Path(output_file)
        self.gitignore_matcher = self._setup_gitignore()
        self.debug = False

    def _setup_gitignore(self) -> Optional[callable]:
        """Setup gitignore matcher if .gitignore exists"""
        gitignore_path = self.project_path / '.gitignore'
        if gitignore_path.exists():
            try:
                return gitignore_parser.parse_gitignore(gitignore_path)
            except Exception as e:
                print(f"Warning: Failed to parse .gitignore: {e}")
        return None

    def _should_include_file(self, file_path: Path) -> bool:
        """Check if file should be included based on extension and ignore rules"""
        # Skip common virtual environment and system directories
        excluded_dirs = {
            '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
            '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
            'dist', 'build', 'target'
        }

        try:
            # Convert to relative path for checking
            try:
                rel_path = file_path.relative_to(self.project_path)
            except ValueError:
                if self.debug:
                    print(f"Debug: Skipping file outside project path: {file_path}")
                return False

            # Check for excluded directories in the path
            if any(part in excluded_dirs for part in file_path.parts):
                if self.debug:
                    print(f"Debug: Skipping excluded directory: {file_path}")
                return False

            # Check if file extension is in whitelist
            if file_path.suffix.lower() not in SOURCE_EXTENSIONS:
                if self.debug:
                    print(f"Debug: Skipping non-source file: {file_path}")
                return False

            # Check custom ignore patterns
            for pattern in IGNORE_PATTERNS:
                if fnmatch.fnmatch(str(rel_path), pattern):
                    if self.debug:
                        print(f"Debug: Skipping ignored pattern {pattern}: {file_path}")
                    return False

            # Check .gitignore if available
            if self.gitignore_matcher:
                try:
                    should_include = not self.gitignore_matcher(str(file_path))
                    if self.debug and not should_include:
                        print(f"Debug: Skipping gitignored file: {file_path}")
                    return should_include
                except Exception as e:
                    print(f"Warning: gitignore matching failed for {file_path}: {e}")
                    return True

            if self.debug:
                print(f"Debug: Including file: {file_path}")
            return True

        except Exception as e:
            print(f"Warning: Error checking file {file_path}: {e}")
            return False

    def _get_file_content(self, file_path: Path) -> str:
        """Read file content with proper encoding handling"""
        try:
            # Try UTF-8 first
            with open(file_path, 'r', encoding='utf-8') as f:
                return f.read()
        except UnicodeDecodeError:
            try:
                # Fallback to latin-1
                with open(file_path, 'r', encoding='latin-1') as f:
                    return f.read()
            except Exception as e:
                print(f"Warning: Failed to read {file_path}: {e}")
                return f"ERROR: Could not read file {file_path}\n"

    def _generate_directory_structure(self) -> str:
        """Generate a tree-like directory structure"""
        structure = ["Directory Structure:", ""]

        def add_to_tree(path: Path, prefix: str = ""):
            # Skip excluded directories
            excluded_dirs = {
                '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
                '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
                'dist', 'build', 'target'
            }
            if path.name in excluded_dirs:
                return

            # Add files first
            files = sorted([p for p in path.iterdir() if p.is_file()])
            included_files = [f for f in files if self._should_include_file(f)]

            for idx, file in enumerate(included_files):
                is_last = idx == len(included_files) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {file.name}")

            # Then add directories
            dirs = sorted([p for p in path.iterdir() if p.is_dir()])
            included_dirs = [d for d in dirs if d.name not in excluded_dirs]

            for idx, dir in enumerate(included_dirs):
                is_last = idx == len(included_dirs) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {dir.name}/")
                add_to_tree(dir, prefix + ("    " if is_last else "│   "))

        add_to_tree(self.project_path)
        return "\n".join(structure)

    def concatenate(self, debug: bool = False):
        """Main method to concatenate all source files"""
        self.debug = debug
        if not self.project_path.exists():
            print(f"Error: Project path {self.project_path} does not exist")
            return False

        try:
            with open(self.output_file, 'w', encoding='utf-8') as out:
                # Write header
                header = f"""
# Project Source Code Concatenation
# Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
# Project path: {self.project_path}

"""
                out.write(header)

                # Write directory structure
                out.write(self._generate_directory_structure())
                out.write("\n\n" + "="*80 + "\n\n")

                # Process all files
                file_count = 0
                for file_path in self.project_path.rglob('*'):
                    if file_path.is_file() and self._should_include_file(file_path):
                        rel_path = file_path.relative_to(self.project_path)

                        # Write file header
                        out.write(f"\n\n# File: {rel_path}\n")
                        out.write("="*80 + "\n\n")

                        # Write file content
                        content = self._get_file_content(file_path)
                        out.write(content)
                        file_count += 1

                print(f"Successfully melted {file_count} files to {self.output_file}")
                return True

        except Exception as e:
            print(f"Error during melting: {e}")
            return False

def main():
    parser = argparse.ArgumentParser(
        description="CodeSmelt: Melt down your git project's source code into a single file"
    )
    parser.add_argument(
        "project_path",
        help="Path to the git project directory"
    )
    parser.add_argument(
        "-o", "--output",
        default="concatenated_source.txt",
        help="Output file path (default: concatenated_source.txt)"
    )
    parser.add_argument(
        "-d", "--debug",
        action="store_true",
        help="Enable debug logging"
    )

    args = parser.parse_args()

    concatenator = CodeSmelt(args.project_path, args.output)
    success = concatenator.concatenate(debug=args.debug)
    sys.exit(0 if success else 1)

if __name__ == "__main__":
    main()

# File: README.md
================================================================================

python --version
   ```

2. Install the required dependency:
   ```bash
   pip install gitignore-parser
   ```

## Usage

Basic usage:
```bash
python codesmelt.py /path/to/project -o output.txt
```

With debug logging:
```bash
python codesmelt.py /path/to/project -o output.txt --debug
```

### Command-line Arguments

- `project_path`: Path to the Git project directory (required)
- `-o, --output`: Output file path (default: concatenated_source.txt)
- `-d, --debug`: Enable debug logging

## Configuration

### Source File Extensions
The tool includes common source code file extensions by default (defined in `extensions.py`):
- Web: `.js`, `.ts`, `.jsx`, `.tsx`, `.vue`, `.svelte`, `.html`, `.css`, etc.
- Python: `.py`, `.pyi`, `.pyx`
- Java/Kotlin: `.java`, `.kt`, `.groovy`
- C-family: `.c`, `.cpp`, `.h`, `.hpp`
- And many more...

#### Customizing File Extensions
You can modify which file extensions are included by editing the `SOURCE_EXTENSIONS` set in `extensions.py`. For example, to include Unity3D script files while excluding other Unity files:

```python
SOURCE_EXTENSIONS = {
    # ... existing extensions ...

    # Unity3D specific
    '.cs',  # C# scripts
    '.shader', # Custom shaders
    '.asmdef', # Assembly definitions

    # ... other extensions ...
}
```

### Ignore Patterns
The tool automatically ignores files based on three levels:

1. Built-in patterns (`IGNORE_PATTERNS` in `extensions.py`):
   - Build outputs (`build/*`, `dist/*`, `*.pyc`, etc.)
   - Dependencies (`node_modules/*`, `vendor/*`, `venv/*`)
   - IDE files (`.idea/*`, `.vscode/*`)
   - Package lock files (`package-lock.json`, `poetry.lock`, etc.)
   - Binary and media files (`*.pdf`, `*.jpg`, `*.exe`, etc.)

2. Project's `.gitignore` rules (if present)
3. Directory-specific `.gitignore` rules

#### Customizing Ignore Patterns
To modify which files are ignored, you can:

1. Edit `IGNORE_PATTERNS` in `extensions.py`:
```python
IGNORE_PATTERNS = {
    # ... existing patterns ...

    # Unity3D specific ignores
    'Assets/AssetStoreTools/*',
    'Library/*',
    'Temp/*',
    'Logs/*',
    '*.unity',  # Unity scene files
    '*.meta',   # Unity meta files
    '*.prefab', # Unity prefab files

    # ... other patterns ...
}
```

2. Use your project's `.gitignore` file for project-specific exclusions

**Note**: Ignore patterns follow the same syntax as `.gitignore` files. The tool processes these rules in order:
1. Built-in `IGNORE_PATTERNS`
2. Project's root `.gitignore`
3. Directory-specific `.gitignore` files


## Tips for Using with LLMs

1. **Token Management**:
   - For large projects, consider concatenating only specific directories
   - Use the debug mode to see which files are included/excluded
   - Remove unnecessary documentation files if you're close to token limits

2. **Effective Prompting**:
   - Reference files using their relative paths as shown in the directory structure
   - Use the directory structure to ask about specific components
   - Refer to file relationships based on the visual structure

3. **Best Practices**:
   - Review the concatenated output before sending to ensure relevance
   - For large projects, break down analysis into smaller, focused components
   - Use the debug mode to verify file selection when customizing

## Output Format

The generated file includes:
1. A timestamp and project path header
2. A visual directory structure of the project
3. The contents of each source file, clearly separated with headers

Example output:
```
# Project Source Code Concatenation
# Generated on: 2025-02-15 20:53:29
# Project path: /path/to/project

Directory Structure:
├── src/
│   ├── main.py
│   └── utils.py
└── README.md

================================================================================

# File: src/main.py
================================================================================
[File contents here]

# File: src/utils.py
================================================================================
[File contents here]
```

## Troubleshooting

### Common Issues

1. **No Files Found**:
   - Verify the project path is correct
   - Check if files have supported extensions
   - Run with --debug to see which files are being filtered

2. **Missing Dependencies**:
   ```bash
   pip install --upgrade gitignore-parser

# File: codesmelt.py
================================================================================

#!/usr/bin/env python3
"""
CodeSmelt: Source Code Concatenator

This tool melts down source code files from a git project into a single file,
including directory structure information.
"""

import argparse
import sys
from pathlib import Path
import os
from typing import Set, List, Optional
import fnmatch
from datetime import datetime
import gitignore_parser
from extensions import SOURCE_EXTENSIONS, IGNORE_PATTERNS

class CodeSmelt:
    def __init__(self, project_path: str, output_file: str):
        self.project_path = Path(project_path).resolve()
        self.output_file = Path(output_file)
        self.gitignore_matcher = self._setup_gitignore()
        self.debug = False

    def _setup_gitignore(self) -> Optional[callable]:
        """Setup gitignore matcher if .gitignore exists"""
        gitignore_path = self.project_path / '.gitignore'
        if gitignore_path.exists():
            try:
                return gitignore_parser.parse_gitignore(gitignore_path)
            except Exception as e:
                print(f"Warning: Failed to parse .gitignore: {e}")
        return None

    def _should_include_file(self, file_path: Path) -> bool:
        """Check if file should be included based on extension and ignore rules"""
        # Skip common virtual environment and system directories
        excluded_dirs = {
            '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
            '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
            'dist', 'build', 'target'
        }

        try:
            # Convert to relative path for checking
            try:
                rel_path = file_path.relative_to(self.project_path)
            except ValueError:
                if self.debug:
                    print(f"Debug: Skipping file outside project path: {file_path}")
                return False

            # Check for excluded directories in the path
            if any(part in excluded_dirs for part in file_path.parts):
                if self.debug:
                    print(f"Debug: Skipping excluded directory: {file_path}")
                return False

            # Check if file extension is in whitelist
            if file_path.suffix.lower() not in SOURCE_EXTENSIONS:
                if self.debug:
                    print(f"Debug: Skipping non-source file: {file_path}")
                return False

            # Check custom ignore patterns
            for pattern in IGNORE_PATTERNS:
                if fnmatch.fnmatch(str(rel_path), pattern):
                    if self.debug:
                        print(f"Debug: Skipping ignored pattern {pattern}: {file_path}")
                    return False

            # Check .gitignore if available
            if self.gitignore_matcher:
                try:
                    should_include = not self.gitignore_matcher(str(file_path))
                    if self.debug and not should_include:
                        print(f"Debug: Skipping gitignored file: {file_path}")
                    return should_include
                except Exception as e:
                    print(f"Warning: gitignore matching failed for {file_path}: {e}")
                    return True

            if self.debug:
                print(f"Debug: Including file: {file_path}")
            return True

        except Exception as e:
            print(f"Warning: Error checking file {file_path}: {e}")
            return False

    def _get_file_content(self, file_path: Path) -> str:
        """Read file content with proper encoding handling"""
        try:
            # Try UTF-8 first
            with open(file_path, 'r', encoding='utf-8') as f:
                return f.read()
        except UnicodeDecodeError:
            try:
                # Fallback to latin-1
                with open(file_path, 'r', encoding='latin-1') as f:
                    return f.read()
            except Exception as e:
                print(f"Warning: Failed to read {file_path}: {e}")
                return f"ERROR: Could not read file {file_path}\n"

    def _generate_directory_structure(self) -> str:
        """Generate a tree-like directory structure"""
        structure = ["Directory Structure:", ""]

        def add_to_tree(path: Path, prefix: str = ""):
            # Skip excluded directories
            excluded_dirs = {
                '.git', '__pycache__', '.pythonlibs', 'venv', 'node_modules',
                '.cache', '.local', '.upm', '.config', '.npm', '.nix-profile',
                'dist', 'build', 'target'
            }
            if path.name in excluded_dirs:
                return

            # Add files first
            files = sorted([p for p in path.iterdir() if p.is_file()])
            included_files = [f for f in files if self._should_include_file(f)]

            for idx, file in enumerate(included_files):
                is_last = idx == len(included_files) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {file.name}")

            # Then add directories
            dirs = sorted([p for p in path.iterdir() if p.is_dir()])
            included_dirs = [d for d in dirs if d.name not in excluded_dirs]

            for idx, dir in enumerate(included_dirs):
                is_last = idx == len(included_dirs) - 1
                structure.append(f"{prefix}{'└──' if is_last else '├──'} {dir.name}/")
                add_to_tree(dir, prefix + ("    " if is_last else "│   "))

        add_to_tree(self.project_path)
        return "\n".join(structure)

    def concatenate(self, debug: bool = False):
        """Main method to concatenate all source files"""
        self.debug = debug
        if not self.project_path.exists():
            print(f"Error: Project path {self.project_path} does not exist")
            return False

        try:
            with open(self.output_file, 'w', encoding='utf-8') as out:
                # Write header
                header = f"""
# Project Source Code Concatenation
# Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
# Project path: {self.project_path}

"""
                out.write(header)

                # Write directory structure
                out.write(self._generate_directory_structure())
                out.write("\n\n" + "="*80 + "\n\n")

                # Process all files
                file_count = 0
                for file_path in self.project_path.rglob('*'):
                    if file_path.is_file() and self._should_include_file(file_path):
                        rel_path = file_path.relative_to(self.project_path)

                        # Write file header
                        out.write(f"\n\n# File: {rel_path}\n")
                        out.write("="*80 + "\n\n")

                        # Write file content
                        content = self._get_file_content(file_path)
                        out.write(content)
                        file_count += 1

                print(f"Successfully melted {file_count} files to {self.output_file}")
                return True

        except Exception as e:
            print(f"Error during melting: {e}")
            return False

def main():
    parser = argparse.ArgumentParser(
        description="CodeSmelt: Melt down your git project's source code into a single file",
        usage="%(prog)s [-o OUTPUT] [-d] project_path"
    )
    parser.add_argument(
        "-o", "--output",
        default="concatenated_source.txt",
        help="Output file path (default: concatenated_source.txt)"
    )
    parser.add_argument(
        "-d", "--debug",
        action="store_true",
        help="Enable debug logging"
    )
    parser.add_argument(
        "project_path",
        help="Path to the git project directory",
        nargs="?"  # Make it optional in the parser (though we'll check it's provided)
    )

    args = parser.parse_args()

    if not args.project_path:
        parser.error("project_path is required")

    concatenator = CodeSmelt(args.project_path, args.output)
    success = concatenator.concatenate(debug=args.debug)
    sys.exit(0 if success else 1)

if __name__ == "__main__":
    main()